// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tici/indexer.proto

package tipb

import (
	"context"
	"fmt"
	"io"
	"math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// IndexType represents the type of index
type IndexType int32

const (
	// Default value must be 0 in proto3
	IndexType_UNKNOWN IndexType = 0
	// Full-text index type
	IndexType_FULL_TEXT IndexType = 1
	// Custom index type
	IndexType_CUSTOM IndexType = 2
)

var IndexType_name = map[int32]string{
	0: "UNKNOWN",
	1: "FULL_TEXT",
	2: "CUSTOM",
}

var IndexType_value = map[string]int32{
	"UNKNOWN":   0,
	"FULL_TEXT": 1,
	"CUSTOM":    2,
}

func (x IndexType) String() string {
	return proto.EnumName(IndexType_name, int32(x))
}

func (IndexType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_318fc78ce72ff229, []int{0}
}

// ParserType represents the type of parser
type ParserType int32

const (
	// Default value must be 0 in proto3
	ParserType_UNKNOWN_PARSER ParserType = 0
	// Default parser
	ParserType_DEFAULT_PARSER ParserType = 1
	// Other parser types
	ParserType_OTHER_PARSER ParserType = 2
)

var ParserType_name = map[int32]string{
	0: "UNKNOWN_PARSER",
	1: "DEFAULT_PARSER",
	2: "OTHER_PARSER",
}

var ParserType_value = map[string]int32{
	"UNKNOWN_PARSER": 0,
	"DEFAULT_PARSER": 1,
	"OTHER_PARSER":   2,
}

func (x ParserType) String() string {
	return proto.EnumName(ParserType_name, int32(x))
}

func (ParserType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_318fc78ce72ff229, []int{1}
}

// CreateIndexRequest is a request to create an index
type CreateIndexRequest struct {
	// Index information
	IndexInfo *TiCIIndexInfo `protobuf:"bytes,1,opt,name=index_info,json=indexInfo,proto3" json:"index_info,omitempty"`
	// Table information
	TableInfo *TiCITableInfo `protobuf:"bytes,2,opt,name=table_info,json=tableInfo,proto3" json:"table_info,omitempty"`
}

func (m *CreateIndexRequest) Reset()         { *m = CreateIndexRequest{} }
func (m *CreateIndexRequest) String() string { return proto.CompactTextString(m) }
func (*CreateIndexRequest) ProtoMessage()    {}
func (*CreateIndexRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_318fc78ce72ff229, []int{0}
}
func (m *CreateIndexRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateIndexRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateIndexRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateIndexRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateIndexRequest.Merge(m, src)
}
func (m *CreateIndexRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateIndexRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateIndexRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateIndexRequest proto.InternalMessageInfo

func (m *CreateIndexRequest) GetIndexInfo() *TiCIIndexInfo {
	if m != nil {
		return m.IndexInfo
	}
	return nil
}

func (m *CreateIndexRequest) GetTableInfo() *TiCITableInfo {
	if m != nil {
		return m.TableInfo
	}
	return nil
}

// CreateIndexResponse is a response to the index creation request
type CreateIndexResponse struct {
	// Operation result status code, 0 means success
	Status int32 `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
	// Error message, only valid when status is non-zero
	ErrorMessage string `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// Created index ID
	IndexId string `protobuf:"bytes,3,opt,name=index_id,json=indexId,proto3" json:"index_id,omitempty"`
}

func (m *CreateIndexResponse) Reset()         { *m = CreateIndexResponse{} }
func (m *CreateIndexResponse) String() string { return proto.CompactTextString(m) }
func (*CreateIndexResponse) ProtoMessage()    {}
func (*CreateIndexResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_318fc78ce72ff229, []int{1}
}
func (m *CreateIndexResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateIndexResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateIndexResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateIndexResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateIndexResponse.Merge(m, src)
}
func (m *CreateIndexResponse) XXX_Size() int {
	return m.Size()
}
func (m *CreateIndexResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateIndexResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateIndexResponse proto.InternalMessageInfo

func (m *CreateIndexResponse) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *CreateIndexResponse) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func (m *CreateIndexResponse) GetIndexId() string {
	if m != nil {
		return m.IndexId
	}
	return ""
}

// DropIndexRequest is a request to drop an index
type DropIndexRequest struct {
	// Index ID
	TableId int64  `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	IndexId string `protobuf:"bytes,2,opt,name=index_id,json=indexId,proto3" json:"index_id,omitempty"`
}

func (m *DropIndexRequest) Reset()         { *m = DropIndexRequest{} }
func (m *DropIndexRequest) String() string { return proto.CompactTextString(m) }
func (*DropIndexRequest) ProtoMessage()    {}
func (*DropIndexRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_318fc78ce72ff229, []int{2}
}
func (m *DropIndexRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DropIndexRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DropIndexRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DropIndexRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DropIndexRequest.Merge(m, src)
}
func (m *DropIndexRequest) XXX_Size() int {
	return m.Size()
}
func (m *DropIndexRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DropIndexRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DropIndexRequest proto.InternalMessageInfo

func (m *DropIndexRequest) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *DropIndexRequest) GetIndexId() string {
	if m != nil {
		return m.IndexId
	}
	return ""
}

// DropIndexResponse is a response to the index drop request
type DropIndexResponse struct {
	// Operation result status code, 0 means success
	Status int32 `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
	// Error message, only valid when status is non-zero
	ErrorMessage string `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
}

func (m *DropIndexResponse) Reset()         { *m = DropIndexResponse{} }
func (m *DropIndexResponse) String() string { return proto.CompactTextString(m) }
func (*DropIndexResponse) ProtoMessage()    {}
func (*DropIndexResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_318fc78ce72ff229, []int{3}
}
func (m *DropIndexResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DropIndexResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DropIndexResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DropIndexResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DropIndexResponse.Merge(m, src)
}
func (m *DropIndexResponse) XXX_Size() int {
	return m.Size()
}
func (m *DropIndexResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DropIndexResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DropIndexResponse proto.InternalMessageInfo

func (m *DropIndexResponse) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *DropIndexResponse) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

// TableInfo represents table information
type TiCITableInfo struct {
	// Table ID
	TableId int64 `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	// Table name
	TableName string `protobuf:"bytes,2,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	// Database name
	DatabaseName string `protobuf:"bytes,3,opt,name=database_name,json=databaseName,proto3" json:"database_name,omitempty"`
	// Table version
	Version int64 `protobuf:"varint,4,opt,name=version,proto3" json:"version,omitempty"`
	// Column information
	Columns []*TiCIColumnInfo `protobuf:"bytes,5,rep,name=columns,proto3" json:"columns,omitempty"`
}

func (m *TiCITableInfo) Reset()         { *m = TiCITableInfo{} }
func (m *TiCITableInfo) String() string { return proto.CompactTextString(m) }
func (*TiCITableInfo) ProtoMessage()    {}
func (*TiCITableInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_318fc78ce72ff229, []int{4}
}
func (m *TiCITableInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TiCITableInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TiCITableInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TiCITableInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TiCITableInfo.Merge(m, src)
}
func (m *TiCITableInfo) XXX_Size() int {
	return m.Size()
}
func (m *TiCITableInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TiCITableInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TiCITableInfo proto.InternalMessageInfo

func (m *TiCITableInfo) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *TiCITableInfo) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *TiCITableInfo) GetDatabaseName() string {
	if m != nil {
		return m.DatabaseName
	}
	return ""
}

func (m *TiCITableInfo) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *TiCITableInfo) GetColumns() []*TiCIColumnInfo {
	if m != nil {
		return m.Columns
	}
	return nil
}

// ColumnInfo represents column information
type TiCIColumnInfo struct {
	// Column ID
	ColumnId int64 `protobuf:"varint,1,opt,name=column_id,json=columnId,proto3" json:"column_id,omitempty"`
	// Column name
	ColumnName string `protobuf:"bytes,2,opt,name=column_name,json=columnName,proto3" json:"column_name,omitempty"`
	// MySQL type
	Type int32 `protobuf:"varint,3,opt,name=type,proto3" json:"type,omitempty"`
	// Collation
	Collation int32 `protobuf:"varint,4,opt,name=collation,proto3" json:"collation,omitempty"`
	// Column length
	ColumnLength int32 `protobuf:"varint,5,opt,name=column_length,json=columnLength,proto3" json:"column_length,omitempty"`
	// Decimal places
	Decimal int32 `protobuf:"varint,6,opt,name=decimal,proto3" json:"decimal,omitempty"`
	// Flags
	Flag int32 `protobuf:"varint,7,opt,name=flag,proto3" json:"flag,omitempty"`
	// Enum elements
	Elems []string `protobuf:"bytes,8,rep,name=elems,proto3" json:"elems,omitempty"`
	// Default value
	DefaultVal []byte `protobuf:"bytes,9,opt,name=default_val,json=defaultVal,proto3" json:"default_val,omitempty"`
	// Whether it's a primary key
	IsPrimaryKey bool `protobuf:"varint,10,opt,name=is_primary_key,json=isPrimaryKey,proto3" json:"is_primary_key,omitempty"`
	// Whether it's an array
	IsArray bool `protobuf:"varint,11,opt,name=is_array,json=isArray,proto3" json:"is_array,omitempty"`
}

func (m *TiCIColumnInfo) Reset()         { *m = TiCIColumnInfo{} }
func (m *TiCIColumnInfo) String() string { return proto.CompactTextString(m) }
func (*TiCIColumnInfo) ProtoMessage()    {}
func (*TiCIColumnInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_318fc78ce72ff229, []int{5}
}
func (m *TiCIColumnInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TiCIColumnInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TiCIColumnInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TiCIColumnInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TiCIColumnInfo.Merge(m, src)
}
func (m *TiCIColumnInfo) XXX_Size() int {
	return m.Size()
}
func (m *TiCIColumnInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TiCIColumnInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TiCIColumnInfo proto.InternalMessageInfo

func (m *TiCIColumnInfo) GetColumnId() int64 {
	if m != nil {
		return m.ColumnId
	}
	return 0
}

func (m *TiCIColumnInfo) GetColumnName() string {
	if m != nil {
		return m.ColumnName
	}
	return ""
}

func (m *TiCIColumnInfo) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *TiCIColumnInfo) GetCollation() int32 {
	if m != nil {
		return m.Collation
	}
	return 0
}

func (m *TiCIColumnInfo) GetColumnLength() int32 {
	if m != nil {
		return m.ColumnLength
	}
	return 0
}

func (m *TiCIColumnInfo) GetDecimal() int32 {
	if m != nil {
		return m.Decimal
	}
	return 0
}

func (m *TiCIColumnInfo) GetFlag() int32 {
	if m != nil {
		return m.Flag
	}
	return 0
}

func (m *TiCIColumnInfo) GetElems() []string {
	if m != nil {
		return m.Elems
	}
	return nil
}

func (m *TiCIColumnInfo) GetDefaultVal() []byte {
	if m != nil {
		return m.DefaultVal
	}
	return nil
}

func (m *TiCIColumnInfo) GetIsPrimaryKey() bool {
	if m != nil {
		return m.IsPrimaryKey
	}
	return false
}

func (m *TiCIColumnInfo) GetIsArray() bool {
	if m != nil {
		return m.IsArray
	}
	return false
}

// IndexInfo represents index information
type TiCIIndexInfo struct {
	// Index ID
	IndexId int64 `protobuf:"varint,1,opt,name=index_id,json=indexId,proto3" json:"index_id,omitempty"`
	// Index name
	IndexName string `protobuf:"bytes,2,opt,name=index_name,json=indexName,proto3" json:"index_name,omitempty"`
	// Index type (fulltext, custom)
	IndexType IndexType `protobuf:"varint,3,opt,name=index_type,json=indexType,proto3,enum=tipb.tici.IndexType" json:"index_type,omitempty"`
	// Index columns
	Columns []*TiCIColumnInfo `protobuf:"bytes,4,rep,name=columns,proto3" json:"columns,omitempty"`
	// Whether the index is unique
	IsUnique bool `protobuf:"varint,5,opt,name=is_unique,json=isUnique,proto3" json:"is_unique,omitempty"`
	// Parser information
	ParserInfo *ParserInfo `protobuf:"bytes,6,opt,name=parser_info,json=parserInfo,proto3" json:"parser_info,omitempty"`
	// Other index parameters
	OtherParams map[string]string `protobuf:"bytes,7,rep,name=other_params,json=otherParams,proto3" json:"other_params,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *TiCIIndexInfo) Reset()         { *m = TiCIIndexInfo{} }
func (m *TiCIIndexInfo) String() string { return proto.CompactTextString(m) }
func (*TiCIIndexInfo) ProtoMessage()    {}
func (*TiCIIndexInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_318fc78ce72ff229, []int{6}
}
func (m *TiCIIndexInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TiCIIndexInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TiCIIndexInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TiCIIndexInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TiCIIndexInfo.Merge(m, src)
}
func (m *TiCIIndexInfo) XXX_Size() int {
	return m.Size()
}
func (m *TiCIIndexInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TiCIIndexInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TiCIIndexInfo proto.InternalMessageInfo

func (m *TiCIIndexInfo) GetIndexId() int64 {
	if m != nil {
		return m.IndexId
	}
	return 0
}

func (m *TiCIIndexInfo) GetIndexName() string {
	if m != nil {
		return m.IndexName
	}
	return ""
}

func (m *TiCIIndexInfo) GetIndexType() IndexType {
	if m != nil {
		return m.IndexType
	}
	return IndexType_UNKNOWN
}

func (m *TiCIIndexInfo) GetColumns() []*TiCIColumnInfo {
	if m != nil {
		return m.Columns
	}
	return nil
}

func (m *TiCIIndexInfo) GetIsUnique() bool {
	if m != nil {
		return m.IsUnique
	}
	return false
}

func (m *TiCIIndexInfo) GetParserInfo() *ParserInfo {
	if m != nil {
		return m.ParserInfo
	}
	return nil
}

func (m *TiCIIndexInfo) GetOtherParams() map[string]string {
	if m != nil {
		return m.OtherParams
	}
	return nil
}

// ParserInfo represents parser information
type ParserInfo struct {
	// Parser type
	ParserType ParserType `protobuf:"varint,1,opt,name=parser_type,json=parserType,proto3,enum=tipb.tici.ParserType" json:"parser_type,omitempty"`
	// Parser parameters
	ParserParams map[string]string `protobuf:"bytes,2,rep,name=parser_params,json=parserParams,proto3" json:"parser_params,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ParserInfo) Reset()         { *m = ParserInfo{} }
func (m *ParserInfo) String() string { return proto.CompactTextString(m) }
func (*ParserInfo) ProtoMessage()    {}
func (*ParserInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_318fc78ce72ff229, []int{7}
}
func (m *ParserInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParserInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParserInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ParserInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParserInfo.Merge(m, src)
}
func (m *ParserInfo) XXX_Size() int {
	return m.Size()
}
func (m *ParserInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ParserInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ParserInfo proto.InternalMessageInfo

func (m *ParserInfo) GetParserType() ParserType {
	if m != nil {
		return m.ParserType
	}
	return ParserType_UNKNOWN_PARSER
}

func (m *ParserInfo) GetParserParams() map[string]string {
	if m != nil {
		return m.ParserParams
	}
	return nil
}

// GetIndexProgressRequest is a request to get the progress of an index build
type GetIndexProgressRequest struct {
	// Table ID
	TableId int64 `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	// Index ID
	IndexId int64 `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3" json:"index_id,omitempty"`
}

func (m *GetIndexProgressRequest) Reset()         { *m = GetIndexProgressRequest{} }
func (m *GetIndexProgressRequest) String() string { return proto.CompactTextString(m) }
func (*GetIndexProgressRequest) ProtoMessage()    {}
func (*GetIndexProgressRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_318fc78ce72ff229, []int{8}
}
func (m *GetIndexProgressRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetIndexProgressRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetIndexProgressRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetIndexProgressRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetIndexProgressRequest.Merge(m, src)
}
func (m *GetIndexProgressRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetIndexProgressRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetIndexProgressRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetIndexProgressRequest proto.InternalMessageInfo

func (m *GetIndexProgressRequest) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *GetIndexProgressRequest) GetIndexId() int64 {
	if m != nil {
		return m.IndexId
	}
	return 0
}

// GetIndexProgressResponse is a response containing index build progress
type GetIndexProgressResponse struct {
	// Operation result status code, 0 means success
	Status int32 `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
	// Error message, only valid when status is non-zero
	ErrorMessage string `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// Number of documents indexed so far
	DocumentCount uint64 `protobuf:"varint,3,opt,name=document_count,json=documentCount,proto3" json:"document_count,omitempty"`
	// Build task state (PENDING, RUNNING, COMPLETED, FAILED)
	State string `protobuf:"bytes,4,opt,name=state,proto3" json:"state,omitempty"`
	// Whether index has been uploaded to S3
	IsUploaded bool `protobuf:"varint,5,opt,name=is_uploaded,json=isUploaded,proto3" json:"is_uploaded,omitempty"`
	// Last S3 upload time in RFC3339 format
	LastUploadTime string `protobuf:"bytes,6,opt,name=last_upload_time,json=lastUploadTime,proto3" json:"last_upload_time,omitempty"`
	// S3 path where the index is stored
	S3Path []string `protobuf:"bytes,7,rep,name=s3_path,json=s3Path,proto3" json:"s3_path,omitempty"`
}

func (m *GetIndexProgressResponse) Reset()         { *m = GetIndexProgressResponse{} }
func (m *GetIndexProgressResponse) String() string { return proto.CompactTextString(m) }
func (*GetIndexProgressResponse) ProtoMessage()    {}
func (*GetIndexProgressResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_318fc78ce72ff229, []int{9}
}
func (m *GetIndexProgressResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetIndexProgressResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetIndexProgressResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetIndexProgressResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetIndexProgressResponse.Merge(m, src)
}
func (m *GetIndexProgressResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetIndexProgressResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetIndexProgressResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetIndexProgressResponse proto.InternalMessageInfo

func (m *GetIndexProgressResponse) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *GetIndexProgressResponse) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func (m *GetIndexProgressResponse) GetDocumentCount() uint64 {
	if m != nil {
		return m.DocumentCount
	}
	return 0
}

func (m *GetIndexProgressResponse) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *GetIndexProgressResponse) GetIsUploaded() bool {
	if m != nil {
		return m.IsUploaded
	}
	return false
}

func (m *GetIndexProgressResponse) GetLastUploadTime() string {
	if m != nil {
		return m.LastUploadTime
	}
	return ""
}

func (m *GetIndexProgressResponse) GetS3Path() []string {
	if m != nil {
		return m.S3Path
	}
	return nil
}

func init() {
	proto.RegisterEnum("tipb.tici.IndexType", IndexType_name, IndexType_value)
	proto.RegisterEnum("tipb.tici.ParserType", ParserType_name, ParserType_value)
	proto.RegisterType((*CreateIndexRequest)(nil), "tipb.tici.CreateIndexRequest")
	proto.RegisterType((*CreateIndexResponse)(nil), "tipb.tici.CreateIndexResponse")
	proto.RegisterType((*DropIndexRequest)(nil), "tipb.tici.DropIndexRequest")
	proto.RegisterType((*DropIndexResponse)(nil), "tipb.tici.DropIndexResponse")
	proto.RegisterType((*TiCITableInfo)(nil), "tipb.tici.TiCITableInfo")
	proto.RegisterType((*TiCIColumnInfo)(nil), "tipb.tici.TiCIColumnInfo")
	proto.RegisterType((*TiCIIndexInfo)(nil), "tipb.tici.TiCIIndexInfo")
	proto.RegisterMapType((map[string]string)(nil), "tipb.tici.TiCIIndexInfo.OtherParamsEntry")
	proto.RegisterType((*ParserInfo)(nil), "tipb.tici.ParserInfo")
	proto.RegisterMapType((map[string]string)(nil), "tipb.tici.ParserInfo.ParserParamsEntry")
	proto.RegisterType((*GetIndexProgressRequest)(nil), "tipb.tici.GetIndexProgressRequest")
	proto.RegisterType((*GetIndexProgressResponse)(nil), "tipb.tici.GetIndexProgressResponse")
}

func init() { proto.RegisterFile("tici/indexer.proto", fileDescriptor_318fc78ce72ff229) }

var fileDescriptor_318fc78ce72ff229 = []byte{
	// 1030 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0x4d, 0x6f, 0x23, 0x45,
	0x13, 0xf6, 0xd8, 0xf1, 0xc7, 0x94, 0x1d, 0xbf, 0xde, 0x7e, 0x17, 0x76, 0xd6, 0xbb, 0x6b, 0x2c,
	0x2f, 0x08, 0xb3, 0x87, 0xac, 0x14, 0x4b, 0x80, 0x38, 0x80, 0x42, 0x36, 0x61, 0xa3, 0xf5, 0x26,
	0xd6, 0xc4, 0x06, 0x24, 0x0e, 0xa3, 0x8e, 0xa7, 0xe3, 0x8c, 0x98, 0xaf, 0xed, 0x6e, 0x47, 0xf8,
	0x8c, 0xc4, 0x99, 0x13, 0xe2, 0x27, 0xf0, 0x27, 0xb8, 0x23, 0x71, 0x59, 0x89, 0xcb, 0x1e, 0x51,
	0xf2, 0x27, 0x38, 0xa2, 0xae, 0xee, 0x71, 0xc6, 0xf9, 0x58, 0x01, 0xda, 0x5b, 0xf5, 0x53, 0x55,
	0x4f, 0x57, 0x55, 0x3f, 0xd3, 0xd3, 0x40, 0x64, 0x30, 0x0d, 0x1e, 0x07, 0xb1, 0xcf, 0xbe, 0x63,
	0x7c, 0x23, 0xe5, 0x89, 0x4c, 0x88, 0x2d, 0x83, 0xf4, 0x68, 0x43, 0x39, 0xda, 0xb7, 0x67, 0xc9,
	0x2c, 0x41, 0xf4, 0xb1, 0xb2, 0x74, 0x40, 0xfb, 0x7f, 0x7c, 0x2e, 0x24, 0x9a, 0x1a, 0xe8, 0xfd,
	0x60, 0x01, 0xd9, 0xe6, 0x8c, 0x4a, 0xb6, 0xa7, 0x98, 0x5c, 0xf6, 0x62, 0xce, 0x84, 0x24, 0x1f,
	0x01, 0x20, 0xb3, 0x17, 0xc4, 0xc7, 0x89, 0x63, 0x75, 0xad, 0x7e, 0x7d, 0xd3, 0xd9, 0x58, 0xb2,
	0x6f, 0x8c, 0x83, 0xed, 0x3d, 0x4c, 0xd8, 0x8b, 0x8f, 0x13, 0xd7, 0x0e, 0x32, 0x53, 0x25, 0x4a,
	0x7a, 0x14, 0x32, 0x9d, 0x58, 0xbc, 0x36, 0x71, 0xac, 0x02, 0x74, 0xa2, 0xcc, 0xcc, 0x5e, 0x04,
	0xff, 0x5f, 0xa9, 0x43, 0xa4, 0x49, 0x2c, 0x18, 0x79, 0x1b, 0x2a, 0x42, 0x52, 0x39, 0x17, 0x58,
	0x44, 0xd9, 0x35, 0x2b, 0xf2, 0x10, 0xd6, 0x19, 0xe7, 0x09, 0xf7, 0x22, 0x26, 0x04, 0x9d, 0x31,
	0xdc, 0xca, 0x76, 0x1b, 0x08, 0x3e, 0xd7, 0x18, 0xb9, 0x0b, 0x35, 0xd3, 0x85, 0xef, 0x94, 0xd0,
	0x5f, 0xd5, 0x95, 0xfa, 0xbd, 0xa7, 0xd0, 0x7a, 0xc2, 0x93, 0x74, 0xa5, 0xe9, 0xbb, 0x50, 0x33,
	0xb5, 0xfb, 0xb8, 0x5b, 0xc9, 0xad, 0xea, 0xfa, 0xfc, 0x15, 0xa6, 0xe2, 0x2a, 0xd3, 0x08, 0x6e,
	0xe5, 0x98, 0xde, 0x40, 0xd9, 0xbd, 0x5f, 0x2d, 0x58, 0x5f, 0x99, 0xd3, 0xeb, 0x2a, 0x7b, 0x90,
	0x0d, 0x3c, 0xa6, 0x51, 0x46, 0xa7, 0xc7, 0xba, 0x4f, 0x23, 0xa6, 0x36, 0xf4, 0xa9, 0xa4, 0x47,
	0x54, 0x98, 0x08, 0x3d, 0x87, 0x46, 0x06, 0x62, 0x90, 0x03, 0xd5, 0x53, 0xc6, 0x45, 0x90, 0xc4,
	0xce, 0x9a, 0x66, 0x37, 0x4b, 0x32, 0x80, 0xea, 0x34, 0x09, 0xe7, 0x51, 0x2c, 0x9c, 0x72, 0xb7,
	0xd4, 0xaf, 0x6f, 0xde, 0xbd, 0x74, 0x96, 0xdb, 0xe8, 0xc5, 0xc3, 0xcc, 0x22, 0x7b, 0xbf, 0x17,
	0xa1, 0xb9, 0xea, 0x23, 0xf7, 0xc0, 0xd6, 0xde, 0x8b, 0x0e, 0x6a, 0x1a, 0xd8, 0xf3, 0xc9, 0x3b,
	0x50, 0x37, 0xce, 0x5c, 0x0f, 0xa0, 0x21, 0xac, 0x8f, 0xc0, 0x9a, 0x5c, 0xa4, 0xba, 0xf6, 0xb2,
	0x8b, 0x36, 0xb9, 0x8f, 0x8c, 0x21, 0x95, 0x59, 0xd5, 0x65, 0xf7, 0x02, 0x50, 0x6d, 0x1b, 0xca,
	0x90, 0xc5, 0x33, 0x79, 0xe2, 0x94, 0x31, 0xa2, 0xa1, 0xc1, 0x21, 0x62, 0xaa, 0x6d, 0x9f, 0x4d,
	0x83, 0x88, 0x86, 0x4e, 0x05, 0xdd, 0xd9, 0x52, 0x6d, 0x78, 0x1c, 0xd2, 0x99, 0x53, 0xd5, 0x1b,
	0x2a, 0x9b, 0xdc, 0x86, 0x32, 0x0b, 0x59, 0x24, 0x9c, 0x5a, 0xb7, 0xd4, 0xb7, 0x5d, 0xbd, 0x50,
	0xb5, 0xfb, 0xec, 0x98, 0xce, 0x43, 0xe9, 0x9d, 0xd2, 0xd0, 0xb1, 0xbb, 0x56, 0xbf, 0xe1, 0x82,
	0x81, 0xbe, 0xa4, 0x21, 0x79, 0x17, 0x9a, 0x81, 0xf0, 0x52, 0x1e, 0x44, 0x94, 0x2f, 0xbc, 0x6f,
	0xd9, 0xc2, 0x81, 0xae, 0xd5, 0xaf, 0xb9, 0x8d, 0x40, 0x8c, 0x34, 0xf8, 0x8c, 0x2d, 0x50, 0x5f,
	0xc2, 0xa3, 0x9c, 0xd3, 0x85, 0x53, 0x47, 0x7f, 0x35, 0x10, 0x5b, 0x6a, 0xd9, 0xfb, 0xa9, 0xa4,
	0xd5, 0xb0, 0xfc, 0xdc, 0x56, 0xc4, 0x68, 0xd4, 0x60, 0xc4, 0xa8, 0xd4, 0xa0, 0x5d, 0x79, 0x35,
	0x20, 0x82, 0x83, 0x1c, 0x64, 0xee, 0xe5, 0x38, 0x9b, 0x9b, 0xb7, 0x73, 0x27, 0x8a, 0x7b, 0x8c,
	0x17, 0x29, 0x33, 0x49, 0xca, 0xcc, 0x6b, 0x60, 0xed, 0x9f, 0x6a, 0x40, 0x1d, 0x78, 0x20, 0xbc,
	0x79, 0x1c, 0xbc, 0x98, 0x33, 0x1c, 0x7e, 0xcd, 0xad, 0x05, 0x62, 0x82, 0x6b, 0xf2, 0x21, 0xd4,
	0x53, 0xca, 0x05, 0xe3, 0xfa, 0x96, 0xa8, 0xe0, 0x2d, 0xf1, 0x56, 0x8e, 0x75, 0x84, 0x5e, 0x64,
	0x84, 0x74, 0x69, 0x93, 0x21, 0x34, 0x12, 0x79, 0xc2, 0xb8, 0x97, 0x52, 0x4e, 0x23, 0xe1, 0x54,
	0xb1, 0x9c, 0x0f, 0x6e, 0xba, 0x97, 0x36, 0x0e, 0x54, 0xf0, 0x08, 0x63, 0x77, 0x62, 0xc9, 0x17,
	0x6e, 0x3d, 0xb9, 0x40, 0xda, 0x9f, 0x42, 0xeb, 0x72, 0x00, 0x69, 0x41, 0x49, 0x1d, 0x91, 0x85,
	0x83, 0x53, 0xa6, 0x3a, 0xf6, 0x53, 0x1a, 0xce, 0xb3, 0x61, 0xea, 0xc5, 0x27, 0xc5, 0x8f, 0xad,
	0xde, 0x1f, 0x16, 0xc0, 0x45, 0xa1, 0xb9, 0xa6, 0x70, 0xb8, 0x16, 0x0e, 0xf7, 0x6a, 0x53, 0x38,
	0x5d, 0xd3, 0x14, 0x8e, 0x77, 0x08, 0xeb, 0x26, 0xcf, 0x74, 0x55, 0xc4, 0xae, 0xde, 0xbf, 0x76,
	0x1c, 0xc6, 0xcc, 0xf7, 0xd4, 0x48, 0x73, 0x50, 0xfb, 0x33, 0xb8, 0x75, 0x25, 0xe4, 0x5f, 0x75,
	0x75, 0x00, 0x77, 0xbe, 0x60, 0x12, 0x67, 0x38, 0xe2, 0xc9, 0x8c, 0x33, 0x21, 0xfe, 0xc3, 0xfd,
	0x78, 0x21, 0xc9, 0xde, 0x5f, 0x16, 0x38, 0x57, 0x19, 0xdf, 0xc4, 0xf5, 0xfe, 0x1e, 0x34, 0xfd,
	0x64, 0x3a, 0x8f, 0x58, 0x2c, 0xbd, 0x69, 0x32, 0x8f, 0x25, 0x2a, 0x7a, 0xcd, 0x5d, 0xcf, 0xd0,
	0x6d, 0x05, 0xaa, 0x5e, 0x15, 0x2b, 0xc3, 0x5b, 0xc2, 0x76, 0xf5, 0x42, 0x7d, 0xb8, 0x4a, 0xa0,
	0x69, 0x98, 0x50, 0x9f, 0xf9, 0x46, 0xa2, 0x10, 0x88, 0x89, 0x41, 0x48, 0x1f, 0x5a, 0x21, 0x15,
	0xd2, 0x84, 0x78, 0x32, 0x88, 0x18, 0x2a, 0xd5, 0x76, 0x9b, 0x0a, 0xd7, 0x71, 0xe3, 0x20, 0x62,
	0xe4, 0x0e, 0x54, 0xc5, 0xc0, 0x4b, 0xa9, 0x3c, 0x41, 0x45, 0xda, 0x6e, 0x45, 0x0c, 0x46, 0x54,
	0x9e, 0x3c, 0x1a, 0x80, 0xbd, 0xfc, 0xa2, 0x48, 0x1d, 0xaa, 0x93, 0xfd, 0x67, 0xfb, 0x07, 0x5f,
	0xed, 0xb7, 0x0a, 0x64, 0x1d, 0xec, 0xdd, 0xc9, 0x70, 0xe8, 0x8d, 0x77, 0xbe, 0x1e, 0xb7, 0x2c,
	0x02, 0x50, 0xd9, 0x9e, 0x1c, 0x8e, 0x0f, 0x9e, 0xb7, 0x8a, 0x8f, 0x76, 0x33, 0x55, 0x61, 0x16,
	0x81, 0xa6, 0xc9, 0xf2, 0x46, 0x5b, 0xee, 0xe1, 0x8e, 0xdb, 0x2a, 0x28, 0xec, 0xc9, 0xce, 0xee,
	0xd6, 0x64, 0x38, 0xce, 0x30, 0x8b, 0xb4, 0xa0, 0x71, 0x30, 0x7e, 0xba, 0xe3, 0x66, 0x48, 0x71,
	0xf3, 0xfb, 0x22, 0x34, 0xf7, 0xf4, 0xeb, 0xe0, 0x90, 0xf1, 0xd3, 0x60, 0xaa, 0xa4, 0x56, 0xcf,
	0xfd, 0x63, 0xc9, 0x83, 0x9c, 0xc4, 0xae, 0xbe, 0x01, 0xda, 0x9d, 0x9b, 0xdc, 0xe6, 0xec, 0x76,
	0xc1, 0x5e, 0xfe, 0xf8, 0xc8, 0xbd, 0x5c, 0xf0, 0xe5, 0x1f, 0x6b, 0xfb, 0xfe, 0xf5, 0x4e, 0xc3,
	0xf3, 0x0d, 0xb4, 0x2e, 0xeb, 0x83, 0xf4, 0x72, 0x19, 0x37, 0xc8, 0xb1, 0xfd, 0xf0, 0xb5, 0x31,
	0x9a, 0xfc, 0xf3, 0xee, 0xab, 0x5f, 0x6a, 0xd6, 0x6f, 0x67, 0x1d, 0xeb, 0xe5, 0x59, 0xc7, 0xfa,
	0xf3, 0xac, 0x63, 0xfd, 0x78, 0xde, 0x29, 0xfc, 0x7c, 0xde, 0x29, 0xbc, 0x3c, 0xef, 0x14, 0x5e,
	0x9d, 0x77, 0x0a, 0x47, 0x15, 0x7c, 0x08, 0x0d, 0xfe, 0x0e, 0x00, 0x00, 0xff, 0xff, 0x29, 0xbd,
	0xfb, 0x36, 0x50, 0x09, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// IndexerServiceClient is the client API for IndexerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type IndexerServiceClient interface {
	// CreateIndex creates a new index
	CreateIndex(ctx context.Context, in *CreateIndexRequest, opts ...grpc.CallOption) (*CreateIndexResponse, error)
	// DropIndex removes an existing index
	DropIndex(ctx context.Context, in *DropIndexRequest, opts ...grpc.CallOption) (*DropIndexResponse, error)
	// GetIndexProgress retrieves the current progress of an index build
	GetIndexProgress(ctx context.Context, in *GetIndexProgressRequest, opts ...grpc.CallOption) (*GetIndexProgressResponse, error)
}

type indexerServiceClient struct {
	cc *grpc.ClientConn
}

func NewIndexerServiceClient(cc *grpc.ClientConn) IndexerServiceClient {
	return &indexerServiceClient{cc}
}

func (c *indexerServiceClient) CreateIndex(ctx context.Context, in *CreateIndexRequest, opts ...grpc.CallOption) (*CreateIndexResponse, error) {
	out := new(CreateIndexResponse)
	err := c.cc.Invoke(ctx, "/tipb.tici.IndexerService/CreateIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *indexerServiceClient) DropIndex(ctx context.Context, in *DropIndexRequest, opts ...grpc.CallOption) (*DropIndexResponse, error) {
	out := new(DropIndexResponse)
	err := c.cc.Invoke(ctx, "/tipb.tici.IndexerService/DropIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *indexerServiceClient) GetIndexProgress(ctx context.Context, in *GetIndexProgressRequest, opts ...grpc.CallOption) (*GetIndexProgressResponse, error) {
	out := new(GetIndexProgressResponse)
	err := c.cc.Invoke(ctx, "/tipb.tici.IndexerService/GetIndexProgress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IndexerServiceServer is the server API for IndexerService service.
type IndexerServiceServer interface {
	// CreateIndex creates a new index
	CreateIndex(context.Context, *CreateIndexRequest) (*CreateIndexResponse, error)
	// DropIndex removes an existing index
	DropIndex(context.Context, *DropIndexRequest) (*DropIndexResponse, error)
	// GetIndexProgress retrieves the current progress of an index build
	GetIndexProgress(context.Context, *GetIndexProgressRequest) (*GetIndexProgressResponse, error)
}

// UnimplementedIndexerServiceServer can be embedded to have forward compatible implementations.
type UnimplementedIndexerServiceServer struct {
}

func (*UnimplementedIndexerServiceServer) CreateIndex(ctx context.Context, req *CreateIndexRequest) (*CreateIndexResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateIndex not implemented")
}
func (*UnimplementedIndexerServiceServer) DropIndex(ctx context.Context, req *DropIndexRequest) (*DropIndexResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DropIndex not implemented")
}
func (*UnimplementedIndexerServiceServer) GetIndexProgress(ctx context.Context, req *GetIndexProgressRequest) (*GetIndexProgressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIndexProgress not implemented")
}

func RegisterIndexerServiceServer(s *grpc.Server, srv IndexerServiceServer) {
	s.RegisterService(&_IndexerService_serviceDesc, srv)
}

func _IndexerService_CreateIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateIndexRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IndexerServiceServer).CreateIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tipb.tici.IndexerService/CreateIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IndexerServiceServer).CreateIndex(ctx, req.(*CreateIndexRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IndexerService_DropIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DropIndexRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IndexerServiceServer).DropIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tipb.tici.IndexerService/DropIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IndexerServiceServer).DropIndex(ctx, req.(*DropIndexRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IndexerService_GetIndexProgress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIndexProgressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IndexerServiceServer).GetIndexProgress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tipb.tici.IndexerService/GetIndexProgress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IndexerServiceServer).GetIndexProgress(ctx, req.(*GetIndexProgressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _IndexerService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tipb.tici.IndexerService",
	HandlerType: (*IndexerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateIndex",
			Handler:    _IndexerService_CreateIndex_Handler,
		},
		{
			MethodName: "DropIndex",
			Handler:    _IndexerService_DropIndex_Handler,
		},
		{
			MethodName: "GetIndexProgress",
			Handler:    _IndexerService_GetIndexProgress_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "tici/indexer.proto",
}

func (m *CreateIndexRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateIndexRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateIndexRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TableInfo != nil {
		{
			size, err := m.TableInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIndexer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.IndexInfo != nil {
		{
			size, err := m.IndexInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIndexer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateIndexResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateIndexResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateIndexResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IndexId) > 0 {
		i -= len(m.IndexId)
		copy(dAtA[i:], m.IndexId)
		i = encodeVarintIndexer(dAtA, i, uint64(len(m.IndexId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintIndexer(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintIndexer(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DropIndexRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropIndexRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DropIndexRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IndexId) > 0 {
		i -= len(m.IndexId)
		copy(dAtA[i:], m.IndexId)
		i = encodeVarintIndexer(dAtA, i, uint64(len(m.IndexId)))
		i--
		dAtA[i] = 0x12
	}
	if m.TableId != 0 {
		i = encodeVarintIndexer(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DropIndexResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropIndexResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DropIndexResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintIndexer(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintIndexer(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TiCITableInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TiCITableInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TiCITableInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Columns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintIndexer(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Version != 0 {
		i = encodeVarintIndexer(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x20
	}
	if len(m.DatabaseName) > 0 {
		i -= len(m.DatabaseName)
		copy(dAtA[i:], m.DatabaseName)
		i = encodeVarintIndexer(dAtA, i, uint64(len(m.DatabaseName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TableName) > 0 {
		i -= len(m.TableName)
		copy(dAtA[i:], m.TableName)
		i = encodeVarintIndexer(dAtA, i, uint64(len(m.TableName)))
		i--
		dAtA[i] = 0x12
	}
	if m.TableId != 0 {
		i = encodeVarintIndexer(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TiCIColumnInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TiCIColumnInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TiCIColumnInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsArray {
		i--
		if m.IsArray {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.IsPrimaryKey {
		i--
		if m.IsPrimaryKey {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.DefaultVal) > 0 {
		i -= len(m.DefaultVal)
		copy(dAtA[i:], m.DefaultVal)
		i = encodeVarintIndexer(dAtA, i, uint64(len(m.DefaultVal)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Elems) > 0 {
		for iNdEx := len(m.Elems) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Elems[iNdEx])
			copy(dAtA[i:], m.Elems[iNdEx])
			i = encodeVarintIndexer(dAtA, i, uint64(len(m.Elems[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.Flag != 0 {
		i = encodeVarintIndexer(dAtA, i, uint64(m.Flag))
		i--
		dAtA[i] = 0x38
	}
	if m.Decimal != 0 {
		i = encodeVarintIndexer(dAtA, i, uint64(m.Decimal))
		i--
		dAtA[i] = 0x30
	}
	if m.ColumnLength != 0 {
		i = encodeVarintIndexer(dAtA, i, uint64(m.ColumnLength))
		i--
		dAtA[i] = 0x28
	}
	if m.Collation != 0 {
		i = encodeVarintIndexer(dAtA, i, uint64(m.Collation))
		i--
		dAtA[i] = 0x20
	}
	if m.Type != 0 {
		i = encodeVarintIndexer(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ColumnName) > 0 {
		i -= len(m.ColumnName)
		copy(dAtA[i:], m.ColumnName)
		i = encodeVarintIndexer(dAtA, i, uint64(len(m.ColumnName)))
		i--
		dAtA[i] = 0x12
	}
	if m.ColumnId != 0 {
		i = encodeVarintIndexer(dAtA, i, uint64(m.ColumnId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TiCIIndexInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TiCIIndexInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TiCIIndexInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OtherParams) > 0 {
		for k := range m.OtherParams {
			v := m.OtherParams[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintIndexer(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintIndexer(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintIndexer(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.ParserInfo != nil {
		{
			size, err := m.ParserInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIndexer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.IsUnique {
		i--
		if m.IsUnique {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Columns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintIndexer(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.IndexType != 0 {
		i = encodeVarintIndexer(dAtA, i, uint64(m.IndexType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.IndexName) > 0 {
		i -= len(m.IndexName)
		copy(dAtA[i:], m.IndexName)
		i = encodeVarintIndexer(dAtA, i, uint64(len(m.IndexName)))
		i--
		dAtA[i] = 0x12
	}
	if m.IndexId != 0 {
		i = encodeVarintIndexer(dAtA, i, uint64(m.IndexId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ParserInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParserInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ParserInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ParserParams) > 0 {
		for k := range m.ParserParams {
			v := m.ParserParams[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintIndexer(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintIndexer(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintIndexer(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ParserType != 0 {
		i = encodeVarintIndexer(dAtA, i, uint64(m.ParserType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetIndexProgressRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetIndexProgressRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetIndexProgressRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IndexId != 0 {
		i = encodeVarintIndexer(dAtA, i, uint64(m.IndexId))
		i--
		dAtA[i] = 0x10
	}
	if m.TableId != 0 {
		i = encodeVarintIndexer(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetIndexProgressResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetIndexProgressResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetIndexProgressResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.S3Path) > 0 {
		for iNdEx := len(m.S3Path) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.S3Path[iNdEx])
			copy(dAtA[i:], m.S3Path[iNdEx])
			i = encodeVarintIndexer(dAtA, i, uint64(len(m.S3Path[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.LastUploadTime) > 0 {
		i -= len(m.LastUploadTime)
		copy(dAtA[i:], m.LastUploadTime)
		i = encodeVarintIndexer(dAtA, i, uint64(len(m.LastUploadTime)))
		i--
		dAtA[i] = 0x32
	}
	if m.IsUploaded {
		i--
		if m.IsUploaded {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintIndexer(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0x22
	}
	if m.DocumentCount != 0 {
		i = encodeVarintIndexer(dAtA, i, uint64(m.DocumentCount))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintIndexer(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintIndexer(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintIndexer(dAtA []byte, offset int, v uint64) int {
	offset -= sovIndexer(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CreateIndexRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IndexInfo != nil {
		l = m.IndexInfo.Size()
		n += 1 + l + sovIndexer(uint64(l))
	}
	if m.TableInfo != nil {
		l = m.TableInfo.Size()
		n += 1 + l + sovIndexer(uint64(l))
	}
	return n
}

func (m *CreateIndexResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovIndexer(uint64(m.Status))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovIndexer(uint64(l))
	}
	l = len(m.IndexId)
	if l > 0 {
		n += 1 + l + sovIndexer(uint64(l))
	}
	return n
}

func (m *DropIndexRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableId != 0 {
		n += 1 + sovIndexer(uint64(m.TableId))
	}
	l = len(m.IndexId)
	if l > 0 {
		n += 1 + l + sovIndexer(uint64(l))
	}
	return n
}

func (m *DropIndexResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovIndexer(uint64(m.Status))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovIndexer(uint64(l))
	}
	return n
}

func (m *TiCITableInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableId != 0 {
		n += 1 + sovIndexer(uint64(m.TableId))
	}
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovIndexer(uint64(l))
	}
	l = len(m.DatabaseName)
	if l > 0 {
		n += 1 + l + sovIndexer(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovIndexer(uint64(m.Version))
	}
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovIndexer(uint64(l))
		}
	}
	return n
}

func (m *TiCIColumnInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ColumnId != 0 {
		n += 1 + sovIndexer(uint64(m.ColumnId))
	}
	l = len(m.ColumnName)
	if l > 0 {
		n += 1 + l + sovIndexer(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovIndexer(uint64(m.Type))
	}
	if m.Collation != 0 {
		n += 1 + sovIndexer(uint64(m.Collation))
	}
	if m.ColumnLength != 0 {
		n += 1 + sovIndexer(uint64(m.ColumnLength))
	}
	if m.Decimal != 0 {
		n += 1 + sovIndexer(uint64(m.Decimal))
	}
	if m.Flag != 0 {
		n += 1 + sovIndexer(uint64(m.Flag))
	}
	if len(m.Elems) > 0 {
		for _, s := range m.Elems {
			l = len(s)
			n += 1 + l + sovIndexer(uint64(l))
		}
	}
	l = len(m.DefaultVal)
	if l > 0 {
		n += 1 + l + sovIndexer(uint64(l))
	}
	if m.IsPrimaryKey {
		n += 2
	}
	if m.IsArray {
		n += 2
	}
	return n
}

func (m *TiCIIndexInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IndexId != 0 {
		n += 1 + sovIndexer(uint64(m.IndexId))
	}
	l = len(m.IndexName)
	if l > 0 {
		n += 1 + l + sovIndexer(uint64(l))
	}
	if m.IndexType != 0 {
		n += 1 + sovIndexer(uint64(m.IndexType))
	}
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovIndexer(uint64(l))
		}
	}
	if m.IsUnique {
		n += 2
	}
	if m.ParserInfo != nil {
		l = m.ParserInfo.Size()
		n += 1 + l + sovIndexer(uint64(l))
	}
	if len(m.OtherParams) > 0 {
		for k, v := range m.OtherParams {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIndexer(uint64(len(k))) + 1 + len(v) + sovIndexer(uint64(len(v)))
			n += mapEntrySize + 1 + sovIndexer(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ParserInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ParserType != 0 {
		n += 1 + sovIndexer(uint64(m.ParserType))
	}
	if len(m.ParserParams) > 0 {
		for k, v := range m.ParserParams {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovIndexer(uint64(len(k))) + 1 + len(v) + sovIndexer(uint64(len(v)))
			n += mapEntrySize + 1 + sovIndexer(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *GetIndexProgressRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableId != 0 {
		n += 1 + sovIndexer(uint64(m.TableId))
	}
	if m.IndexId != 0 {
		n += 1 + sovIndexer(uint64(m.IndexId))
	}
	return n
}

func (m *GetIndexProgressResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovIndexer(uint64(m.Status))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovIndexer(uint64(l))
	}
	if m.DocumentCount != 0 {
		n += 1 + sovIndexer(uint64(m.DocumentCount))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovIndexer(uint64(l))
	}
	if m.IsUploaded {
		n += 2
	}
	l = len(m.LastUploadTime)
	if l > 0 {
		n += 1 + l + sovIndexer(uint64(l))
	}
	if len(m.S3Path) > 0 {
		for _, s := range m.S3Path {
			l = len(s)
			n += 1 + l + sovIndexer(uint64(l))
		}
	}
	return n
}

func sovIndexer(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozIndexer(x uint64) (n int) {
	return sovIndexer(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CreateIndexRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateIndexRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateIndexRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IndexInfo == nil {
				m.IndexInfo = &TiCIIndexInfo{}
			}
			if err := m.IndexInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableInfo == nil {
				m.TableInfo = &TiCITableInfo{}
			}
			if err := m.TableInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthIndexer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateIndexResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateIndexResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateIndexResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIndexer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIndexer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIndexer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIndexer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthIndexer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropIndexRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropIndexRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropIndexRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIndexer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIndexer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthIndexer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropIndexResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropIndexResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropIndexResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIndexer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIndexer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthIndexer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TiCITableInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TiCITableInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TiCITableInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIndexer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIndexer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIndexer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIndexer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatabaseName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &TiCIColumnInfo{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthIndexer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TiCIColumnInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TiCIColumnInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TiCIColumnInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnId", wireType)
			}
			m.ColumnId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIndexer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIndexer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColumnName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collation", wireType)
			}
			m.Collation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Collation |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnLength", wireType)
			}
			m.ColumnLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decimal", wireType)
			}
			m.Decimal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Decimal |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			m.Flag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Elems", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIndexer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIndexer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Elems = append(m.Elems, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultVal", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIndexer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIndexer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultVal = append(m.DefaultVal[:0], dAtA[iNdEx:postIndex]...)
			if m.DefaultVal == nil {
				m.DefaultVal = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPrimaryKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPrimaryKey = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsArray", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsArray = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipIndexer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthIndexer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TiCIIndexInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TiCIIndexInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TiCIIndexInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			m.IndexId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIndexer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIndexer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexType", wireType)
			}
			m.IndexType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexType |= IndexType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &TiCIColumnInfo{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUnique", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsUnique = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParserInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParserInfo == nil {
				m.ParserInfo = &ParserInfo{}
			}
			if err := m.ParserInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OtherParams == nil {
				m.OtherParams = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIndexer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIndexer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIndexer
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIndexer
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIndexer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIndexer
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIndexer
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIndexer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthIndexer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.OtherParams[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthIndexer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParserInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParserInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParserInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParserType", wireType)
			}
			m.ParserType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParserType |= ParserType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParserParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParserParams == nil {
				m.ParserParams = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIndexer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIndexer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthIndexer
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthIndexer
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIndexer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthIndexer
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthIndexer
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipIndexer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthIndexer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ParserParams[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthIndexer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetIndexProgressRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetIndexProgressRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetIndexProgressRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			m.IndexId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIndexer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthIndexer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetIndexProgressResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetIndexProgressResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetIndexProgressResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIndexer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIndexer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocumentCount", wireType)
			}
			m.DocumentCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DocumentCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIndexer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIndexer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUploaded", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsUploaded = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUploadTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIndexer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIndexer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastUploadTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field S3Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIndexer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIndexer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.S3Path = append(m.S3Path, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthIndexer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipIndexer(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowIndexer
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIndexer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthIndexer
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupIndexer
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthIndexer
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthIndexer        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowIndexer          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupIndexer = fmt.Errorf("proto: unexpected end of group")
)
