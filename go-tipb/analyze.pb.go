// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: analyze.proto

/*
Package tipb is a generated protocol buffer package.

It is generated from these files:

	analyze.proto
	checksum.proto
	executor.proto
	explain.proto
	expression.proto
	metadata.proto
	resourcetag.proto
	schema.proto
	select.proto
	topsql_agent.proto
	trace.proto

It has these top-level messages:

	AnalyzeReq
	AnalyzeIndexReq
	AnalyzeColumnsReq
	AnalyzeMixedResp
	AnalyzeColumnGroup
	AnalyzeColumnsResp
	AnalyzeIndexResp
	Bucket
	Histogram
	FMSketch
	SampleCollector
	RowSampleCollector
	RowSample
	CMSketchRow
	CMSketchTopN
	CMSketch
	ChecksumRewriteRule
	ChecksumRequest
	ChecksumResponse
	Executor
	ExchangeSender
	EncodedBytesSlice
	ExchangeReceiver
	ANNQueryInfo
	TableScan
	PartitionTableScan
	Join
	RuntimeFilter
	IndexScan
	Selection
	Projection
	Aggregation
	TopN
	Limit
	Kill
	ExecutorExecutionSummary
	TiFlashExecutionInfo
	TiFlashRegionNumOfInstance
	TiFlashScanContext
	Sort
	WindowFrameBound
	WindowFrame
	Window
	GroupingExpr
	GroupingSet
	Expand
	ExprSlice
	Expand2
	ExplainData
	ExplainOperator
	AccessObject
	DynamicPartitionAccessObjects
	DynamicPartitionAccessObject
	ScanAccessObject
	IndexAccess
	FieldType
	Expr
	RpnExpr
	ByItem
	InUnionMetadata
	CompareInMetadata
	GroupingMark
	GroupingFunctionMetadata
	ResourceGroupTag
	TableInfo
	ColumnInfo
	IndexInfo
	KeyRange
	Row
	Error
	SelectResponse
	Chunk
	RowMeta
	DAGRequest
	ChunkMemoryLayout
	UserIdentity
	StreamResponse
	TopSQLRecord
	TopSQLRecordItem
	SQLMeta
	PlanMeta
	EmptyResponse
	TopSQLSubRequest
	TopSQLSubResponse
*/
package tipb

import (
	"fmt"

	proto "github.com/golang/protobuf/proto"

	math "math"

	encoding_binary "encoding/binary"

	io "io"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type AnalyzeType int32

const (
	AnalyzeType_TypeIndex        AnalyzeType = 0
	AnalyzeType_TypeColumn       AnalyzeType = 1
	AnalyzeType_TypeCommonHandle AnalyzeType = 2
	AnalyzeType_TypeSampleIndex  AnalyzeType = 3
	AnalyzeType_TypeMixed        AnalyzeType = 4
	AnalyzeType_TypeFullSampling AnalyzeType = 5
)

var AnalyzeType_name = map[int32]string{
	0: "TypeIndex",
	1: "TypeColumn",
	2: "TypeCommonHandle",
	3: "TypeSampleIndex",
	4: "TypeMixed",
	5: "TypeFullSampling",
}
var AnalyzeType_value = map[string]int32{
	"TypeIndex":        0,
	"TypeColumn":       1,
	"TypeCommonHandle": 2,
	"TypeSampleIndex":  3,
	"TypeMixed":        4,
	"TypeFullSampling": 5,
}

func (x AnalyzeType) Enum() *AnalyzeType {
	p := new(AnalyzeType)
	*p = x
	return p
}
func (x AnalyzeType) String() string {
	return proto.EnumName(AnalyzeType_name, int32(x))
}
func (x *AnalyzeType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(AnalyzeType_value, data, "AnalyzeType")
	if err != nil {
		return err
	}
	*x = AnalyzeType(value)
	return nil
}
func (AnalyzeType) EnumDescriptor() ([]byte, []int) { return fileDescriptorAnalyze, []int{0} }

type AnalyzeReq struct {
	Tp AnalyzeType `protobuf:"varint,1,opt,name=tp,enum=tipb.AnalyzeType" json:"tp"`
	// Deprecated. Start Ts has been moved to coprocessor.Request.
	StartTsFallback  *uint64            `protobuf:"varint,2,opt,name=start_ts_fallback,json=startTsFallback" json:"start_ts_fallback,omitempty"`
	Flags            uint64             `protobuf:"varint,3,opt,name=flags" json:"flags"`
	TimeZoneOffset   int64              `protobuf:"varint,4,opt,name=time_zone_offset,json=timeZoneOffset" json:"time_zone_offset"`
	IdxReq           *AnalyzeIndexReq   `protobuf:"bytes,5,opt,name=idx_req,json=idxReq" json:"idx_req,omitempty"`
	ColReq           *AnalyzeColumnsReq `protobuf:"bytes,6,opt,name=col_req,json=colReq" json:"col_req,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *AnalyzeReq) Reset()                    { *m = AnalyzeReq{} }
func (m *AnalyzeReq) String() string            { return proto.CompactTextString(m) }
func (*AnalyzeReq) ProtoMessage()               {}
func (*AnalyzeReq) Descriptor() ([]byte, []int) { return fileDescriptorAnalyze, []int{0} }

func (m *AnalyzeReq) GetTp() AnalyzeType {
	if m != nil {
		return m.Tp
	}
	return AnalyzeType_TypeIndex
}

func (m *AnalyzeReq) GetStartTsFallback() uint64 {
	if m != nil && m.StartTsFallback != nil {
		return *m.StartTsFallback
	}
	return 0
}

func (m *AnalyzeReq) GetFlags() uint64 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *AnalyzeReq) GetTimeZoneOffset() int64 {
	if m != nil {
		return m.TimeZoneOffset
	}
	return 0
}

func (m *AnalyzeReq) GetIdxReq() *AnalyzeIndexReq {
	if m != nil {
		return m.IdxReq
	}
	return nil
}

func (m *AnalyzeReq) GetColReq() *AnalyzeColumnsReq {
	if m != nil {
		return m.ColReq
	}
	return nil
}

type AnalyzeIndexReq struct {
	// bucket_size is the max histograms bucket size.
	BucketSize int64 `protobuf:"varint,1,opt,name=bucket_size,json=bucketSize" json:"bucket_size"`
	// num_columns is the number of columns in the index.
	NumColumns       int32  `protobuf:"varint,2,opt,name=num_columns,json=numColumns" json:"num_columns"`
	CmsketchDepth    *int32 `protobuf:"varint,3,opt,name=cmsketch_depth,json=cmsketchDepth" json:"cmsketch_depth,omitempty"`
	CmsketchWidth    *int32 `protobuf:"varint,4,opt,name=cmsketch_width,json=cmsketchWidth" json:"cmsketch_width,omitempty"`
	SampleSize       int64  `protobuf:"varint,5,opt,name=sample_size,json=sampleSize" json:"sample_size"`
	SketchSize       int64  `protobuf:"varint,6,opt,name=sketch_size,json=sketchSize" json:"sketch_size"`
	TopNSize         *int32 `protobuf:"varint,7,opt,name=top_n_size,json=topNSize" json:"top_n_size,omitempty"`
	Version          *int32 `protobuf:"varint,8,opt,name=version" json:"version,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *AnalyzeIndexReq) Reset()                    { *m = AnalyzeIndexReq{} }
func (m *AnalyzeIndexReq) String() string            { return proto.CompactTextString(m) }
func (*AnalyzeIndexReq) ProtoMessage()               {}
func (*AnalyzeIndexReq) Descriptor() ([]byte, []int) { return fileDescriptorAnalyze, []int{1} }

func (m *AnalyzeIndexReq) GetBucketSize() int64 {
	if m != nil {
		return m.BucketSize
	}
	return 0
}

func (m *AnalyzeIndexReq) GetNumColumns() int32 {
	if m != nil {
		return m.NumColumns
	}
	return 0
}

func (m *AnalyzeIndexReq) GetCmsketchDepth() int32 {
	if m != nil && m.CmsketchDepth != nil {
		return *m.CmsketchDepth
	}
	return 0
}

func (m *AnalyzeIndexReq) GetCmsketchWidth() int32 {
	if m != nil && m.CmsketchWidth != nil {
		return *m.CmsketchWidth
	}
	return 0
}

func (m *AnalyzeIndexReq) GetSampleSize() int64 {
	if m != nil {
		return m.SampleSize
	}
	return 0
}

func (m *AnalyzeIndexReq) GetSketchSize() int64 {
	if m != nil {
		return m.SketchSize
	}
	return 0
}

func (m *AnalyzeIndexReq) GetTopNSize() int32 {
	if m != nil && m.TopNSize != nil {
		return *m.TopNSize
	}
	return 0
}

func (m *AnalyzeIndexReq) GetVersion() int32 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return 0
}

type AnalyzeColumnsReq struct {
	// bucket_size is the max histograms bucket size, we need this because when primary key is handle,
	// the histogram will be directly built.
	BucketSize int64 `protobuf:"varint,1,opt,name=bucket_size,json=bucketSize" json:"bucket_size"`
	// sample_size is the max number of samples that will be collected.
	SampleSize int64 `protobuf:"varint,2,opt,name=sample_size,json=sampleSize" json:"sample_size"`
	// sketch_size is the max sketch size.
	SketchSize int64 `protobuf:"varint,3,opt,name=sketch_size,json=sketchSize" json:"sketch_size"`
	// columns_info is the info of all the columns that needs to be analyzed.
	ColumnsInfo            []*ColumnInfo         `protobuf:"bytes,4,rep,name=columns_info,json=columnsInfo" json:"columns_info,omitempty"`
	CmsketchDepth          *int32                `protobuf:"varint,5,opt,name=cmsketch_depth,json=cmsketchDepth" json:"cmsketch_depth,omitempty"`
	CmsketchWidth          *int32                `protobuf:"varint,6,opt,name=cmsketch_width,json=cmsketchWidth" json:"cmsketch_width,omitempty"`
	PrimaryColumnIds       []int64               `protobuf:"varint,7,rep,name=primary_column_ids,json=primaryColumnIds" json:"primary_column_ids,omitempty"`
	Version                *int32                `protobuf:"varint,8,opt,name=version" json:"version,omitempty"`
	PrimaryPrefixColumnIds []int64               `protobuf:"varint,9,rep,name=primary_prefix_column_ids,json=primaryPrefixColumnIds" json:"primary_prefix_column_ids,omitempty"`
	ColumnGroups           []*AnalyzeColumnGroup `protobuf:"bytes,10,rep,name=column_groups,json=columnGroups" json:"column_groups,omitempty"`
	// sample_rate is the sampling rate that how many samples will collected.
	// There must be one non-zero value in sample_rate and sample_size.
	SampleRate *float64 `protobuf:"fixed64,11,opt,name=sample_rate,json=sampleRate" json:"sample_rate,omitempty"`
	// If ndv_sample_rate is 1, just use fm_sketch to calculate ndv.
	// If ndv_sample_rate is less than 1, use sample-based estimator to calculate ndv.
	NdvSampleRate    []float64 `protobuf:"fixed64,12,rep,name=ndv_sample_rate,json=ndvSampleRate" json:"ndv_sample_rate,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *AnalyzeColumnsReq) Reset()                    { *m = AnalyzeColumnsReq{} }
func (m *AnalyzeColumnsReq) String() string            { return proto.CompactTextString(m) }
func (*AnalyzeColumnsReq) ProtoMessage()               {}
func (*AnalyzeColumnsReq) Descriptor() ([]byte, []int) { return fileDescriptorAnalyze, []int{2} }

func (m *AnalyzeColumnsReq) GetBucketSize() int64 {
	if m != nil {
		return m.BucketSize
	}
	return 0
}

func (m *AnalyzeColumnsReq) GetSampleSize() int64 {
	if m != nil {
		return m.SampleSize
	}
	return 0
}

func (m *AnalyzeColumnsReq) GetSketchSize() int64 {
	if m != nil {
		return m.SketchSize
	}
	return 0
}

func (m *AnalyzeColumnsReq) GetColumnsInfo() []*ColumnInfo {
	if m != nil {
		return m.ColumnsInfo
	}
	return nil
}

func (m *AnalyzeColumnsReq) GetCmsketchDepth() int32 {
	if m != nil && m.CmsketchDepth != nil {
		return *m.CmsketchDepth
	}
	return 0
}

func (m *AnalyzeColumnsReq) GetCmsketchWidth() int32 {
	if m != nil && m.CmsketchWidth != nil {
		return *m.CmsketchWidth
	}
	return 0
}

func (m *AnalyzeColumnsReq) GetPrimaryColumnIds() []int64 {
	if m != nil {
		return m.PrimaryColumnIds
	}
	return nil
}

func (m *AnalyzeColumnsReq) GetVersion() int32 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return 0
}

func (m *AnalyzeColumnsReq) GetPrimaryPrefixColumnIds() []int64 {
	if m != nil {
		return m.PrimaryPrefixColumnIds
	}
	return nil
}

func (m *AnalyzeColumnsReq) GetColumnGroups() []*AnalyzeColumnGroup {
	if m != nil {
		return m.ColumnGroups
	}
	return nil
}

func (m *AnalyzeColumnsReq) GetSampleRate() float64 {
	if m != nil && m.SampleRate != nil {
		return *m.SampleRate
	}
	return 0
}

func (m *AnalyzeColumnsReq) GetNdvSampleRate() []float64 {
	if m != nil {
		return m.NdvSampleRate
	}
	return nil
}

type AnalyzeMixedResp struct {
	ColumnsResp      *AnalyzeColumnsResp `protobuf:"bytes,1,opt,name=columns_resp,json=columnsResp" json:"columns_resp,omitempty"`
	IndexResp        *AnalyzeIndexResp   `protobuf:"bytes,2,opt,name=index_resp,json=indexResp" json:"index_resp,omitempty"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *AnalyzeMixedResp) Reset()                    { *m = AnalyzeMixedResp{} }
func (m *AnalyzeMixedResp) String() string            { return proto.CompactTextString(m) }
func (*AnalyzeMixedResp) ProtoMessage()               {}
func (*AnalyzeMixedResp) Descriptor() ([]byte, []int) { return fileDescriptorAnalyze, []int{3} }

func (m *AnalyzeMixedResp) GetColumnsResp() *AnalyzeColumnsResp {
	if m != nil {
		return m.ColumnsResp
	}
	return nil
}

func (m *AnalyzeMixedResp) GetIndexResp() *AnalyzeIndexResp {
	if m != nil {
		return m.IndexResp
	}
	return nil
}

type AnalyzeColumnGroup struct {
	ColumnOffsets    []int64 `protobuf:"varint,1,rep,name=column_offsets,json=columnOffsets" json:"column_offsets,omitempty"`
	PrefixLengths    []int64 `protobuf:"varint,2,rep,name=prefix_lengths,json=prefixLengths" json:"prefix_lengths,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *AnalyzeColumnGroup) Reset()                    { *m = AnalyzeColumnGroup{} }
func (m *AnalyzeColumnGroup) String() string            { return proto.CompactTextString(m) }
func (*AnalyzeColumnGroup) ProtoMessage()               {}
func (*AnalyzeColumnGroup) Descriptor() ([]byte, []int) { return fileDescriptorAnalyze, []int{4} }

func (m *AnalyzeColumnGroup) GetColumnOffsets() []int64 {
	if m != nil {
		return m.ColumnOffsets
	}
	return nil
}

func (m *AnalyzeColumnGroup) GetPrefixLengths() []int64 {
	if m != nil {
		return m.PrefixLengths
	}
	return nil
}

type AnalyzeColumnsResp struct {
	// collectors is the sample collectors for columns.
	Collectors []*SampleCollector `protobuf:"bytes,1,rep,name=collectors" json:"collectors,omitempty"`
	// pk_hist is the histogram for primary key when it is the handle.
	PkHist           *Histogram          `protobuf:"bytes,2,opt,name=pk_hist,json=pkHist" json:"pk_hist,omitempty"`
	RowCollector     *RowSampleCollector `protobuf:"bytes,3,opt,name=row_collector,json=rowCollector" json:"row_collector,omitempty"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *AnalyzeColumnsResp) Reset()                    { *m = AnalyzeColumnsResp{} }
func (m *AnalyzeColumnsResp) String() string            { return proto.CompactTextString(m) }
func (*AnalyzeColumnsResp) ProtoMessage()               {}
func (*AnalyzeColumnsResp) Descriptor() ([]byte, []int) { return fileDescriptorAnalyze, []int{5} }

func (m *AnalyzeColumnsResp) GetCollectors() []*SampleCollector {
	if m != nil {
		return m.Collectors
	}
	return nil
}

func (m *AnalyzeColumnsResp) GetPkHist() *Histogram {
	if m != nil {
		return m.PkHist
	}
	return nil
}

func (m *AnalyzeColumnsResp) GetRowCollector() *RowSampleCollector {
	if m != nil {
		return m.RowCollector
	}
	return nil
}

type AnalyzeIndexResp struct {
	Hist             *Histogram       `protobuf:"bytes,1,opt,name=hist" json:"hist,omitempty"`
	Cms              *CMSketch        `protobuf:"bytes,2,opt,name=cms" json:"cms,omitempty"`
	Collector        *SampleCollector `protobuf:"bytes,3,opt,name=collector" json:"collector,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *AnalyzeIndexResp) Reset()                    { *m = AnalyzeIndexResp{} }
func (m *AnalyzeIndexResp) String() string            { return proto.CompactTextString(m) }
func (*AnalyzeIndexResp) ProtoMessage()               {}
func (*AnalyzeIndexResp) Descriptor() ([]byte, []int) { return fileDescriptorAnalyze, []int{6} }

func (m *AnalyzeIndexResp) GetHist() *Histogram {
	if m != nil {
		return m.Hist
	}
	return nil
}

func (m *AnalyzeIndexResp) GetCms() *CMSketch {
	if m != nil {
		return m.Cms
	}
	return nil
}

func (m *AnalyzeIndexResp) GetCollector() *SampleCollector {
	if m != nil {
		return m.Collector
	}
	return nil
}

// Bucket is an element of histogram.
type Bucket struct {
	Count            int64  `protobuf:"varint,1,opt,name=count" json:"count"`
	LowerBound       []byte `protobuf:"bytes,2,opt,name=lower_bound,json=lowerBound" json:"lower_bound,omitempty"`
	UpperBound       []byte `protobuf:"bytes,3,opt,name=upper_bound,json=upperBound" json:"upper_bound,omitempty"`
	Repeats          int64  `protobuf:"varint,4,opt,name=repeats" json:"repeats"`
	Ndv              *int64 `protobuf:"varint,5,opt,name=ndv" json:"ndv,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Bucket) Reset()                    { *m = Bucket{} }
func (m *Bucket) String() string            { return proto.CompactTextString(m) }
func (*Bucket) ProtoMessage()               {}
func (*Bucket) Descriptor() ([]byte, []int) { return fileDescriptorAnalyze, []int{7} }

func (m *Bucket) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *Bucket) GetLowerBound() []byte {
	if m != nil {
		return m.LowerBound
	}
	return nil
}

func (m *Bucket) GetUpperBound() []byte {
	if m != nil {
		return m.UpperBound
	}
	return nil
}

func (m *Bucket) GetRepeats() int64 {
	if m != nil {
		return m.Repeats
	}
	return 0
}

func (m *Bucket) GetNdv() int64 {
	if m != nil && m.Ndv != nil {
		return *m.Ndv
	}
	return 0
}

type Histogram struct {
	// ndv is the number of distinct values.
	Ndv int64 `protobuf:"varint,1,opt,name=ndv" json:"ndv"`
	// buckets represents all the buckets.
	Buckets          []*Bucket `protobuf:"bytes,2,rep,name=buckets" json:"buckets,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *Histogram) Reset()                    { *m = Histogram{} }
func (m *Histogram) String() string            { return proto.CompactTextString(m) }
func (*Histogram) ProtoMessage()               {}
func (*Histogram) Descriptor() ([]byte, []int) { return fileDescriptorAnalyze, []int{8} }

func (m *Histogram) GetNdv() int64 {
	if m != nil {
		return m.Ndv
	}
	return 0
}

func (m *Histogram) GetBuckets() []*Bucket {
	if m != nil {
		return m.Buckets
	}
	return nil
}

// FMSketch is used to count distinct values for columns.
type FMSketch struct {
	Mask             uint64   `protobuf:"varint,1,opt,name=mask" json:"mask"`
	Hashset          []uint64 `protobuf:"varint,2,rep,name=hashset" json:"hashset,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *FMSketch) Reset()                    { *m = FMSketch{} }
func (m *FMSketch) String() string            { return proto.CompactTextString(m) }
func (*FMSketch) ProtoMessage()               {}
func (*FMSketch) Descriptor() ([]byte, []int) { return fileDescriptorAnalyze, []int{9} }

func (m *FMSketch) GetMask() uint64 {
	if m != nil {
		return m.Mask
	}
	return 0
}

func (m *FMSketch) GetHashset() []uint64 {
	if m != nil {
		return m.Hashset
	}
	return nil
}

// SampleCollector is used for collect samples and calculate the count and ndv of an column.
type SampleCollector struct {
	Samples          [][]byte  `protobuf:"bytes,1,rep,name=samples" json:"samples,omitempty"`
	NullCount        int64     `protobuf:"varint,2,opt,name=null_count,json=nullCount" json:"null_count"`
	Count            int64     `protobuf:"varint,3,opt,name=count" json:"count"`
	FmSketch         *FMSketch `protobuf:"bytes,4,opt,name=fm_sketch,json=fmSketch" json:"fm_sketch,omitempty"`
	CmSketch         *CMSketch `protobuf:"bytes,5,opt,name=cm_sketch,json=cmSketch" json:"cm_sketch,omitempty"`
	TotalSize        *int64    `protobuf:"varint,6,opt,name=total_size,json=totalSize" json:"total_size,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *SampleCollector) Reset()                    { *m = SampleCollector{} }
func (m *SampleCollector) String() string            { return proto.CompactTextString(m) }
func (*SampleCollector) ProtoMessage()               {}
func (*SampleCollector) Descriptor() ([]byte, []int) { return fileDescriptorAnalyze, []int{10} }

func (m *SampleCollector) GetSamples() [][]byte {
	if m != nil {
		return m.Samples
	}
	return nil
}

func (m *SampleCollector) GetNullCount() int64 {
	if m != nil {
		return m.NullCount
	}
	return 0
}

func (m *SampleCollector) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *SampleCollector) GetFmSketch() *FMSketch {
	if m != nil {
		return m.FmSketch
	}
	return nil
}

func (m *SampleCollector) GetCmSketch() *CMSketch {
	if m != nil {
		return m.CmSketch
	}
	return nil
}

func (m *SampleCollector) GetTotalSize() int64 {
	if m != nil && m.TotalSize != nil {
		return *m.TotalSize
	}
	return 0
}

type RowSampleCollector struct {
	Samples    []*RowSample `protobuf:"bytes,1,rep,name=samples" json:"samples,omitempty"`
	NullCounts []int64      `protobuf:"varint,2,rep,name=null_counts,json=nullCounts" json:"null_counts,omitempty"`
	Count      int64        `protobuf:"varint,3,opt,name=count" json:"count"`
	FmSketch   []*FMSketch  `protobuf:"bytes,4,rep,name=fm_sketch,json=fmSketch" json:"fm_sketch,omitempty"`
	TotalSize  []int64      `protobuf:"varint,5,rep,name=total_size,json=totalSize" json:"total_size,omitempty"`
	// sample_ndv_offsets, sample_fm_sketch, sample_f1_fm_sketch are used for sample-based ndv calculation.
	// sample_ndv_offsets indicates which columns/indexes use sample-based ndv calculation.
	// sample_fm_sketch is the fm_sketch of the all samples.
	// sample_f1_fm_sketch is the fm_sketch of the samples whose value occurs exactly once.
	SampleNdvOffsets []int64     `protobuf:"varint,6,rep,name=sample_ndv_offsets,json=sampleNdvOffsets" json:"sample_ndv_offsets,omitempty"`
	SampleFmSketch   []*FMSketch `protobuf:"bytes,7,rep,name=sample_fm_sketch,json=sampleFmSketch" json:"sample_fm_sketch,omitempty"`
	SampleF1FmSketch []*FMSketch `protobuf:"bytes,8,rep,name=sample_f1_fm_sketch,json=sampleF1FmSketch" json:"sample_f1_fm_sketch,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *RowSampleCollector) Reset()                    { *m = RowSampleCollector{} }
func (m *RowSampleCollector) String() string            { return proto.CompactTextString(m) }
func (*RowSampleCollector) ProtoMessage()               {}
func (*RowSampleCollector) Descriptor() ([]byte, []int) { return fileDescriptorAnalyze, []int{11} }

func (m *RowSampleCollector) GetSamples() []*RowSample {
	if m != nil {
		return m.Samples
	}
	return nil
}

func (m *RowSampleCollector) GetNullCounts() []int64 {
	if m != nil {
		return m.NullCounts
	}
	return nil
}

func (m *RowSampleCollector) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *RowSampleCollector) GetFmSketch() []*FMSketch {
	if m != nil {
		return m.FmSketch
	}
	return nil
}

func (m *RowSampleCollector) GetTotalSize() []int64 {
	if m != nil {
		return m.TotalSize
	}
	return nil
}

func (m *RowSampleCollector) GetSampleNdvOffsets() []int64 {
	if m != nil {
		return m.SampleNdvOffsets
	}
	return nil
}

func (m *RowSampleCollector) GetSampleFmSketch() []*FMSketch {
	if m != nil {
		return m.SampleFmSketch
	}
	return nil
}

func (m *RowSampleCollector) GetSampleF1FmSketch() []*FMSketch {
	if m != nil {
		return m.SampleF1FmSketch
	}
	return nil
}

type RowSample struct {
	Row              [][]byte `protobuf:"bytes,1,rep,name=row" json:"row,omitempty"`
	Weight           int64    `protobuf:"varint,2,opt,name=weight" json:"weight"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *RowSample) Reset()                    { *m = RowSample{} }
func (m *RowSample) String() string            { return proto.CompactTextString(m) }
func (*RowSample) ProtoMessage()               {}
func (*RowSample) Descriptor() ([]byte, []int) { return fileDescriptorAnalyze, []int{12} }

func (m *RowSample) GetRow() [][]byte {
	if m != nil {
		return m.Row
	}
	return nil
}

func (m *RowSample) GetWeight() int64 {
	if m != nil {
		return m.Weight
	}
	return 0
}

type CMSketchRow struct {
	Counters         []uint32 `protobuf:"varint,1,rep,name=counters" json:"counters,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *CMSketchRow) Reset()                    { *m = CMSketchRow{} }
func (m *CMSketchRow) String() string            { return proto.CompactTextString(m) }
func (*CMSketchRow) ProtoMessage()               {}
func (*CMSketchRow) Descriptor() ([]byte, []int) { return fileDescriptorAnalyze, []int{13} }

func (m *CMSketchRow) GetCounters() []uint32 {
	if m != nil {
		return m.Counters
	}
	return nil
}

type CMSketchTopN struct {
	Data             []byte `protobuf:"bytes,1,opt,name=data" json:"data,omitempty"`
	Count            uint64 `protobuf:"varint,2,opt,name=count" json:"count"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *CMSketchTopN) Reset()                    { *m = CMSketchTopN{} }
func (m *CMSketchTopN) String() string            { return proto.CompactTextString(m) }
func (*CMSketchTopN) ProtoMessage()               {}
func (*CMSketchTopN) Descriptor() ([]byte, []int) { return fileDescriptorAnalyze, []int{14} }

func (m *CMSketchTopN) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *CMSketchTopN) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type CMSketch struct {
	Rows             []*CMSketchRow  `protobuf:"bytes,1,rep,name=rows" json:"rows,omitempty"`
	TopN             []*CMSketchTopN `protobuf:"bytes,2,rep,name=top_n,json=topN" json:"top_n,omitempty"`
	DefaultValue     uint64          `protobuf:"varint,3,opt,name=default_value,json=defaultValue" json:"default_value"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *CMSketch) Reset()                    { *m = CMSketch{} }
func (m *CMSketch) String() string            { return proto.CompactTextString(m) }
func (*CMSketch) ProtoMessage()               {}
func (*CMSketch) Descriptor() ([]byte, []int) { return fileDescriptorAnalyze, []int{15} }

func (m *CMSketch) GetRows() []*CMSketchRow {
	if m != nil {
		return m.Rows
	}
	return nil
}

func (m *CMSketch) GetTopN() []*CMSketchTopN {
	if m != nil {
		return m.TopN
	}
	return nil
}

func (m *CMSketch) GetDefaultValue() uint64 {
	if m != nil {
		return m.DefaultValue
	}
	return 0
}

func init() {
	proto.RegisterType((*AnalyzeReq)(nil), "tipb.AnalyzeReq")
	proto.RegisterType((*AnalyzeIndexReq)(nil), "tipb.AnalyzeIndexReq")
	proto.RegisterType((*AnalyzeColumnsReq)(nil), "tipb.AnalyzeColumnsReq")
	proto.RegisterType((*AnalyzeMixedResp)(nil), "tipb.AnalyzeMixedResp")
	proto.RegisterType((*AnalyzeColumnGroup)(nil), "tipb.AnalyzeColumnGroup")
	proto.RegisterType((*AnalyzeColumnsResp)(nil), "tipb.AnalyzeColumnsResp")
	proto.RegisterType((*AnalyzeIndexResp)(nil), "tipb.AnalyzeIndexResp")
	proto.RegisterType((*Bucket)(nil), "tipb.Bucket")
	proto.RegisterType((*Histogram)(nil), "tipb.Histogram")
	proto.RegisterType((*FMSketch)(nil), "tipb.FMSketch")
	proto.RegisterType((*SampleCollector)(nil), "tipb.SampleCollector")
	proto.RegisterType((*RowSampleCollector)(nil), "tipb.RowSampleCollector")
	proto.RegisterType((*RowSample)(nil), "tipb.RowSample")
	proto.RegisterType((*CMSketchRow)(nil), "tipb.CMSketchRow")
	proto.RegisterType((*CMSketchTopN)(nil), "tipb.CMSketchTopN")
	proto.RegisterType((*CMSketch)(nil), "tipb.CMSketch")
	proto.RegisterEnum("tipb.AnalyzeType", AnalyzeType_name, AnalyzeType_value)
}
func (m *AnalyzeReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnalyzeReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintAnalyze(dAtA, i, uint64(m.Tp))
	if m.StartTsFallback != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAnalyze(dAtA, i, uint64(*m.StartTsFallback))
	}
	dAtA[i] = 0x18
	i++
	i = encodeVarintAnalyze(dAtA, i, uint64(m.Flags))
	dAtA[i] = 0x20
	i++
	i = encodeVarintAnalyze(dAtA, i, uint64(m.TimeZoneOffset))
	if m.IdxReq != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAnalyze(dAtA, i, uint64(m.IdxReq.Size()))
		n1, err := m.IdxReq.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.ColReq != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAnalyze(dAtA, i, uint64(m.ColReq.Size()))
		n2, err := m.ColReq.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AnalyzeIndexReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnalyzeIndexReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintAnalyze(dAtA, i, uint64(m.BucketSize))
	dAtA[i] = 0x10
	i++
	i = encodeVarintAnalyze(dAtA, i, uint64(m.NumColumns))
	if m.CmsketchDepth != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAnalyze(dAtA, i, uint64(*m.CmsketchDepth))
	}
	if m.CmsketchWidth != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAnalyze(dAtA, i, uint64(*m.CmsketchWidth))
	}
	dAtA[i] = 0x28
	i++
	i = encodeVarintAnalyze(dAtA, i, uint64(m.SampleSize))
	dAtA[i] = 0x30
	i++
	i = encodeVarintAnalyze(dAtA, i, uint64(m.SketchSize))
	if m.TopNSize != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintAnalyze(dAtA, i, uint64(*m.TopNSize))
	}
	if m.Version != nil {
		dAtA[i] = 0x40
		i++
		i = encodeVarintAnalyze(dAtA, i, uint64(*m.Version))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AnalyzeColumnsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnalyzeColumnsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintAnalyze(dAtA, i, uint64(m.BucketSize))
	dAtA[i] = 0x10
	i++
	i = encodeVarintAnalyze(dAtA, i, uint64(m.SampleSize))
	dAtA[i] = 0x18
	i++
	i = encodeVarintAnalyze(dAtA, i, uint64(m.SketchSize))
	if len(m.ColumnsInfo) > 0 {
		for _, msg := range m.ColumnsInfo {
			dAtA[i] = 0x22
			i++
			i = encodeVarintAnalyze(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CmsketchDepth != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAnalyze(dAtA, i, uint64(*m.CmsketchDepth))
	}
	if m.CmsketchWidth != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintAnalyze(dAtA, i, uint64(*m.CmsketchWidth))
	}
	if len(m.PrimaryColumnIds) > 0 {
		for _, num := range m.PrimaryColumnIds {
			dAtA[i] = 0x38
			i++
			i = encodeVarintAnalyze(dAtA, i, uint64(num))
		}
	}
	if m.Version != nil {
		dAtA[i] = 0x40
		i++
		i = encodeVarintAnalyze(dAtA, i, uint64(*m.Version))
	}
	if len(m.PrimaryPrefixColumnIds) > 0 {
		for _, num := range m.PrimaryPrefixColumnIds {
			dAtA[i] = 0x48
			i++
			i = encodeVarintAnalyze(dAtA, i, uint64(num))
		}
	}
	if len(m.ColumnGroups) > 0 {
		for _, msg := range m.ColumnGroups {
			dAtA[i] = 0x52
			i++
			i = encodeVarintAnalyze(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.SampleRate != nil {
		dAtA[i] = 0x59
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.SampleRate))))
		i += 8
	}
	if len(m.NdvSampleRate) > 0 {
		for _, num := range m.NdvSampleRate {
			dAtA[i] = 0x61
			i++
			f3 := math.Float64bits(float64(num))
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f3))
			i += 8
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AnalyzeMixedResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnalyzeMixedResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ColumnsResp != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAnalyze(dAtA, i, uint64(m.ColumnsResp.Size()))
		n4, err := m.ColumnsResp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.IndexResp != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAnalyze(dAtA, i, uint64(m.IndexResp.Size()))
		n5, err := m.IndexResp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AnalyzeColumnGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnalyzeColumnGroup) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ColumnOffsets) > 0 {
		for _, num := range m.ColumnOffsets {
			dAtA[i] = 0x8
			i++
			i = encodeVarintAnalyze(dAtA, i, uint64(num))
		}
	}
	if len(m.PrefixLengths) > 0 {
		for _, num := range m.PrefixLengths {
			dAtA[i] = 0x10
			i++
			i = encodeVarintAnalyze(dAtA, i, uint64(num))
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AnalyzeColumnsResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnalyzeColumnsResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Collectors) > 0 {
		for _, msg := range m.Collectors {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAnalyze(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PkHist != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAnalyze(dAtA, i, uint64(m.PkHist.Size()))
		n6, err := m.PkHist.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.RowCollector != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAnalyze(dAtA, i, uint64(m.RowCollector.Size()))
		n7, err := m.RowCollector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AnalyzeIndexResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnalyzeIndexResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Hist != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAnalyze(dAtA, i, uint64(m.Hist.Size()))
		n8, err := m.Hist.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Cms != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAnalyze(dAtA, i, uint64(m.Cms.Size()))
		n9, err := m.Cms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Collector != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAnalyze(dAtA, i, uint64(m.Collector.Size()))
		n10, err := m.Collector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Bucket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Bucket) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintAnalyze(dAtA, i, uint64(m.Count))
	if m.LowerBound != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAnalyze(dAtA, i, uint64(len(m.LowerBound)))
		i += copy(dAtA[i:], m.LowerBound)
	}
	if m.UpperBound != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAnalyze(dAtA, i, uint64(len(m.UpperBound)))
		i += copy(dAtA[i:], m.UpperBound)
	}
	dAtA[i] = 0x20
	i++
	i = encodeVarintAnalyze(dAtA, i, uint64(m.Repeats))
	if m.Ndv != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAnalyze(dAtA, i, uint64(*m.Ndv))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Histogram) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Histogram) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintAnalyze(dAtA, i, uint64(m.Ndv))
	if len(m.Buckets) > 0 {
		for _, msg := range m.Buckets {
			dAtA[i] = 0x12
			i++
			i = encodeVarintAnalyze(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FMSketch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FMSketch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintAnalyze(dAtA, i, uint64(m.Mask))
	if len(m.Hashset) > 0 {
		for _, num := range m.Hashset {
			dAtA[i] = 0x10
			i++
			i = encodeVarintAnalyze(dAtA, i, uint64(num))
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SampleCollector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SampleCollector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Samples) > 0 {
		for _, b := range m.Samples {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAnalyze(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	dAtA[i] = 0x10
	i++
	i = encodeVarintAnalyze(dAtA, i, uint64(m.NullCount))
	dAtA[i] = 0x18
	i++
	i = encodeVarintAnalyze(dAtA, i, uint64(m.Count))
	if m.FmSketch != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAnalyze(dAtA, i, uint64(m.FmSketch.Size()))
		n11, err := m.FmSketch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.CmSketch != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAnalyze(dAtA, i, uint64(m.CmSketch.Size()))
		n12, err := m.CmSketch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.TotalSize != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintAnalyze(dAtA, i, uint64(*m.TotalSize))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RowSampleCollector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RowSampleCollector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Samples) > 0 {
		for _, msg := range m.Samples {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAnalyze(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NullCounts) > 0 {
		for _, num := range m.NullCounts {
			dAtA[i] = 0x10
			i++
			i = encodeVarintAnalyze(dAtA, i, uint64(num))
		}
	}
	dAtA[i] = 0x18
	i++
	i = encodeVarintAnalyze(dAtA, i, uint64(m.Count))
	if len(m.FmSketch) > 0 {
		for _, msg := range m.FmSketch {
			dAtA[i] = 0x22
			i++
			i = encodeVarintAnalyze(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TotalSize) > 0 {
		for _, num := range m.TotalSize {
			dAtA[i] = 0x28
			i++
			i = encodeVarintAnalyze(dAtA, i, uint64(num))
		}
	}
	if len(m.SampleNdvOffsets) > 0 {
		for _, num := range m.SampleNdvOffsets {
			dAtA[i] = 0x30
			i++
			i = encodeVarintAnalyze(dAtA, i, uint64(num))
		}
	}
	if len(m.SampleFmSketch) > 0 {
		for _, msg := range m.SampleFmSketch {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintAnalyze(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SampleF1FmSketch) > 0 {
		for _, msg := range m.SampleF1FmSketch {
			dAtA[i] = 0x42
			i++
			i = encodeVarintAnalyze(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RowSample) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RowSample) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Row) > 0 {
		for _, b := range m.Row {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAnalyze(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	dAtA[i] = 0x10
	i++
	i = encodeVarintAnalyze(dAtA, i, uint64(m.Weight))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CMSketchRow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMSketchRow) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Counters) > 0 {
		for _, num := range m.Counters {
			dAtA[i] = 0x8
			i++
			i = encodeVarintAnalyze(dAtA, i, uint64(num))
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CMSketchTopN) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMSketchTopN) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAnalyze(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	dAtA[i] = 0x10
	i++
	i = encodeVarintAnalyze(dAtA, i, uint64(m.Count))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CMSketch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMSketch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Rows) > 0 {
		for _, msg := range m.Rows {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAnalyze(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TopN) > 0 {
		for _, msg := range m.TopN {
			dAtA[i] = 0x12
			i++
			i = encodeVarintAnalyze(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x18
	i++
	i = encodeVarintAnalyze(dAtA, i, uint64(m.DefaultValue))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintAnalyze(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AnalyzeReq) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovAnalyze(uint64(m.Tp))
	if m.StartTsFallback != nil {
		n += 1 + sovAnalyze(uint64(*m.StartTsFallback))
	}
	n += 1 + sovAnalyze(uint64(m.Flags))
	n += 1 + sovAnalyze(uint64(m.TimeZoneOffset))
	if m.IdxReq != nil {
		l = m.IdxReq.Size()
		n += 1 + l + sovAnalyze(uint64(l))
	}
	if m.ColReq != nil {
		l = m.ColReq.Size()
		n += 1 + l + sovAnalyze(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AnalyzeIndexReq) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovAnalyze(uint64(m.BucketSize))
	n += 1 + sovAnalyze(uint64(m.NumColumns))
	if m.CmsketchDepth != nil {
		n += 1 + sovAnalyze(uint64(*m.CmsketchDepth))
	}
	if m.CmsketchWidth != nil {
		n += 1 + sovAnalyze(uint64(*m.CmsketchWidth))
	}
	n += 1 + sovAnalyze(uint64(m.SampleSize))
	n += 1 + sovAnalyze(uint64(m.SketchSize))
	if m.TopNSize != nil {
		n += 1 + sovAnalyze(uint64(*m.TopNSize))
	}
	if m.Version != nil {
		n += 1 + sovAnalyze(uint64(*m.Version))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AnalyzeColumnsReq) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovAnalyze(uint64(m.BucketSize))
	n += 1 + sovAnalyze(uint64(m.SampleSize))
	n += 1 + sovAnalyze(uint64(m.SketchSize))
	if len(m.ColumnsInfo) > 0 {
		for _, e := range m.ColumnsInfo {
			l = e.Size()
			n += 1 + l + sovAnalyze(uint64(l))
		}
	}
	if m.CmsketchDepth != nil {
		n += 1 + sovAnalyze(uint64(*m.CmsketchDepth))
	}
	if m.CmsketchWidth != nil {
		n += 1 + sovAnalyze(uint64(*m.CmsketchWidth))
	}
	if len(m.PrimaryColumnIds) > 0 {
		for _, e := range m.PrimaryColumnIds {
			n += 1 + sovAnalyze(uint64(e))
		}
	}
	if m.Version != nil {
		n += 1 + sovAnalyze(uint64(*m.Version))
	}
	if len(m.PrimaryPrefixColumnIds) > 0 {
		for _, e := range m.PrimaryPrefixColumnIds {
			n += 1 + sovAnalyze(uint64(e))
		}
	}
	if len(m.ColumnGroups) > 0 {
		for _, e := range m.ColumnGroups {
			l = e.Size()
			n += 1 + l + sovAnalyze(uint64(l))
		}
	}
	if m.SampleRate != nil {
		n += 9
	}
	if len(m.NdvSampleRate) > 0 {
		n += 9 * len(m.NdvSampleRate)
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AnalyzeMixedResp) Size() (n int) {
	var l int
	_ = l
	if m.ColumnsResp != nil {
		l = m.ColumnsResp.Size()
		n += 1 + l + sovAnalyze(uint64(l))
	}
	if m.IndexResp != nil {
		l = m.IndexResp.Size()
		n += 1 + l + sovAnalyze(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AnalyzeColumnGroup) Size() (n int) {
	var l int
	_ = l
	if len(m.ColumnOffsets) > 0 {
		for _, e := range m.ColumnOffsets {
			n += 1 + sovAnalyze(uint64(e))
		}
	}
	if len(m.PrefixLengths) > 0 {
		for _, e := range m.PrefixLengths {
			n += 1 + sovAnalyze(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AnalyzeColumnsResp) Size() (n int) {
	var l int
	_ = l
	if len(m.Collectors) > 0 {
		for _, e := range m.Collectors {
			l = e.Size()
			n += 1 + l + sovAnalyze(uint64(l))
		}
	}
	if m.PkHist != nil {
		l = m.PkHist.Size()
		n += 1 + l + sovAnalyze(uint64(l))
	}
	if m.RowCollector != nil {
		l = m.RowCollector.Size()
		n += 1 + l + sovAnalyze(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AnalyzeIndexResp) Size() (n int) {
	var l int
	_ = l
	if m.Hist != nil {
		l = m.Hist.Size()
		n += 1 + l + sovAnalyze(uint64(l))
	}
	if m.Cms != nil {
		l = m.Cms.Size()
		n += 1 + l + sovAnalyze(uint64(l))
	}
	if m.Collector != nil {
		l = m.Collector.Size()
		n += 1 + l + sovAnalyze(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Bucket) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovAnalyze(uint64(m.Count))
	if m.LowerBound != nil {
		l = len(m.LowerBound)
		n += 1 + l + sovAnalyze(uint64(l))
	}
	if m.UpperBound != nil {
		l = len(m.UpperBound)
		n += 1 + l + sovAnalyze(uint64(l))
	}
	n += 1 + sovAnalyze(uint64(m.Repeats))
	if m.Ndv != nil {
		n += 1 + sovAnalyze(uint64(*m.Ndv))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Histogram) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovAnalyze(uint64(m.Ndv))
	if len(m.Buckets) > 0 {
		for _, e := range m.Buckets {
			l = e.Size()
			n += 1 + l + sovAnalyze(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FMSketch) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovAnalyze(uint64(m.Mask))
	if len(m.Hashset) > 0 {
		for _, e := range m.Hashset {
			n += 1 + sovAnalyze(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SampleCollector) Size() (n int) {
	var l int
	_ = l
	if len(m.Samples) > 0 {
		for _, b := range m.Samples {
			l = len(b)
			n += 1 + l + sovAnalyze(uint64(l))
		}
	}
	n += 1 + sovAnalyze(uint64(m.NullCount))
	n += 1 + sovAnalyze(uint64(m.Count))
	if m.FmSketch != nil {
		l = m.FmSketch.Size()
		n += 1 + l + sovAnalyze(uint64(l))
	}
	if m.CmSketch != nil {
		l = m.CmSketch.Size()
		n += 1 + l + sovAnalyze(uint64(l))
	}
	if m.TotalSize != nil {
		n += 1 + sovAnalyze(uint64(*m.TotalSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RowSampleCollector) Size() (n int) {
	var l int
	_ = l
	if len(m.Samples) > 0 {
		for _, e := range m.Samples {
			l = e.Size()
			n += 1 + l + sovAnalyze(uint64(l))
		}
	}
	if len(m.NullCounts) > 0 {
		for _, e := range m.NullCounts {
			n += 1 + sovAnalyze(uint64(e))
		}
	}
	n += 1 + sovAnalyze(uint64(m.Count))
	if len(m.FmSketch) > 0 {
		for _, e := range m.FmSketch {
			l = e.Size()
			n += 1 + l + sovAnalyze(uint64(l))
		}
	}
	if len(m.TotalSize) > 0 {
		for _, e := range m.TotalSize {
			n += 1 + sovAnalyze(uint64(e))
		}
	}
	if len(m.SampleNdvOffsets) > 0 {
		for _, e := range m.SampleNdvOffsets {
			n += 1 + sovAnalyze(uint64(e))
		}
	}
	if len(m.SampleFmSketch) > 0 {
		for _, e := range m.SampleFmSketch {
			l = e.Size()
			n += 1 + l + sovAnalyze(uint64(l))
		}
	}
	if len(m.SampleF1FmSketch) > 0 {
		for _, e := range m.SampleF1FmSketch {
			l = e.Size()
			n += 1 + l + sovAnalyze(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RowSample) Size() (n int) {
	var l int
	_ = l
	if len(m.Row) > 0 {
		for _, b := range m.Row {
			l = len(b)
			n += 1 + l + sovAnalyze(uint64(l))
		}
	}
	n += 1 + sovAnalyze(uint64(m.Weight))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CMSketchRow) Size() (n int) {
	var l int
	_ = l
	if len(m.Counters) > 0 {
		for _, e := range m.Counters {
			n += 1 + sovAnalyze(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CMSketchTopN) Size() (n int) {
	var l int
	_ = l
	if m.Data != nil {
		l = len(m.Data)
		n += 1 + l + sovAnalyze(uint64(l))
	}
	n += 1 + sovAnalyze(uint64(m.Count))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CMSketch) Size() (n int) {
	var l int
	_ = l
	if len(m.Rows) > 0 {
		for _, e := range m.Rows {
			l = e.Size()
			n += 1 + l + sovAnalyze(uint64(l))
		}
	}
	if len(m.TopN) > 0 {
		for _, e := range m.TopN {
			l = e.Size()
			n += 1 + l + sovAnalyze(uint64(l))
		}
	}
	n += 1 + sovAnalyze(uint64(m.DefaultValue))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovAnalyze(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAnalyze(x uint64) (n int) {
	return sovAnalyze(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AnalyzeReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnalyze
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnalyzeReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnalyzeReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tp", wireType)
			}
			m.Tp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tp |= (AnalyzeType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTsFallback", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StartTsFallback = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeZoneOffset", wireType)
			}
			m.TimeZoneOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeZoneOffset |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdxReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalyze
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdxReq == nil {
				m.IdxReq = &AnalyzeIndexReq{}
			}
			if err := m.IdxReq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalyze
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ColReq == nil {
				m.ColReq = &AnalyzeColumnsReq{}
			}
			if err := m.ColReq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnalyze(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnalyze
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnalyzeIndexReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnalyze
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnalyzeIndexReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnalyzeIndexReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketSize", wireType)
			}
			m.BucketSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BucketSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumColumns", wireType)
			}
			m.NumColumns = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumColumns |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmsketchDepth", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CmsketchDepth = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmsketchWidth", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CmsketchWidth = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleSize", wireType)
			}
			m.SampleSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SampleSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SketchSize", wireType)
			}
			m.SketchSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SketchSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopNSize", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TopNSize = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Version = &v
		default:
			iNdEx = preIndex
			skippy, err := skipAnalyze(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnalyze
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnalyzeColumnsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnalyze
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnalyzeColumnsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnalyzeColumnsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketSize", wireType)
			}
			m.BucketSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BucketSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleSize", wireType)
			}
			m.SampleSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SampleSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SketchSize", wireType)
			}
			m.SketchSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SketchSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnsInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalyze
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColumnsInfo = append(m.ColumnsInfo, &ColumnInfo{})
			if err := m.ColumnsInfo[len(m.ColumnsInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmsketchDepth", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CmsketchDepth = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmsketchWidth", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CmsketchWidth = &v
		case 7:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAnalyze
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PrimaryColumnIds = append(m.PrimaryColumnIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAnalyze
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAnalyze
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAnalyze
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PrimaryColumnIds = append(m.PrimaryColumnIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryColumnIds", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Version = &v
		case 9:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAnalyze
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PrimaryPrefixColumnIds = append(m.PrimaryPrefixColumnIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAnalyze
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAnalyze
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAnalyze
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PrimaryPrefixColumnIds = append(m.PrimaryPrefixColumnIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryPrefixColumnIds", wireType)
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnGroups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalyze
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColumnGroups = append(m.ColumnGroups, &AnalyzeColumnGroup{})
			if err := m.ColumnGroups[len(m.ColumnGroups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleRate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.SampleRate = &v2
		case 12:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.NdvSampleRate = append(m.NdvSampleRate, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAnalyze
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAnalyze
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.NdvSampleRate = append(m.NdvSampleRate, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NdvSampleRate", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAnalyze(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnalyze
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnalyzeMixedResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnalyze
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnalyzeMixedResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnalyzeMixedResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnsResp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalyze
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ColumnsResp == nil {
				m.ColumnsResp = &AnalyzeColumnsResp{}
			}
			if err := m.ColumnsResp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexResp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalyze
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IndexResp == nil {
				m.IndexResp = &AnalyzeIndexResp{}
			}
			if err := m.IndexResp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnalyze(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnalyze
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnalyzeColumnGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnalyze
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnalyzeColumnGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnalyzeColumnGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAnalyze
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnOffsets = append(m.ColumnOffsets, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAnalyze
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAnalyze
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAnalyze
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnOffsets = append(m.ColumnOffsets, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnOffsets", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAnalyze
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PrefixLengths = append(m.PrefixLengths, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAnalyze
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAnalyze
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAnalyze
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PrefixLengths = append(m.PrefixLengths, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixLengths", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAnalyze(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnalyze
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnalyzeColumnsResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnalyze
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnalyzeColumnsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnalyzeColumnsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalyze
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Collectors = append(m.Collectors, &SampleCollector{})
			if err := m.Collectors[len(m.Collectors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PkHist", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalyze
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PkHist == nil {
				m.PkHist = &Histogram{}
			}
			if err := m.PkHist.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowCollector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalyze
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RowCollector == nil {
				m.RowCollector = &RowSampleCollector{}
			}
			if err := m.RowCollector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnalyze(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnalyze
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnalyzeIndexResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnalyze
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnalyzeIndexResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnalyzeIndexResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hist", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalyze
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hist == nil {
				m.Hist = &Histogram{}
			}
			if err := m.Hist.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalyze
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cms == nil {
				m.Cms = &CMSketch{}
			}
			if err := m.Cms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalyze
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Collector == nil {
				m.Collector = &SampleCollector{}
			}
			if err := m.Collector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnalyze(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnalyze
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Bucket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnalyze
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bucket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bucket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowerBound", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAnalyze
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LowerBound = append(m.LowerBound[:0], dAtA[iNdEx:postIndex]...)
			if m.LowerBound == nil {
				m.LowerBound = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpperBound", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAnalyze
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpperBound = append(m.UpperBound[:0], dAtA[iNdEx:postIndex]...)
			if m.UpperBound == nil {
				m.UpperBound = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repeats", wireType)
			}
			m.Repeats = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Repeats |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ndv", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ndv = &v
		default:
			iNdEx = preIndex
			skippy, err := skipAnalyze(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnalyze
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Histogram) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnalyze
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Histogram: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Histogram: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ndv", wireType)
			}
			m.Ndv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ndv |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buckets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalyze
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buckets = append(m.Buckets, &Bucket{})
			if err := m.Buckets[len(m.Buckets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnalyze(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnalyze
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FMSketch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnalyze
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FMSketch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FMSketch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mask", wireType)
			}
			m.Mask = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mask |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAnalyze
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Hashset = append(m.Hashset, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAnalyze
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAnalyze
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAnalyze
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Hashset = append(m.Hashset, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Hashset", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAnalyze(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnalyze
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SampleCollector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnalyze
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SampleCollector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SampleCollector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Samples", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAnalyze
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Samples = append(m.Samples, make([]byte, postIndex-iNdEx))
			copy(m.Samples[len(m.Samples)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NullCount", wireType)
			}
			m.NullCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NullCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FmSketch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalyze
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FmSketch == nil {
				m.FmSketch = &FMSketch{}
			}
			if err := m.FmSketch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmSketch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalyze
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CmSketch == nil {
				m.CmSketch = &CMSketch{}
			}
			if err := m.CmSketch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSize", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalSize = &v
		default:
			iNdEx = preIndex
			skippy, err := skipAnalyze(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnalyze
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RowSampleCollector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnalyze
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RowSampleCollector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RowSampleCollector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Samples", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalyze
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Samples = append(m.Samples, &RowSample{})
			if err := m.Samples[len(m.Samples)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAnalyze
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NullCounts = append(m.NullCounts, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAnalyze
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAnalyze
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAnalyze
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NullCounts = append(m.NullCounts, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NullCounts", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FmSketch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalyze
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FmSketch = append(m.FmSketch, &FMSketch{})
			if err := m.FmSketch[len(m.FmSketch)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAnalyze
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TotalSize = append(m.TotalSize, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAnalyze
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAnalyze
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAnalyze
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TotalSize = append(m.TotalSize, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSize", wireType)
			}
		case 6:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAnalyze
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SampleNdvOffsets = append(m.SampleNdvOffsets, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAnalyze
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAnalyze
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAnalyze
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SampleNdvOffsets = append(m.SampleNdvOffsets, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleNdvOffsets", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleFmSketch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalyze
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SampleFmSketch = append(m.SampleFmSketch, &FMSketch{})
			if err := m.SampleFmSketch[len(m.SampleFmSketch)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleF1FmSketch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalyze
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SampleF1FmSketch = append(m.SampleF1FmSketch, &FMSketch{})
			if err := m.SampleF1FmSketch[len(m.SampleF1FmSketch)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnalyze(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnalyze
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RowSample) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnalyze
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RowSample: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RowSample: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Row", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAnalyze
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Row = append(m.Row, make([]byte, postIndex-iNdEx))
			copy(m.Row[len(m.Row)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			m.Weight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Weight |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAnalyze(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnalyze
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMSketchRow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnalyze
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMSketchRow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMSketchRow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAnalyze
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Counters = append(m.Counters, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAnalyze
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAnalyze
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAnalyze
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Counters = append(m.Counters, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Counters", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAnalyze(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnalyze
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMSketchTopN) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnalyze
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMSketchTopN: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMSketchTopN: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAnalyze
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAnalyze(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnalyze
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMSketch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnalyze
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMSketch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMSketch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalyze
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rows = append(m.Rows, &CMSketchRow{})
			if err := m.Rows[len(m.Rows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopN", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalyze
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopN = append(m.TopN, &CMSketchTopN{})
			if err := m.TopN[len(m.TopN)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValue", wireType)
			}
			m.DefaultValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultValue |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAnalyze(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnalyze
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAnalyze(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAnalyze
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAnalyze
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAnalyze
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAnalyze
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAnalyze(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAnalyze = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAnalyze   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("analyze.proto", fileDescriptorAnalyze) }

var fileDescriptorAnalyze = []byte{
	// 1317 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0x5f, 0x6f, 0xdc, 0x44,
	0x10, 0xaf, 0xcf, 0xbe, 0x7f, 0x73, 0x77, 0xc9, 0x65, 0xfb, 0x07, 0x13, 0x95, 0xf4, 0xe4, 0xaa,
	0xed, 0xa5, 0x45, 0x07, 0x4d, 0x85, 0x04, 0xaa, 0x5a, 0x89, 0x14, 0x85, 0x56, 0xd0, 0x52, 0x6d,
	0x2b, 0x90, 0x78, 0xb1, 0x1c, 0x7b, 0xef, 0xce, 0x8a, 0xed, 0x75, 0xbc, 0x7b, 0xb9, 0x34, 0xe2,
	0x15, 0x1e, 0xe1, 0x0d, 0xf5, 0x7b, 0xc0, 0x87, 0xe8, 0x23, 0x9f, 0x00, 0xa1, 0x22, 0x3e, 0x02,
	0xef, 0x68, 0xff, 0xf9, 0x7c, 0xc9, 0x15, 0xb5, 0x4f, 0xde, 0x9d, 0xf9, 0xcd, 0xec, 0xcc, 0x6f,
	0x76, 0x67, 0x0c, 0xbd, 0x20, 0x0b, 0x92, 0x17, 0x27, 0x64, 0x94, 0x17, 0x94, 0x53, 0xe4, 0xf0,
	0x38, 0xdf, 0xdf, 0xec, 0xb2, 0x70, 0x4a, 0xd2, 0x40, 0xc9, 0x36, 0x2f, 0x4c, 0xe8, 0x84, 0xca,
	0xe5, 0x47, 0x62, 0xa5, 0xa4, 0xde, 0x2f, 0x35, 0x80, 0xcf, 0x95, 0x2d, 0x26, 0x87, 0xe8, 0x06,
	0xd4, 0x78, 0xee, 0x5a, 0x03, 0x6b, 0xb8, 0xb6, 0xb3, 0x31, 0x12, 0x5e, 0x46, 0x5a, 0xfb, 0xfc,
	0x45, 0x4e, 0x76, 0x9d, 0x57, 0x7f, 0x5e, 0x39, 0x87, 0x6b, 0x3c, 0x47, 0x37, 0x61, 0x83, 0xf1,
	0xa0, 0xe0, 0x3e, 0x67, 0xfe, 0x38, 0x48, 0x92, 0xfd, 0x20, 0x3c, 0x70, 0x6b, 0x03, 0x6b, 0xe8,
	0xe0, 0x75, 0xa9, 0x78, 0xce, 0xf6, 0xb4, 0x18, 0x6d, 0x42, 0x7d, 0x9c, 0x04, 0x13, 0xe6, 0xda,
	0x42, 0xaf, 0x9d, 0x28, 0x11, 0x1a, 0x41, 0x9f, 0xc7, 0x29, 0xf1, 0x4f, 0x68, 0x46, 0x7c, 0x3a,
	0x1e, 0x33, 0xc2, 0x5d, 0x67, 0x60, 0x0d, 0x6d, 0x0d, 0x5b, 0x13, 0xda, 0xef, 0x69, 0x46, 0xbe,
	0x91, 0x3a, 0x34, 0x82, 0x66, 0x1c, 0x1d, 0xfb, 0x05, 0x39, 0x74, 0xeb, 0x03, 0x6b, 0xd8, 0xd9,
	0xb9, 0xb8, 0x14, 0xe5, 0xa3, 0x2c, 0x22, 0xc7, 0x98, 0x1c, 0xe2, 0x46, 0x1c, 0x89, 0x2f, 0xfa,
	0x18, 0x9a, 0x21, 0x4d, 0x24, 0xbe, 0x21, 0xf1, 0xef, 0x2d, 0xe1, 0x1f, 0xd0, 0x64, 0x96, 0x66,
	0x4c, 0x5a, 0x84, 0x34, 0xc1, 0xe4, 0xd0, 0xfb, 0xad, 0x06, 0xeb, 0xa7, 0xbc, 0xa1, 0x6b, 0xd0,
	0xd9, 0x9f, 0x85, 0x07, 0x84, 0xfb, 0x2c, 0x3e, 0x21, 0x92, 0x1f, 0x13, 0x20, 0x28, 0xc5, 0xb3,
	0xf8, 0x84, 0x08, 0x58, 0x36, 0x4b, 0xfd, 0x50, 0x39, 0x95, 0x74, 0xd4, 0x0d, 0x2c, 0x9b, 0xa5,
	0xfa, 0x30, 0x74, 0x0d, 0xd6, 0xc2, 0x94, 0x1d, 0x10, 0x1e, 0x4e, 0xfd, 0x88, 0xe4, 0x7c, 0x2a,
	0x89, 0xa9, 0xe3, 0x9e, 0x91, 0x7e, 0x21, 0x84, 0x4b, 0xb0, 0x79, 0x1c, 0xf1, 0xa9, 0x24, 0xa6,
	0x02, 0xfb, 0x4e, 0x08, 0xc5, 0xa1, 0x2c, 0x48, 0xf3, 0x84, 0xa8, 0xd8, 0xea, 0xd5, 0xd8, 0x94,
	0xc2, 0xc4, 0xa6, 0x7d, 0x49, 0x58, 0x63, 0x09, 0x26, 0x15, 0x12, 0x76, 0x19, 0x80, 0xd3, 0xdc,
	0xcf, 0x14, 0xaa, 0x29, 0x0f, 0x6c, 0x71, 0x9a, 0x3f, 0x91, 0x5a, 0x17, 0x9a, 0x47, 0xa4, 0x60,
	0x31, 0xcd, 0xdc, 0x96, 0x54, 0x99, 0xad, 0xf7, 0xab, 0x03, 0x1b, 0x67, 0x38, 0x7d, 0x07, 0xde,
	0xaa, 0x29, 0xd4, 0xde, 0x2e, 0x05, 0xfb, 0x0d, 0x29, 0xdc, 0x81, 0xae, 0xae, 0x80, 0x1f, 0x67,
	0x63, 0xea, 0x3a, 0x03, 0x7b, 0xd8, 0xd9, 0xe9, 0xab, 0xba, 0xab, 0xe0, 0x1e, 0x65, 0x63, 0x8a,
	0x3b, 0x1a, 0x25, 0x36, 0x2b, 0x6a, 0x52, 0x7f, 0xbb, 0x9a, 0x34, 0x56, 0xd5, 0xe4, 0x43, 0x40,
	0x79, 0x11, 0xa7, 0x41, 0xf1, 0x42, 0x5f, 0x06, 0x3f, 0x8e, 0x98, 0xdb, 0x1c, 0xd8, 0x43, 0x1b,
	0xf7, 0xb5, 0x46, 0x47, 0x12, 0xb1, 0x37, 0xb3, 0x8a, 0x3e, 0x83, 0xf7, 0x8d, 0x9f, 0xbc, 0x20,
	0xe3, 0xf8, 0xb8, 0xea, 0xae, 0x2d, 0xdd, 0x5d, 0xd2, 0x80, 0xa7, 0x52, 0xbf, 0x70, 0x7a, 0x0f,
	0x7a, 0x1a, 0x3b, 0x29, 0xe8, 0x2c, 0x67, 0x2e, 0x48, 0x1a, 0xdc, 0x15, 0xd7, 0xff, 0x4b, 0x01,
	0xc0, 0x9a, 0x34, 0xb9, 0x61, 0xe8, 0x4a, 0x59, 0x92, 0x22, 0xe0, 0xc4, 0xed, 0x0c, 0xac, 0xa1,
	0x65, 0x8a, 0x81, 0x03, 0x4e, 0xd0, 0x75, 0x58, 0xcf, 0xa2, 0x23, 0xbf, 0x0a, 0xea, 0x0e, 0xec,
	0xa1, 0x85, 0x7b, 0x59, 0x74, 0xf4, 0xac, 0xc4, 0x79, 0x3f, 0x59, 0xd0, 0xd7, 0xa7, 0x3d, 0x8e,
	0x8f, 0x49, 0x84, 0x09, 0xcb, 0xd1, 0xdd, 0x45, 0x89, 0x0a, 0xc2, 0x54, 0xc3, 0x59, 0x1d, 0x1b,
	0x13, 0xf8, 0xb2, 0x54, 0xd2, 0xf8, 0x13, 0x80, 0x58, 0x3c, 0x4c, 0x65, 0x5a, 0x93, 0xa6, 0x97,
	0x56, 0x75, 0x01, 0x96, 0xe3, 0x76, 0x6c, 0x96, 0xde, 0x3e, 0xa0, 0xb3, 0x59, 0xcb, 0x82, 0x2a,
	0x9a, 0x54, 0xf3, 0x61, 0xae, 0x25, 0x69, 0xd5, 0xe4, 0xa9, 0xae, 0x23, 0x9f, 0xac, 0x2e, 0x40,
	0x42, 0xb2, 0x09, 0x9f, 0x8a, 0xc7, 0x2d, 0x61, 0x4a, 0xfa, 0xb5, 0x12, 0x7a, 0xbf, 0x5b, 0xa7,
	0x0e, 0x29, 0x23, 0x0e, 0x69, 0x92, 0x90, 0x90, 0xd3, 0x42, 0x1d, 0x50, 0xf6, 0x2d, 0xc5, 0xd4,
	0x03, 0xa3, 0xc5, 0x15, 0x20, 0x1a, 0x42, 0x33, 0x3f, 0xf0, 0xa7, 0x31, 0xe3, 0x3a, 0xcb, 0x75,
	0x65, 0xf3, 0x30, 0x66, 0x9c, 0x4e, 0x8a, 0x20, 0xc5, 0x8d, 0xfc, 0x40, 0x6c, 0x44, 0xb1, 0x0b,
	0x3a, 0xf7, 0x4b, 0x5b, 0xf9, 0x36, 0x4a, 0x42, 0x31, 0x9d, 0x9f, 0x3e, 0xa6, 0x5b, 0xd0, 0x79,
	0xb9, 0xf3, 0x7e, 0x5e, 0xd4, 0xa8, 0xa4, 0x0e, 0x5d, 0x05, 0x47, 0x1e, 0x6d, 0xad, 0x3e, 0x5a,
	0x2a, 0xd1, 0x00, 0xec, 0x30, 0x65, 0x3a, 0xbc, 0x35, 0xfd, 0xc4, 0x1e, 0x3f, 0x93, 0x4f, 0x01,
	0x0b, 0x15, 0xba, 0x03, 0xed, 0xd3, 0x61, 0xbd, 0x21, 0xf5, 0x05, 0xce, 0x7b, 0x69, 0x41, 0x63,
	0x57, 0xf6, 0x07, 0x31, 0x3c, 0x42, 0x3a, 0xcb, 0xf8, 0x52, 0xf3, 0x50, 0x22, 0x71, 0x49, 0x13,
	0x3a, 0x27, 0x85, 0xbf, 0x4f, 0x67, 0x59, 0x24, 0xa3, 0xe8, 0x62, 0x90, 0xa2, 0x5d, 0x21, 0x11,
	0x80, 0x59, 0x9e, 0x97, 0x00, 0x5b, 0x01, 0xa4, 0x48, 0x01, 0xb6, 0xa0, 0x59, 0x90, 0x9c, 0x04,
	0x9c, 0x2d, 0x4d, 0x1d, 0x23, 0x44, 0x7d, 0xb0, 0xb3, 0xe8, 0x48, 0x35, 0x55, 0x2c, 0x96, 0xde,
	0x57, 0xd0, 0x2e, 0x49, 0x40, 0x97, 0x94, 0xba, 0x1a, 0x9a, 0x10, 0xa0, 0xeb, 0xd0, 0x54, 0xed,
	0x4d, 0xdd, 0x93, 0xce, 0x4e, 0x57, 0xa5, 0xac, 0x72, 0xc2, 0x46, 0xe9, 0xdd, 0x87, 0xd6, 0x9e,
	0x66, 0x0b, 0xb9, 0xe0, 0xa4, 0x01, 0x3b, 0x90, 0xce, 0xcc, 0x90, 0x94, 0x12, 0xd1, 0x1f, 0xa6,
	0x01, 0x9b, 0x8a, 0xd1, 0x28, 0xbc, 0x39, 0xd8, 0x6c, 0xbd, 0x7f, 0x2c, 0x58, 0x3f, 0x45, 0xa3,
	0x40, 0xab, 0x47, 0xa9, 0x6e, 0x5a, 0x17, 0x9b, 0x2d, 0xba, 0x0a, 0x90, 0xcd, 0x92, 0xc4, 0x57,
	0x7c, 0x56, 0xbb, 0x6c, 0x5b, 0xc8, 0x1f, 0x48, 0x4e, 0x4b, 0xbe, 0xed, 0xb3, 0x7c, 0xdf, 0x82,
	0xf6, 0x38, 0xf5, 0x55, 0xa3, 0x93, 0x7c, 0x95, 0x35, 0x37, 0x59, 0xe0, 0xd6, 0x38, 0xd5, 0xf9,
	0xdc, 0x82, 0x76, 0x58, 0x82, 0xeb, 0x2b, 0x2f, 0x48, 0x2b, 0x34, 0xe0, 0x0f, 0xc4, 0xd8, 0xe1,
	0x41, 0x52, 0x19, 0x4e, 0xb8, 0x2d, 0x25, 0xa2, 0xa5, 0x7b, 0xff, 0xd6, 0x00, 0x9d, 0xbd, 0xc5,
	0x68, 0x7b, 0x39, 0xd5, 0xf2, 0x96, 0x96, 0xd0, 0x45, 0xee, 0x72, 0x34, 0x9b, 0xdc, 0xf5, 0xeb,
	0x5d, 0x8c, 0x66, 0x9d, 0x3c, 0x7b, 0x97, 0xec, 0xed, 0xff, 0xcd, 0x7e, 0x39, 0xa1, 0xba, 0x6c,
	0x16, 0x8b, 0x84, 0xc4, 0x80, 0xd0, 0x9d, 0x53, 0x34, 0x51, 0xd3, 0x7a, 0x1a, 0x6a, 0x40, 0x28,
	0xcd, 0x93, 0xe8, 0xc8, 0x74, 0x9f, 0x4f, 0x41, 0xcb, 0xfc, 0x45, 0x00, 0xcd, 0x95, 0x01, 0xac,
	0x29, 0xdc, 0x9e, 0x09, 0xe3, 0x1e, 0x9c, 0x37, 0x96, 0xb7, 0x2b, 0xc6, 0xad, 0x95, 0xc6, 0xfa,
	0x90, 0xbd, 0xdb, 0xc6, 0xdc, 0xbb, 0x0b, 0xed, 0x92, 0x4b, 0xf1, 0x16, 0x0a, 0x3a, 0xd7, 0x97,
	0x4a, 0x2c, 0xd1, 0x65, 0x68, 0xcc, 0x49, 0x3c, 0x99, 0x2e, 0x5f, 0x26, 0x2d, 0xf3, 0xb6, 0xa1,
	0x53, 0x56, 0x9a, 0xce, 0xd1, 0x26, 0xb4, 0x24, 0x8f, 0x44, 0xb7, 0xc0, 0x1e, 0x2e, 0xf7, 0xde,
	0x7d, 0xe8, 0x1a, 0xe8, 0x73, 0x9a, 0x3f, 0x41, 0x08, 0x9c, 0x28, 0xe0, 0x81, 0x7c, 0x0b, 0x5d,
	0x2c, 0xd7, 0x8b, 0xd2, 0xd4, 0xaa, 0x7f, 0x91, 0x52, 0xe4, 0xfd, 0x68, 0x41, 0xcb, 0x38, 0x40,
	0xd7, 0xc0, 0x29, 0xe8, 0xdc, 0x5c, 0x89, 0x8d, 0x53, 0x77, 0x8e, 0xce, 0xb1, 0x54, 0xa3, 0x1b,
	0x50, 0x97, 0x7f, 0x3a, 0xfa, 0x85, 0xa2, 0x65, 0x9c, 0x08, 0x03, 0x3b, 0xe2, 0xc7, 0x07, 0x6d,
	0x43, 0x2f, 0x22, 0xe3, 0x60, 0x96, 0x70, 0xff, 0x28, 0x48, 0x66, 0x64, 0xe9, 0x37, 0xb6, 0xab,
	0x55, 0xdf, 0x0a, 0xcd, 0xcd, 0x1f, 0xa0, 0x53, 0xf9, 0x5d, 0x46, 0x3d, 0x68, 0x8b, 0xaf, 0xec,
	0xa9, 0xfd, 0x73, 0x68, 0x0d, 0x40, 0x6c, 0xd5, 0x64, 0xe8, 0x5b, 0xe8, 0x02, 0xf4, 0xd5, 0x3e,
	0x4d, 0x69, 0xf6, 0x30, 0xc8, 0xa2, 0x84, 0xf4, 0x6b, 0xe8, 0x3c, 0xac, 0x0b, 0xa9, 0x22, 0x5d,
	0x99, 0xda, 0xc6, 0x93, 0x9c, 0xa0, 0x7d, 0xc7, 0x58, 0xee, 0xcd, 0x92, 0x44, 0xe2, 0xe2, 0x6c,
	0xd2, 0xaf, 0xef, 0x6e, 0xbf, 0x7a, 0xbd, 0x65, 0xfd, 0xf1, 0x7a, 0xcb, 0xfa, 0xeb, 0xf5, 0x96,
	0xf5, 0xf2, 0xef, 0xad, 0x73, 0x70, 0x31, 0xa4, 0xe9, 0x28, 0x8f, 0xb3, 0x49, 0x18, 0xe4, 0x23,
	0x1e, 0x47, 0xfb, 0x32, 0xc9, 0xa7, 0xd6, 0x7f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x08, 0x46, 0x54,
	0x3e, 0x30, 0x0c, 0x00, 0x00,
}
