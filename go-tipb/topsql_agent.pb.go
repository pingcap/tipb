// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: topsql_agent.proto

package tipb

import (
	"context"
	encoding_binary "encoding/binary"
	"fmt"
	"io"
	"math"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"

	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ReportInterval int32

const (
	ReportInterval_REPORT_INTERVAL_UNSPECIFIED ReportInterval = 0
	ReportInterval_REPORT_INTERVAL_15S         ReportInterval = 15
	ReportInterval_REPORT_INTERVAL_30S         ReportInterval = 30
	ReportInterval_REPORT_INTERVAL_60S         ReportInterval = 60
)

var ReportInterval_name = map[int32]string{
	0:  "REPORT_INTERVAL_UNSPECIFIED",
	15: "REPORT_INTERVAL_15S",
	30: "REPORT_INTERVAL_30S",
	60: "REPORT_INTERVAL_60S",
}

var ReportInterval_value = map[string]int32{
	"REPORT_INTERVAL_UNSPECIFIED": 0,
	"REPORT_INTERVAL_15S":         15,
	"REPORT_INTERVAL_30S":         30,
	"REPORT_INTERVAL_60S":         60,
}

func (x ReportInterval) String() string {
	return proto.EnumName(ReportInterval_name, int32(x))
}

func (ReportInterval) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1b19f3a2fcd6965e, []int{0}
}

type TopSQLRecord struct {
	SqlDigest    []byte              `protobuf:"bytes,1,opt,name=sql_digest,json=sqlDigest,proto3" json:"sql_digest,omitempty"`
	PlanDigest   []byte              `protobuf:"bytes,2,opt,name=plan_digest,json=planDigest,proto3" json:"plan_digest,omitempty"`
	Items        []*TopSQLRecordItem `protobuf:"bytes,3,rep,name=items,proto3" json:"items,omitempty"`
	KeyspaceName []byte              `protobuf:"bytes,4,opt,name=keyspace_name,json=keyspaceName,proto3" json:"keyspace_name,omitempty"`
}

func (m *TopSQLRecord) Reset()         { *m = TopSQLRecord{} }
func (m *TopSQLRecord) String() string { return proto.CompactTextString(m) }
func (*TopSQLRecord) ProtoMessage()    {}
func (*TopSQLRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b19f3a2fcd6965e, []int{0}
}
func (m *TopSQLRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopSQLRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopSQLRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopSQLRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopSQLRecord.Merge(m, src)
}
func (m *TopSQLRecord) XXX_Size() int {
	return m.Size()
}
func (m *TopSQLRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_TopSQLRecord.DiscardUnknown(m)
}

var xxx_messageInfo_TopSQLRecord proto.InternalMessageInfo

func (m *TopSQLRecord) GetSqlDigest() []byte {
	if m != nil {
		return m.SqlDigest
	}
	return nil
}

func (m *TopSQLRecord) GetPlanDigest() []byte {
	if m != nil {
		return m.PlanDigest
	}
	return nil
}

func (m *TopSQLRecord) GetItems() []*TopSQLRecordItem {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *TopSQLRecord) GetKeyspaceName() []byte {
	if m != nil {
		return m.KeyspaceName
	}
	return nil
}

// TopRURecord represents RU statistics for a single (user, sql_digest, plan_digest) combination.
type TopRURecord struct {
	KeyspaceName []byte             `protobuf:"bytes,1,opt,name=keyspace_name,json=keyspaceName,proto3" json:"keyspace_name,omitempty"`
	User         string             `protobuf:"bytes,2,opt,name=user,proto3" json:"user,omitempty"`
	SqlDigest    []byte             `protobuf:"bytes,3,opt,name=sql_digest,json=sqlDigest,proto3" json:"sql_digest,omitempty"`
	PlanDigest   []byte             `protobuf:"bytes,4,opt,name=plan_digest,json=planDigest,proto3" json:"plan_digest,omitempty"`
	Items        []*TopRURecordItem `protobuf:"bytes,5,rep,name=items,proto3" json:"items,omitempty"`
}

func (m *TopRURecord) Reset()         { *m = TopRURecord{} }
func (m *TopRURecord) String() string { return proto.CompactTextString(m) }
func (*TopRURecord) ProtoMessage()    {}
func (*TopRURecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b19f3a2fcd6965e, []int{1}
}
func (m *TopRURecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopRURecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopRURecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopRURecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopRURecord.Merge(m, src)
}
func (m *TopRURecord) XXX_Size() int {
	return m.Size()
}
func (m *TopRURecord) XXX_DiscardUnknown() {
	xxx_messageInfo_TopRURecord.DiscardUnknown(m)
}

var xxx_messageInfo_TopRURecord proto.InternalMessageInfo

func (m *TopRURecord) GetKeyspaceName() []byte {
	if m != nil {
		return m.KeyspaceName
	}
	return nil
}

func (m *TopRURecord) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *TopRURecord) GetSqlDigest() []byte {
	if m != nil {
		return m.SqlDigest
	}
	return nil
}

func (m *TopRURecord) GetPlanDigest() []byte {
	if m != nil {
		return m.PlanDigest
	}
	return nil
}

func (m *TopRURecord) GetItems() []*TopRURecordItem {
	if m != nil {
		return m.Items
	}
	return nil
}

// TopRURecordItem represents statistics within a single time bucket.
type TopRURecordItem struct {
	TimestampSec uint64  `protobuf:"varint,1,opt,name=timestamp_sec,json=timestampSec,proto3" json:"timestamp_sec,omitempty"`
	TotalRu      float64 `protobuf:"fixed64,2,opt,name=total_ru,json=totalRu,proto3" json:"total_ru,omitempty"`
	ExecCount    uint64  `protobuf:"varint,3,opt,name=exec_count,json=execCount,proto3" json:"exec_count,omitempty"`
	ExecDuration uint64  `protobuf:"varint,4,opt,name=exec_duration,json=execDuration,proto3" json:"exec_duration,omitempty"`
}

func (m *TopRURecordItem) Reset()         { *m = TopRURecordItem{} }
func (m *TopRURecordItem) String() string { return proto.CompactTextString(m) }
func (*TopRURecordItem) ProtoMessage()    {}
func (*TopRURecordItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b19f3a2fcd6965e, []int{2}
}
func (m *TopRURecordItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopRURecordItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopRURecordItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopRURecordItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopRURecordItem.Merge(m, src)
}
func (m *TopRURecordItem) XXX_Size() int {
	return m.Size()
}
func (m *TopRURecordItem) XXX_DiscardUnknown() {
	xxx_messageInfo_TopRURecordItem.DiscardUnknown(m)
}

var xxx_messageInfo_TopRURecordItem proto.InternalMessageInfo

func (m *TopRURecordItem) GetTimestampSec() uint64 {
	if m != nil {
		return m.TimestampSec
	}
	return 0
}

func (m *TopRURecordItem) GetTotalRu() float64 {
	if m != nil {
		return m.TotalRu
	}
	return 0
}

func (m *TopRURecordItem) GetExecCount() uint64 {
	if m != nil {
		return m.ExecCount
	}
	return 0
}

func (m *TopRURecordItem) GetExecDuration() uint64 {
	if m != nil {
		return m.ExecDuration
	}
	return 0
}

type TopSQLRecordItem struct {
	TimestampSec        uint64            `protobuf:"varint,1,opt,name=timestamp_sec,json=timestampSec,proto3" json:"timestamp_sec,omitempty"`
	CpuTimeMs           uint32            `protobuf:"varint,2,opt,name=cpu_time_ms,json=cpuTimeMs,proto3" json:"cpu_time_ms,omitempty"`
	StmtExecCount       uint64            `protobuf:"varint,3,opt,name=stmt_exec_count,json=stmtExecCount,proto3" json:"stmt_exec_count,omitempty"`
	StmtKvExecCount     map[string]uint64 `protobuf:"bytes,4,rep,name=stmt_kv_exec_count,json=stmtKvExecCount,proto3" json:"stmt_kv_exec_count,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	StmtDurationSumNs   uint64            `protobuf:"varint,5,opt,name=stmt_duration_sum_ns,json=stmtDurationSumNs,proto3" json:"stmt_duration_sum_ns,omitempty"`
	StmtDurationCount   uint64            `protobuf:"varint,6,opt,name=stmt_duration_count,json=stmtDurationCount,proto3" json:"stmt_duration_count,omitempty"`
	StmtNetworkInBytes  uint64            `protobuf:"varint,7,opt,name=stmt_network_in_bytes,json=stmtNetworkInBytes,proto3" json:"stmt_network_in_bytes,omitempty"`
	StmtNetworkOutBytes uint64            `protobuf:"varint,8,opt,name=stmt_network_out_bytes,json=stmtNetworkOutBytes,proto3" json:"stmt_network_out_bytes,omitempty"`
}

func (m *TopSQLRecordItem) Reset()         { *m = TopSQLRecordItem{} }
func (m *TopSQLRecordItem) String() string { return proto.CompactTextString(m) }
func (*TopSQLRecordItem) ProtoMessage()    {}
func (*TopSQLRecordItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b19f3a2fcd6965e, []int{3}
}
func (m *TopSQLRecordItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopSQLRecordItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopSQLRecordItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopSQLRecordItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopSQLRecordItem.Merge(m, src)
}
func (m *TopSQLRecordItem) XXX_Size() int {
	return m.Size()
}
func (m *TopSQLRecordItem) XXX_DiscardUnknown() {
	xxx_messageInfo_TopSQLRecordItem.DiscardUnknown(m)
}

var xxx_messageInfo_TopSQLRecordItem proto.InternalMessageInfo

func (m *TopSQLRecordItem) GetTimestampSec() uint64 {
	if m != nil {
		return m.TimestampSec
	}
	return 0
}

func (m *TopSQLRecordItem) GetCpuTimeMs() uint32 {
	if m != nil {
		return m.CpuTimeMs
	}
	return 0
}

func (m *TopSQLRecordItem) GetStmtExecCount() uint64 {
	if m != nil {
		return m.StmtExecCount
	}
	return 0
}

func (m *TopSQLRecordItem) GetStmtKvExecCount() map[string]uint64 {
	if m != nil {
		return m.StmtKvExecCount
	}
	return nil
}

func (m *TopSQLRecordItem) GetStmtDurationSumNs() uint64 {
	if m != nil {
		return m.StmtDurationSumNs
	}
	return 0
}

func (m *TopSQLRecordItem) GetStmtDurationCount() uint64 {
	if m != nil {
		return m.StmtDurationCount
	}
	return 0
}

func (m *TopSQLRecordItem) GetStmtNetworkInBytes() uint64 {
	if m != nil {
		return m.StmtNetworkInBytes
	}
	return 0
}

func (m *TopSQLRecordItem) GetStmtNetworkOutBytes() uint64 {
	if m != nil {
		return m.StmtNetworkOutBytes
	}
	return 0
}

type SQLMeta struct {
	SqlDigest []byte `protobuf:"bytes,1,opt,name=sql_digest,json=sqlDigest,proto3" json:"sql_digest,omitempty"`
	// SQL text with sensitive fields trimmed.
	//
	// Producers should limit the size to less than 4KiB. Truncation can be chosen to reduce size.
	NormalizedSql string `protobuf:"bytes,2,opt,name=normalized_sql,json=normalizedSql,proto3" json:"normalized_sql,omitempty"`
	// If true, this sql and plan is internally generated by tidb itself, not user.
	IsInternalSql bool   `protobuf:"varint,3,opt,name=is_internal_sql,json=isInternalSql,proto3" json:"is_internal_sql,omitempty"`
	KeyspaceName  []byte `protobuf:"bytes,4,opt,name=keyspace_name,json=keyspaceName,proto3" json:"keyspace_name,omitempty"`
}

func (m *SQLMeta) Reset()         { *m = SQLMeta{} }
func (m *SQLMeta) String() string { return proto.CompactTextString(m) }
func (*SQLMeta) ProtoMessage()    {}
func (*SQLMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b19f3a2fcd6965e, []int{4}
}
func (m *SQLMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SQLMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SQLMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SQLMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SQLMeta.Merge(m, src)
}
func (m *SQLMeta) XXX_Size() int {
	return m.Size()
}
func (m *SQLMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_SQLMeta.DiscardUnknown(m)
}

var xxx_messageInfo_SQLMeta proto.InternalMessageInfo

func (m *SQLMeta) GetSqlDigest() []byte {
	if m != nil {
		return m.SqlDigest
	}
	return nil
}

func (m *SQLMeta) GetNormalizedSql() string {
	if m != nil {
		return m.NormalizedSql
	}
	return ""
}

func (m *SQLMeta) GetIsInternalSql() bool {
	if m != nil {
		return m.IsInternalSql
	}
	return false
}

func (m *SQLMeta) GetKeyspaceName() []byte {
	if m != nil {
		return m.KeyspaceName
	}
	return nil
}

type PlanMeta struct {
	PlanDigest []byte `protobuf:"bytes,1,opt,name=plan_digest,json=planDigest,proto3" json:"plan_digest,omitempty"`
	// Plan text with sensitive fields trimmed.
	//
	// Producers should limit the size to less than 4KiB. Consider use `encoded_normalized_plan` if the size exceeds.
	NormalizedPlan string `protobuf:"bytes,2,opt,name=normalized_plan,json=normalizedPlan,proto3" json:"normalized_plan,omitempty"`
	// If `normalized_plan` is unacceptably large, set `encoded_normalized_plan` instead.
	//
	// The textual normalized plan is expected to get by following steps:
	// 1. decode from base64
	// 2. decode from snappy
	// 3. decode from github.com/pingcap/tidb/util/plancodec.DecodeNormalizedPlan
	EncodedNormalizedPlan string `protobuf:"bytes,3,opt,name=encoded_normalized_plan,json=encodedNormalizedPlan,proto3" json:"encoded_normalized_plan,omitempty"`
	KeyspaceName          []byte `protobuf:"bytes,4,opt,name=keyspace_name,json=keyspaceName,proto3" json:"keyspace_name,omitempty"`
}

func (m *PlanMeta) Reset()         { *m = PlanMeta{} }
func (m *PlanMeta) String() string { return proto.CompactTextString(m) }
func (*PlanMeta) ProtoMessage()    {}
func (*PlanMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b19f3a2fcd6965e, []int{5}
}
func (m *PlanMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlanMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlanMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlanMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlanMeta.Merge(m, src)
}
func (m *PlanMeta) XXX_Size() int {
	return m.Size()
}
func (m *PlanMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_PlanMeta.DiscardUnknown(m)
}

var xxx_messageInfo_PlanMeta proto.InternalMessageInfo

func (m *PlanMeta) GetPlanDigest() []byte {
	if m != nil {
		return m.PlanDigest
	}
	return nil
}

func (m *PlanMeta) GetNormalizedPlan() string {
	if m != nil {
		return m.NormalizedPlan
	}
	return ""
}

func (m *PlanMeta) GetEncodedNormalizedPlan() string {
	if m != nil {
		return m.EncodedNormalizedPlan
	}
	return ""
}

func (m *PlanMeta) GetKeyspaceName() []byte {
	if m != nil {
		return m.KeyspaceName
	}
	return nil
}

type EmptyResponse struct {
}

func (m *EmptyResponse) Reset()         { *m = EmptyResponse{} }
func (m *EmptyResponse) String() string { return proto.CompactTextString(m) }
func (*EmptyResponse) ProtoMessage()    {}
func (*EmptyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b19f3a2fcd6965e, []int{6}
}
func (m *EmptyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EmptyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EmptyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EmptyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EmptyResponse.Merge(m, src)
}
func (m *EmptyResponse) XXX_Size() int {
	return m.Size()
}
func (m *EmptyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EmptyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EmptyResponse proto.InternalMessageInfo

type TopSQLSubRequest struct {
	// enable_top_ru controls TopRU collection and reporting.
	EnableTopRu bool `protobuf:"varint,1,opt,name=enable_top_ru,json=enableTopRu,proto3" json:"enable_top_ru,omitempty"`
	// report_interval controls report interval, options: 15s/30s/60s.
	ReportInterval ReportInterval `protobuf:"varint,2,opt,name=report_interval,json=reportInterval,proto3,enum=tipb.ReportInterval" json:"report_interval,omitempty"`
}

func (m *TopSQLSubRequest) Reset()         { *m = TopSQLSubRequest{} }
func (m *TopSQLSubRequest) String() string { return proto.CompactTextString(m) }
func (*TopSQLSubRequest) ProtoMessage()    {}
func (*TopSQLSubRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b19f3a2fcd6965e, []int{7}
}
func (m *TopSQLSubRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopSQLSubRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopSQLSubRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopSQLSubRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopSQLSubRequest.Merge(m, src)
}
func (m *TopSQLSubRequest) XXX_Size() int {
	return m.Size()
}
func (m *TopSQLSubRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TopSQLSubRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TopSQLSubRequest proto.InternalMessageInfo

func (m *TopSQLSubRequest) GetEnableTopRu() bool {
	if m != nil {
		return m.EnableTopRu
	}
	return false
}

func (m *TopSQLSubRequest) GetReportInterval() ReportInterval {
	if m != nil {
		return m.ReportInterval
	}
	return ReportInterval_REPORT_INTERVAL_UNSPECIFIED
}

type TopSQLSubResponse struct {
	// Types that are valid to be assigned to RespOneof:
	//	*TopSQLSubResponse_Record
	//	*TopSQLSubResponse_SqlMeta
	//	*TopSQLSubResponse_PlanMeta
	//	*TopSQLSubResponse_RuRecord
	RespOneof isTopSQLSubResponse_RespOneof `protobuf_oneof:"resp_oneof"`
}

func (m *TopSQLSubResponse) Reset()         { *m = TopSQLSubResponse{} }
func (m *TopSQLSubResponse) String() string { return proto.CompactTextString(m) }
func (*TopSQLSubResponse) ProtoMessage()    {}
func (*TopSQLSubResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b19f3a2fcd6965e, []int{8}
}
func (m *TopSQLSubResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopSQLSubResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopSQLSubResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopSQLSubResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopSQLSubResponse.Merge(m, src)
}
func (m *TopSQLSubResponse) XXX_Size() int {
	return m.Size()
}
func (m *TopSQLSubResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TopSQLSubResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TopSQLSubResponse proto.InternalMessageInfo

type isTopSQLSubResponse_RespOneof interface {
	isTopSQLSubResponse_RespOneof()
	MarshalTo([]byte) (int, error)
	Size() int
}

type TopSQLSubResponse_Record struct {
	Record *TopSQLRecord `protobuf:"bytes,1,opt,name=record,proto3,oneof" json:"record,omitempty"`
}
type TopSQLSubResponse_SqlMeta struct {
	SqlMeta *SQLMeta `protobuf:"bytes,2,opt,name=sql_meta,json=sqlMeta,proto3,oneof" json:"sql_meta,omitempty"`
}
type TopSQLSubResponse_PlanMeta struct {
	PlanMeta *PlanMeta `protobuf:"bytes,3,opt,name=plan_meta,json=planMeta,proto3,oneof" json:"plan_meta,omitempty"`
}
type TopSQLSubResponse_RuRecord struct {
	RuRecord *TopRURecord `protobuf:"bytes,4,opt,name=ru_record,json=ruRecord,proto3,oneof" json:"ru_record,omitempty"`
}

func (*TopSQLSubResponse_Record) isTopSQLSubResponse_RespOneof()   {}
func (*TopSQLSubResponse_SqlMeta) isTopSQLSubResponse_RespOneof()  {}
func (*TopSQLSubResponse_PlanMeta) isTopSQLSubResponse_RespOneof() {}
func (*TopSQLSubResponse_RuRecord) isTopSQLSubResponse_RespOneof() {}

func (m *TopSQLSubResponse) GetRespOneof() isTopSQLSubResponse_RespOneof {
	if m != nil {
		return m.RespOneof
	}
	return nil
}

func (m *TopSQLSubResponse) GetRecord() *TopSQLRecord {
	if x, ok := m.GetRespOneof().(*TopSQLSubResponse_Record); ok {
		return x.Record
	}
	return nil
}

func (m *TopSQLSubResponse) GetSqlMeta() *SQLMeta {
	if x, ok := m.GetRespOneof().(*TopSQLSubResponse_SqlMeta); ok {
		return x.SqlMeta
	}
	return nil
}

func (m *TopSQLSubResponse) GetPlanMeta() *PlanMeta {
	if x, ok := m.GetRespOneof().(*TopSQLSubResponse_PlanMeta); ok {
		return x.PlanMeta
	}
	return nil
}

func (m *TopSQLSubResponse) GetRuRecord() *TopRURecord {
	if x, ok := m.GetRespOneof().(*TopSQLSubResponse_RuRecord); ok {
		return x.RuRecord
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TopSQLSubResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TopSQLSubResponse_Record)(nil),
		(*TopSQLSubResponse_SqlMeta)(nil),
		(*TopSQLSubResponse_PlanMeta)(nil),
		(*TopSQLSubResponse_RuRecord)(nil),
	}
}

func init() {
	proto.RegisterEnum("tipb.ReportInterval", ReportInterval_name, ReportInterval_value)
	proto.RegisterType((*TopSQLRecord)(nil), "tipb.TopSQLRecord")
	proto.RegisterType((*TopRURecord)(nil), "tipb.TopRURecord")
	proto.RegisterType((*TopRURecordItem)(nil), "tipb.TopRURecordItem")
	proto.RegisterType((*TopSQLRecordItem)(nil), "tipb.TopSQLRecordItem")
	proto.RegisterMapType((map[string]uint64)(nil), "tipb.TopSQLRecordItem.StmtKvExecCountEntry")
	proto.RegisterType((*SQLMeta)(nil), "tipb.SQLMeta")
	proto.RegisterType((*PlanMeta)(nil), "tipb.PlanMeta")
	proto.RegisterType((*EmptyResponse)(nil), "tipb.EmptyResponse")
	proto.RegisterType((*TopSQLSubRequest)(nil), "tipb.TopSQLSubRequest")
	proto.RegisterType((*TopSQLSubResponse)(nil), "tipb.TopSQLSubResponse")
}

func init() { proto.RegisterFile("topsql_agent.proto", fileDescriptor_1b19f3a2fcd6965e) }

var fileDescriptor_1b19f3a2fcd6965e = []byte{
	// 1038 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x56, 0xc1, 0x6f, 0x1b, 0xc5,
	0x17, 0xf6, 0xc6, 0x4e, 0x62, 0x3f, 0xdb, 0xb1, 0x33, 0x49, 0x9a, 0xfc, 0xf2, 0x13, 0x6e, 0x65,
	0x04, 0x44, 0x6d, 0x71, 0x53, 0x47, 0x14, 0x8a, 0x40, 0x6a, 0xd3, 0x18, 0xc5, 0x22, 0x75, 0x9d,
	0xd9, 0x14, 0x71, 0x5b, 0xad, 0xd7, 0x43, 0xb4, 0xca, 0xee, 0xce, 0x7a, 0x67, 0x26, 0x10, 0xc4,
	0x9d, 0x2b, 0x17, 0x24, 0x0e, 0x5c, 0xb8, 0x71, 0x45, 0xfc, 0x13, 0x1c, 0x7b, 0xec, 0x81, 0x03,
	0x4a, 0x24, 0xfe, 0x0e, 0x34, 0x6f, 0x77, 0x5d, 0xdb, 0xeb, 0xa8, 0xb9, 0xed, 0x7e, 0xef, 0xfb,
	0xde, 0x7c, 0xef, 0xbd, 0x79, 0x5e, 0x03, 0x91, 0x3c, 0x14, 0x23, 0xcf, 0xb2, 0x4f, 0x59, 0x20,
	0x5b, 0x61, 0xc4, 0x25, 0x27, 0x05, 0xe9, 0x86, 0x83, 0xed, 0xf5, 0x53, 0x7e, 0xca, 0x11, 0x78,
	0xa0, 0x9f, 0xe2, 0xd8, 0x76, 0x2d, 0x52, 0x42, 0xe2, 0x63, 0x0c, 0x34, 0x7f, 0x33, 0xa0, 0x72,
	0xc2, 0x43, 0xf3, 0xf8, 0x88, 0x32, 0x87, 0x47, 0x43, 0xf2, 0x0e, 0x80, 0x4e, 0x38, 0x74, 0x4f,
	0x99, 0x90, 0x5b, 0xc6, 0x1d, 0x63, 0xa7, 0x42, 0x4b, 0x62, 0xe4, 0x1d, 0x20, 0x40, 0x6e, 0x43,
	0x39, 0xf4, 0xec, 0x20, 0x8d, 0x2f, 0x60, 0x1c, 0x34, 0x94, 0x10, 0xee, 0xc3, 0xa2, 0x2b, 0x99,
	0x2f, 0xb6, 0xf2, 0x77, 0xf2, 0x3b, 0xe5, 0xf6, 0xad, 0x96, 0x76, 0xd3, 0x9a, 0x3c, 0xa2, 0x2b,
	0x99, 0x4f, 0x63, 0x12, 0x79, 0x17, 0xaa, 0x67, 0xec, 0x42, 0x84, 0xb6, 0xc3, 0xac, 0xc0, 0xf6,
	0xd9, 0x56, 0x01, 0x13, 0x56, 0x52, 0xb0, 0x67, 0xfb, 0xac, 0xf9, 0xa7, 0x01, 0xe5, 0x13, 0x1e,
	0xd2, 0x97, 0x89, 0xc5, 0x8c, 0xc8, 0xc8, 0x8a, 0x08, 0x81, 0x82, 0x12, 0x2c, 0x42, 0x87, 0x25,
	0x8a, 0xcf, 0x33, 0xb5, 0xe5, 0xdf, 0x52, 0x5b, 0x21, 0x53, 0xdb, 0xbd, 0xb4, 0xb6, 0x45, 0xac,
	0x6d, 0x63, 0x5c, 0x5b, 0x6a, 0x6d, 0xa2, 0xb4, 0xe6, 0xcf, 0x06, 0xd4, 0x66, 0x42, 0xda, 0xb9,
	0x74, 0x7d, 0x26, 0xa4, 0xed, 0x87, 0x96, 0x60, 0x0e, 0x3a, 0x2f, 0xd0, 0xca, 0x18, 0x34, 0x99,
	0x43, 0xfe, 0x07, 0x45, 0xc9, 0xa5, 0xed, 0x59, 0x91, 0x42, 0xf7, 0x06, 0x5d, 0xc6, 0x77, 0xaa,
	0x74, 0x01, 0xec, 0x3b, 0xe6, 0x58, 0x0e, 0x57, 0x41, 0x5c, 0x40, 0x81, 0x96, 0x34, 0xf2, 0x4c,
	0x03, 0x3a, 0x3d, 0x86, 0x87, 0x2a, 0xb2, 0xa5, 0xcb, 0x03, 0x2c, 0xa1, 0x40, 0x2b, 0x1a, 0x3c,
	0x48, 0xb0, 0xe6, 0xbf, 0x79, 0xa8, 0xcf, 0x8e, 0xe3, 0x66, 0xc6, 0x1a, 0x50, 0x76, 0x42, 0x65,
	0x69, 0xcc, 0xf2, 0x05, 0x7a, 0xab, 0xd2, 0x92, 0x13, 0xaa, 0x13, 0xd7, 0x67, 0xcf, 0x05, 0x79,
	0x1f, 0x6a, 0x42, 0xfa, 0xd2, 0xca, 0x58, 0xac, 0x6a, 0xb8, 0x33, 0xb6, 0xf9, 0x35, 0x10, 0xe4,
	0x9d, 0x9d, 0x4f, 0x52, 0x0b, 0xd8, 0xd3, 0x7b, 0xf3, 0xef, 0x4b, 0xcb, 0x94, 0xbe, 0xfc, 0xf2,
	0x7c, 0x9c, 0xa3, 0x13, 0xc8, 0xe8, 0x82, 0xe2, 0x71, 0x13, 0x28, 0x79, 0x00, 0xeb, 0x98, 0x39,
	0x6d, 0x80, 0x25, 0x94, 0x6f, 0x05, 0x7a, 0x5e, 0xda, 0xc6, 0xaa, 0x8e, 0xa5, 0x7d, 0x30, 0x95,
	0xdf, 0x13, 0xa4, 0x05, 0x6b, 0xd3, 0x82, 0xd8, 0xcb, 0x52, 0x96, 0x1f, 0x1f, 0xf0, 0x10, 0x36,
	0x90, 0x1f, 0x30, 0xf9, 0x2d, 0x8f, 0xce, 0x2c, 0x37, 0xb0, 0x06, 0x17, 0x92, 0x89, 0xad, 0x65,
	0x54, 0x60, 0x5d, 0xbd, 0x38, 0xd6, 0x0d, 0xf6, 0x75, 0x84, 0xec, 0xc1, 0xad, 0x29, 0x09, 0x57,
	0x32, 0xd1, 0x14, 0x51, 0xb3, 0x36, 0xa1, 0x79, 0xa1, 0x24, 0x8a, 0xb6, 0xf7, 0x61, 0x7d, 0x5e,
	0xc5, 0xa4, 0x0e, 0xf9, 0x33, 0x76, 0x81, 0xd3, 0x29, 0x51, 0xfd, 0x48, 0xd6, 0x61, 0xf1, 0xdc,
	0xf6, 0x14, 0xc3, 0x71, 0x14, 0x68, 0xfc, 0xf2, 0xe9, 0xc2, 0x27, 0x46, 0xf3, 0x57, 0x03, 0x96,
	0xcd, 0xe3, 0xa3, 0xe7, 0x4c, 0xda, 0x6f, 0xdb, 0xea, 0xf7, 0x60, 0x25, 0xe0, 0x91, 0x6f, 0x7b,
	0xee, 0xf7, 0x6c, 0x68, 0x89, 0x91, 0x97, 0xac, 0x4d, 0xf5, 0x0d, 0x6a, 0x8e, 0x3c, 0x3d, 0x60,
	0x57, 0x58, 0x6e, 0x20, 0x59, 0x14, 0xd8, 0x1e, 0xf2, 0xf4, 0x80, 0x8b, 0xb4, 0xea, 0x8a, 0x6e,
	0x82, 0x6a, 0xde, 0x8d, 0xb6, 0xfa, 0x0f, 0x03, 0x8a, 0x7d, 0xcf, 0x0e, 0xd0, 0xdf, 0xcc, 0xea,
	0x19, 0x99, 0xd5, 0xfb, 0x00, 0x6a, 0x13, 0x0e, 0x75, 0x20, 0xb1, 0x38, 0x61, 0x5c, 0x67, 0x23,
	0x8f, 0x60, 0x93, 0x05, 0x0e, 0x1f, 0xb2, 0xa1, 0x35, 0x2b, 0xc8, 0xa3, 0x60, 0x23, 0x09, 0xf7,
	0xa6, 0x75, 0x37, 0xf2, 0x5c, 0x83, 0x6a, 0xc7, 0x0f, 0xe5, 0x05, 0x65, 0x22, 0xe4, 0x81, 0x60,
	0x4d, 0x95, 0xee, 0x92, 0xa9, 0x06, 0x94, 0x8d, 0x94, 0xb6, 0xda, 0x84, 0x2a, 0x0b, 0xec, 0x81,
	0xc7, 0x2c, 0xc9, 0x43, 0xbd, 0xc4, 0x06, 0xf6, 0xa8, 0x1c, 0x83, 0xfa, 0x27, 0x41, 0x91, 0xcf,
	0xa1, 0x16, 0xb1, 0x90, 0x47, 0x32, 0xee, 0xe6, 0xb9, 0x1d, 0x77, 0x7c, 0xa5, 0xbd, 0x1e, 0xdf,
	0x7f, 0x8a, 0xc1, 0x6e, 0x12, 0xa3, 0x2b, 0xd1, 0xd4, 0x7b, 0xf3, 0x6f, 0x03, 0x56, 0x27, 0xce,
	0x8d, 0xcd, 0x90, 0xfb, 0xb0, 0x14, 0xe1, 0xc6, 0xe0, 0x89, 0xe5, 0x36, 0xc9, 0xee, 0xd2, 0x61,
	0x8e, 0x26, 0x1c, 0x72, 0x17, 0x8a, 0xfa, 0x4a, 0xf8, 0x4c, 0xda, 0x78, 0x76, 0xb9, 0x5d, 0x8d,
	0xf9, 0xc9, 0x9d, 0x39, 0xcc, 0xd1, 0x65, 0x31, 0xf2, 0x70, 0x3c, 0x1f, 0x42, 0x09, 0xc7, 0x83,
	0xe4, 0x3c, 0x92, 0x57, 0x62, 0x72, 0x3a, 0xc1, 0xc3, 0x1c, 0x2d, 0x86, 0xe9, 0x34, 0x77, 0xa1,
	0x14, 0x29, 0x2b, 0xf1, 0x52, 0x40, 0xfa, 0x6a, 0xe6, 0xb7, 0x52, 0x2b, 0x22, 0x15, 0x3f, 0xef,
	0x57, 0x00, 0x22, 0x26, 0x42, 0x8b, 0x07, 0x8c, 0x7f, 0x73, 0xf7, 0x07, 0x58, 0x99, 0x6e, 0x00,
	0xb9, 0x0d, 0xff, 0xa7, 0x9d, 0xfe, 0x0b, 0x7a, 0x62, 0x75, 0x7b, 0x27, 0x1d, 0xfa, 0xd5, 0xd3,
	0x23, 0xeb, 0x65, 0xcf, 0xec, 0x77, 0x9e, 0x75, 0xbf, 0xe8, 0x76, 0x0e, 0xea, 0x39, 0xb2, 0x09,
	0x6b, 0xb3, 0x84, 0x87, 0x1f, 0x99, 0xf5, 0xda, 0xbc, 0xc0, 0xde, 0xae, 0x59, 0x6f, 0xcc, 0x0b,
	0x3c, 0xda, 0x35, 0xeb, 0x9f, 0xb5, 0x7f, 0x5c, 0xc0, 0xcf, 0x8d, 0x79, 0x7c, 0xf4, 0x54, 0x7f,
	0x55, 0xc9, 0x3e, 0xac, 0xc5, 0x6e, 0x26, 0x1b, 0x29, 0xc8, 0x9c, 0xee, 0x6e, 0xaf, 0xc5, 0xd8,
	0xf4, 0x1d, 0xc9, 0xed, 0x18, 0xe4, 0x63, 0xa8, 0xc6, 0x39, 0xd2, 0x85, 0x9c, 0xee, 0xf5, 0xf5,
	0xc2, 0xc7, 0x69, 0x2b, 0xc6, 0xab, 0x32, 0xd3, 0xf8, 0xeb, 0xa5, 0x4f, 0x80, 0x8c, 0x7d, 0xa7,
	0x4d, 0x17, 0x24, 0x3b, 0x88, 0x6b, 0x33, 0xb4, 0xfb, 0xe9, 0x7f, 0x83, 0xbe, 0x1a, 0x98, 0x6a,
	0x40, 0x9e, 0x40, 0xc9, 0x54, 0x03, 0xe1, 0x44, 0xee, 0x80, 0x91, 0xa9, 0x2f, 0xfb, 0x9b, 0xeb,
	0xbf, 0xbd, 0x99, 0xc1, 0xd3, 0x8c, 0xbb, 0xc6, 0xfe, 0xe3, 0xd7, 0xbf, 0x17, 0x8d, 0xbf, 0x2e,
	0x1b, 0xc6, 0xab, 0xcb, 0x86, 0xf1, 0xcf, 0x65, 0xc3, 0xf8, 0xe9, 0xaa, 0x91, 0xfb, 0xe5, 0xaa,
	0x91, 0x7b, 0x75, 0xd5, 0xc8, 0xbd, 0xbe, 0x6a, 0xe4, 0x60, 0xc3, 0xe1, 0x7e, 0x2b, 0x74, 0x83,
	0x53, 0xc7, 0x0e, 0x5b, 0xd2, 0x1d, 0x0e, 0x30, 0x5d, 0xdf, 0x18, 0x2c, 0xe1, 0x1f, 0x96, 0xbd,
	0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0xf7, 0xb5, 0xff, 0xc2, 0xf3, 0x08, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// TopSQLAgentClient is the client API for TopSQLAgent service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TopSQLAgentClient interface {
	// ReportTopSQLRecords is called periodically (e.g. per minute) to save the in-memory TopSQL records
	ReportTopSQLRecords(ctx context.Context, opts ...grpc.CallOption) (TopSQLAgent_ReportTopSQLRecordsClient, error)
	// ReportSQLMeta reports SQL meta to the agent.
	// The agent should ensure that the SQL meta exists before sending the SQL CPU time records to the remote database.
	ReportSQLMeta(ctx context.Context, opts ...grpc.CallOption) (TopSQLAgent_ReportSQLMetaClient, error)
	// ReportPlanMeta reports plan meta to the agent.
	// The agent should deal with plan meta similarly to SQL meta.
	ReportPlanMeta(ctx context.Context, opts ...grpc.CallOption) (TopSQLAgent_ReportPlanMetaClient, error)
	// ReportTopRURecords is called periodically to save the in-memory TopRU records.
	ReportTopRURecords(ctx context.Context, opts ...grpc.CallOption) (TopSQLAgent_ReportTopRURecordsClient, error)
}

type topSQLAgentClient struct {
	cc *grpc.ClientConn
}

func NewTopSQLAgentClient(cc *grpc.ClientConn) TopSQLAgentClient {
	return &topSQLAgentClient{cc}
}

func (c *topSQLAgentClient) ReportTopSQLRecords(ctx context.Context, opts ...grpc.CallOption) (TopSQLAgent_ReportTopSQLRecordsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_TopSQLAgent_serviceDesc.Streams[0], "/tipb.TopSQLAgent/ReportTopSQLRecords", opts...)
	if err != nil {
		return nil, err
	}
	x := &topSQLAgentReportTopSQLRecordsClient{stream}
	return x, nil
}

type TopSQLAgent_ReportTopSQLRecordsClient interface {
	Send(*TopSQLRecord) error
	CloseAndRecv() (*EmptyResponse, error)
	grpc.ClientStream
}

type topSQLAgentReportTopSQLRecordsClient struct {
	grpc.ClientStream
}

func (x *topSQLAgentReportTopSQLRecordsClient) Send(m *TopSQLRecord) error {
	return x.ClientStream.SendMsg(m)
}

func (x *topSQLAgentReportTopSQLRecordsClient) CloseAndRecv() (*EmptyResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(EmptyResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *topSQLAgentClient) ReportSQLMeta(ctx context.Context, opts ...grpc.CallOption) (TopSQLAgent_ReportSQLMetaClient, error) {
	stream, err := c.cc.NewStream(ctx, &_TopSQLAgent_serviceDesc.Streams[1], "/tipb.TopSQLAgent/ReportSQLMeta", opts...)
	if err != nil {
		return nil, err
	}
	x := &topSQLAgentReportSQLMetaClient{stream}
	return x, nil
}

type TopSQLAgent_ReportSQLMetaClient interface {
	Send(*SQLMeta) error
	CloseAndRecv() (*EmptyResponse, error)
	grpc.ClientStream
}

type topSQLAgentReportSQLMetaClient struct {
	grpc.ClientStream
}

func (x *topSQLAgentReportSQLMetaClient) Send(m *SQLMeta) error {
	return x.ClientStream.SendMsg(m)
}

func (x *topSQLAgentReportSQLMetaClient) CloseAndRecv() (*EmptyResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(EmptyResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *topSQLAgentClient) ReportPlanMeta(ctx context.Context, opts ...grpc.CallOption) (TopSQLAgent_ReportPlanMetaClient, error) {
	stream, err := c.cc.NewStream(ctx, &_TopSQLAgent_serviceDesc.Streams[2], "/tipb.TopSQLAgent/ReportPlanMeta", opts...)
	if err != nil {
		return nil, err
	}
	x := &topSQLAgentReportPlanMetaClient{stream}
	return x, nil
}

type TopSQLAgent_ReportPlanMetaClient interface {
	Send(*PlanMeta) error
	CloseAndRecv() (*EmptyResponse, error)
	grpc.ClientStream
}

type topSQLAgentReportPlanMetaClient struct {
	grpc.ClientStream
}

func (x *topSQLAgentReportPlanMetaClient) Send(m *PlanMeta) error {
	return x.ClientStream.SendMsg(m)
}

func (x *topSQLAgentReportPlanMetaClient) CloseAndRecv() (*EmptyResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(EmptyResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *topSQLAgentClient) ReportTopRURecords(ctx context.Context, opts ...grpc.CallOption) (TopSQLAgent_ReportTopRURecordsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_TopSQLAgent_serviceDesc.Streams[3], "/tipb.TopSQLAgent/ReportTopRURecords", opts...)
	if err != nil {
		return nil, err
	}
	x := &topSQLAgentReportTopRURecordsClient{stream}
	return x, nil
}

type TopSQLAgent_ReportTopRURecordsClient interface {
	Send(*TopRURecord) error
	CloseAndRecv() (*EmptyResponse, error)
	grpc.ClientStream
}

type topSQLAgentReportTopRURecordsClient struct {
	grpc.ClientStream
}

func (x *topSQLAgentReportTopRURecordsClient) Send(m *TopRURecord) error {
	return x.ClientStream.SendMsg(m)
}

func (x *topSQLAgentReportTopRURecordsClient) CloseAndRecv() (*EmptyResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(EmptyResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// TopSQLAgentServer is the server API for TopSQLAgent service.
type TopSQLAgentServer interface {
	// ReportTopSQLRecords is called periodically (e.g. per minute) to save the in-memory TopSQL records
	ReportTopSQLRecords(TopSQLAgent_ReportTopSQLRecordsServer) error
	// ReportSQLMeta reports SQL meta to the agent.
	// The agent should ensure that the SQL meta exists before sending the SQL CPU time records to the remote database.
	ReportSQLMeta(TopSQLAgent_ReportSQLMetaServer) error
	// ReportPlanMeta reports plan meta to the agent.
	// The agent should deal with plan meta similarly to SQL meta.
	ReportPlanMeta(TopSQLAgent_ReportPlanMetaServer) error
	// ReportTopRURecords is called periodically to save the in-memory TopRU records.
	ReportTopRURecords(TopSQLAgent_ReportTopRURecordsServer) error
}

// UnimplementedTopSQLAgentServer can be embedded to have forward compatible implementations.
type UnimplementedTopSQLAgentServer struct {
}

func (*UnimplementedTopSQLAgentServer) ReportTopSQLRecords(srv TopSQLAgent_ReportTopSQLRecordsServer) error {
	return status.Errorf(codes.Unimplemented, "method ReportTopSQLRecords not implemented")
}
func (*UnimplementedTopSQLAgentServer) ReportSQLMeta(srv TopSQLAgent_ReportSQLMetaServer) error {
	return status.Errorf(codes.Unimplemented, "method ReportSQLMeta not implemented")
}
func (*UnimplementedTopSQLAgentServer) ReportPlanMeta(srv TopSQLAgent_ReportPlanMetaServer) error {
	return status.Errorf(codes.Unimplemented, "method ReportPlanMeta not implemented")
}
func (*UnimplementedTopSQLAgentServer) ReportTopRURecords(srv TopSQLAgent_ReportTopRURecordsServer) error {
	return status.Errorf(codes.Unimplemented, "method ReportTopRURecords not implemented")
}

func RegisterTopSQLAgentServer(s *grpc.Server, srv TopSQLAgentServer) {
	s.RegisterService(&_TopSQLAgent_serviceDesc, srv)
}

func _TopSQLAgent_ReportTopSQLRecords_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TopSQLAgentServer).ReportTopSQLRecords(&topSQLAgentReportTopSQLRecordsServer{stream})
}

type TopSQLAgent_ReportTopSQLRecordsServer interface {
	SendAndClose(*EmptyResponse) error
	Recv() (*TopSQLRecord, error)
	grpc.ServerStream
}

type topSQLAgentReportTopSQLRecordsServer struct {
	grpc.ServerStream
}

func (x *topSQLAgentReportTopSQLRecordsServer) SendAndClose(m *EmptyResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *topSQLAgentReportTopSQLRecordsServer) Recv() (*TopSQLRecord, error) {
	m := new(TopSQLRecord)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _TopSQLAgent_ReportSQLMeta_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TopSQLAgentServer).ReportSQLMeta(&topSQLAgentReportSQLMetaServer{stream})
}

type TopSQLAgent_ReportSQLMetaServer interface {
	SendAndClose(*EmptyResponse) error
	Recv() (*SQLMeta, error)
	grpc.ServerStream
}

type topSQLAgentReportSQLMetaServer struct {
	grpc.ServerStream
}

func (x *topSQLAgentReportSQLMetaServer) SendAndClose(m *EmptyResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *topSQLAgentReportSQLMetaServer) Recv() (*SQLMeta, error) {
	m := new(SQLMeta)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _TopSQLAgent_ReportPlanMeta_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TopSQLAgentServer).ReportPlanMeta(&topSQLAgentReportPlanMetaServer{stream})
}

type TopSQLAgent_ReportPlanMetaServer interface {
	SendAndClose(*EmptyResponse) error
	Recv() (*PlanMeta, error)
	grpc.ServerStream
}

type topSQLAgentReportPlanMetaServer struct {
	grpc.ServerStream
}

func (x *topSQLAgentReportPlanMetaServer) SendAndClose(m *EmptyResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *topSQLAgentReportPlanMetaServer) Recv() (*PlanMeta, error) {
	m := new(PlanMeta)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _TopSQLAgent_ReportTopRURecords_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TopSQLAgentServer).ReportTopRURecords(&topSQLAgentReportTopRURecordsServer{stream})
}

type TopSQLAgent_ReportTopRURecordsServer interface {
	SendAndClose(*EmptyResponse) error
	Recv() (*TopRURecord, error)
	grpc.ServerStream
}

type topSQLAgentReportTopRURecordsServer struct {
	grpc.ServerStream
}

func (x *topSQLAgentReportTopRURecordsServer) SendAndClose(m *EmptyResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *topSQLAgentReportTopRURecordsServer) Recv() (*TopRURecord, error) {
	m := new(TopRURecord)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _TopSQLAgent_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tipb.TopSQLAgent",
	HandlerType: (*TopSQLAgentServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ReportTopSQLRecords",
			Handler:       _TopSQLAgent_ReportTopSQLRecords_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "ReportSQLMeta",
			Handler:       _TopSQLAgent_ReportSQLMeta_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "ReportPlanMeta",
			Handler:       _TopSQLAgent_ReportPlanMeta_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "ReportTopRURecords",
			Handler:       _TopSQLAgent_ReportTopRURecords_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "topsql_agent.proto",
}

// TopSQLPubSubClient is the client API for TopSQLPubSub service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TopSQLPubSubClient interface {
	// Clients subscribe to TopSQL data through this RPC, and TiDB periodically (e.g. per minute)
	// publishes TopSQL data to clients via gRPC stream.
	Subscribe(ctx context.Context, in *TopSQLSubRequest, opts ...grpc.CallOption) (TopSQLPubSub_SubscribeClient, error)
}

type topSQLPubSubClient struct {
	cc *grpc.ClientConn
}

func NewTopSQLPubSubClient(cc *grpc.ClientConn) TopSQLPubSubClient {
	return &topSQLPubSubClient{cc}
}

func (c *topSQLPubSubClient) Subscribe(ctx context.Context, in *TopSQLSubRequest, opts ...grpc.CallOption) (TopSQLPubSub_SubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_TopSQLPubSub_serviceDesc.Streams[0], "/tipb.TopSQLPubSub/Subscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &topSQLPubSubSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TopSQLPubSub_SubscribeClient interface {
	Recv() (*TopSQLSubResponse, error)
	grpc.ClientStream
}

type topSQLPubSubSubscribeClient struct {
	grpc.ClientStream
}

func (x *topSQLPubSubSubscribeClient) Recv() (*TopSQLSubResponse, error) {
	m := new(TopSQLSubResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// TopSQLPubSubServer is the server API for TopSQLPubSub service.
type TopSQLPubSubServer interface {
	// Clients subscribe to TopSQL data through this RPC, and TiDB periodically (e.g. per minute)
	// publishes TopSQL data to clients via gRPC stream.
	Subscribe(*TopSQLSubRequest, TopSQLPubSub_SubscribeServer) error
}

// UnimplementedTopSQLPubSubServer can be embedded to have forward compatible implementations.
type UnimplementedTopSQLPubSubServer struct {
}

func (*UnimplementedTopSQLPubSubServer) Subscribe(req *TopSQLSubRequest, srv TopSQLPubSub_SubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}

func RegisterTopSQLPubSubServer(s *grpc.Server, srv TopSQLPubSubServer) {
	s.RegisterService(&_TopSQLPubSub_serviceDesc, srv)
}

func _TopSQLPubSub_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TopSQLSubRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TopSQLPubSubServer).Subscribe(m, &topSQLPubSubSubscribeServer{stream})
}

type TopSQLPubSub_SubscribeServer interface {
	Send(*TopSQLSubResponse) error
	grpc.ServerStream
}

type topSQLPubSubSubscribeServer struct {
	grpc.ServerStream
}

func (x *topSQLPubSubSubscribeServer) Send(m *TopSQLSubResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _TopSQLPubSub_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tipb.TopSQLPubSub",
	HandlerType: (*TopSQLPubSubServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Subscribe",
			Handler:       _TopSQLPubSub_Subscribe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "topsql_agent.proto",
}

func (m *TopSQLRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopSQLRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TopSQLRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.KeyspaceName) > 0 {
		i -= len(m.KeyspaceName)
		copy(dAtA[i:], m.KeyspaceName)
		i = encodeVarintTopsqlAgent(dAtA, i, uint64(len(m.KeyspaceName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTopsqlAgent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.PlanDigest) > 0 {
		i -= len(m.PlanDigest)
		copy(dAtA[i:], m.PlanDigest)
		i = encodeVarintTopsqlAgent(dAtA, i, uint64(len(m.PlanDigest)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SqlDigest) > 0 {
		i -= len(m.SqlDigest)
		copy(dAtA[i:], m.SqlDigest)
		i = encodeVarintTopsqlAgent(dAtA, i, uint64(len(m.SqlDigest)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TopRURecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopRURecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TopRURecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTopsqlAgent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.PlanDigest) > 0 {
		i -= len(m.PlanDigest)
		copy(dAtA[i:], m.PlanDigest)
		i = encodeVarintTopsqlAgent(dAtA, i, uint64(len(m.PlanDigest)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SqlDigest) > 0 {
		i -= len(m.SqlDigest)
		copy(dAtA[i:], m.SqlDigest)
		i = encodeVarintTopsqlAgent(dAtA, i, uint64(len(m.SqlDigest)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintTopsqlAgent(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.KeyspaceName) > 0 {
		i -= len(m.KeyspaceName)
		copy(dAtA[i:], m.KeyspaceName)
		i = encodeVarintTopsqlAgent(dAtA, i, uint64(len(m.KeyspaceName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TopRURecordItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopRURecordItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TopRURecordItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExecDuration != 0 {
		i = encodeVarintTopsqlAgent(dAtA, i, uint64(m.ExecDuration))
		i--
		dAtA[i] = 0x20
	}
	if m.ExecCount != 0 {
		i = encodeVarintTopsqlAgent(dAtA, i, uint64(m.ExecCount))
		i--
		dAtA[i] = 0x18
	}
	if m.TotalRu != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TotalRu))))
		i--
		dAtA[i] = 0x11
	}
	if m.TimestampSec != 0 {
		i = encodeVarintTopsqlAgent(dAtA, i, uint64(m.TimestampSec))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TopSQLRecordItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopSQLRecordItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TopSQLRecordItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StmtNetworkOutBytes != 0 {
		i = encodeVarintTopsqlAgent(dAtA, i, uint64(m.StmtNetworkOutBytes))
		i--
		dAtA[i] = 0x40
	}
	if m.StmtNetworkInBytes != 0 {
		i = encodeVarintTopsqlAgent(dAtA, i, uint64(m.StmtNetworkInBytes))
		i--
		dAtA[i] = 0x38
	}
	if m.StmtDurationCount != 0 {
		i = encodeVarintTopsqlAgent(dAtA, i, uint64(m.StmtDurationCount))
		i--
		dAtA[i] = 0x30
	}
	if m.StmtDurationSumNs != 0 {
		i = encodeVarintTopsqlAgent(dAtA, i, uint64(m.StmtDurationSumNs))
		i--
		dAtA[i] = 0x28
	}
	if len(m.StmtKvExecCount) > 0 {
		for k := range m.StmtKvExecCount {
			v := m.StmtKvExecCount[k]
			baseI := i
			i = encodeVarintTopsqlAgent(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTopsqlAgent(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTopsqlAgent(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.StmtExecCount != 0 {
		i = encodeVarintTopsqlAgent(dAtA, i, uint64(m.StmtExecCount))
		i--
		dAtA[i] = 0x18
	}
	if m.CpuTimeMs != 0 {
		i = encodeVarintTopsqlAgent(dAtA, i, uint64(m.CpuTimeMs))
		i--
		dAtA[i] = 0x10
	}
	if m.TimestampSec != 0 {
		i = encodeVarintTopsqlAgent(dAtA, i, uint64(m.TimestampSec))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SQLMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SQLMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SQLMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.KeyspaceName) > 0 {
		i -= len(m.KeyspaceName)
		copy(dAtA[i:], m.KeyspaceName)
		i = encodeVarintTopsqlAgent(dAtA, i, uint64(len(m.KeyspaceName)))
		i--
		dAtA[i] = 0x22
	}
	if m.IsInternalSql {
		i--
		if m.IsInternalSql {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.NormalizedSql) > 0 {
		i -= len(m.NormalizedSql)
		copy(dAtA[i:], m.NormalizedSql)
		i = encodeVarintTopsqlAgent(dAtA, i, uint64(len(m.NormalizedSql)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SqlDigest) > 0 {
		i -= len(m.SqlDigest)
		copy(dAtA[i:], m.SqlDigest)
		i = encodeVarintTopsqlAgent(dAtA, i, uint64(len(m.SqlDigest)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PlanMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlanMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlanMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.KeyspaceName) > 0 {
		i -= len(m.KeyspaceName)
		copy(dAtA[i:], m.KeyspaceName)
		i = encodeVarintTopsqlAgent(dAtA, i, uint64(len(m.KeyspaceName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.EncodedNormalizedPlan) > 0 {
		i -= len(m.EncodedNormalizedPlan)
		copy(dAtA[i:], m.EncodedNormalizedPlan)
		i = encodeVarintTopsqlAgent(dAtA, i, uint64(len(m.EncodedNormalizedPlan)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.NormalizedPlan) > 0 {
		i -= len(m.NormalizedPlan)
		copy(dAtA[i:], m.NormalizedPlan)
		i = encodeVarintTopsqlAgent(dAtA, i, uint64(len(m.NormalizedPlan)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PlanDigest) > 0 {
		i -= len(m.PlanDigest)
		copy(dAtA[i:], m.PlanDigest)
		i = encodeVarintTopsqlAgent(dAtA, i, uint64(len(m.PlanDigest)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EmptyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EmptyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EmptyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *TopSQLSubRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopSQLSubRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TopSQLSubRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReportInterval != 0 {
		i = encodeVarintTopsqlAgent(dAtA, i, uint64(m.ReportInterval))
		i--
		dAtA[i] = 0x10
	}
	if m.EnableTopRu {
		i--
		if m.EnableTopRu {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TopSQLSubResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopSQLSubResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TopSQLSubResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RespOneof != nil {
		{
			size := m.RespOneof.Size()
			i -= size
			if _, err := m.RespOneof.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *TopSQLSubResponse_Record) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TopSQLSubResponse_Record) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Record != nil {
		{
			size, err := m.Record.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTopsqlAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *TopSQLSubResponse_SqlMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TopSQLSubResponse_SqlMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SqlMeta != nil {
		{
			size, err := m.SqlMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTopsqlAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *TopSQLSubResponse_PlanMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TopSQLSubResponse_PlanMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PlanMeta != nil {
		{
			size, err := m.PlanMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTopsqlAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *TopSQLSubResponse_RuRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TopSQLSubResponse_RuRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RuRecord != nil {
		{
			size, err := m.RuRecord.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTopsqlAgent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func encodeVarintTopsqlAgent(dAtA []byte, offset int, v uint64) int {
	offset -= sovTopsqlAgent(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TopSQLRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SqlDigest)
	if l > 0 {
		n += 1 + l + sovTopsqlAgent(uint64(l))
	}
	l = len(m.PlanDigest)
	if l > 0 {
		n += 1 + l + sovTopsqlAgent(uint64(l))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovTopsqlAgent(uint64(l))
		}
	}
	l = len(m.KeyspaceName)
	if l > 0 {
		n += 1 + l + sovTopsqlAgent(uint64(l))
	}
	return n
}

func (m *TopRURecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KeyspaceName)
	if l > 0 {
		n += 1 + l + sovTopsqlAgent(uint64(l))
	}
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovTopsqlAgent(uint64(l))
	}
	l = len(m.SqlDigest)
	if l > 0 {
		n += 1 + l + sovTopsqlAgent(uint64(l))
	}
	l = len(m.PlanDigest)
	if l > 0 {
		n += 1 + l + sovTopsqlAgent(uint64(l))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovTopsqlAgent(uint64(l))
		}
	}
	return n
}

func (m *TopRURecordItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TimestampSec != 0 {
		n += 1 + sovTopsqlAgent(uint64(m.TimestampSec))
	}
	if m.TotalRu != 0 {
		n += 9
	}
	if m.ExecCount != 0 {
		n += 1 + sovTopsqlAgent(uint64(m.ExecCount))
	}
	if m.ExecDuration != 0 {
		n += 1 + sovTopsqlAgent(uint64(m.ExecDuration))
	}
	return n
}

func (m *TopSQLRecordItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TimestampSec != 0 {
		n += 1 + sovTopsqlAgent(uint64(m.TimestampSec))
	}
	if m.CpuTimeMs != 0 {
		n += 1 + sovTopsqlAgent(uint64(m.CpuTimeMs))
	}
	if m.StmtExecCount != 0 {
		n += 1 + sovTopsqlAgent(uint64(m.StmtExecCount))
	}
	if len(m.StmtKvExecCount) > 0 {
		for k, v := range m.StmtKvExecCount {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTopsqlAgent(uint64(len(k))) + 1 + sovTopsqlAgent(uint64(v))
			n += mapEntrySize + 1 + sovTopsqlAgent(uint64(mapEntrySize))
		}
	}
	if m.StmtDurationSumNs != 0 {
		n += 1 + sovTopsqlAgent(uint64(m.StmtDurationSumNs))
	}
	if m.StmtDurationCount != 0 {
		n += 1 + sovTopsqlAgent(uint64(m.StmtDurationCount))
	}
	if m.StmtNetworkInBytes != 0 {
		n += 1 + sovTopsqlAgent(uint64(m.StmtNetworkInBytes))
	}
	if m.StmtNetworkOutBytes != 0 {
		n += 1 + sovTopsqlAgent(uint64(m.StmtNetworkOutBytes))
	}
	return n
}

func (m *SQLMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SqlDigest)
	if l > 0 {
		n += 1 + l + sovTopsqlAgent(uint64(l))
	}
	l = len(m.NormalizedSql)
	if l > 0 {
		n += 1 + l + sovTopsqlAgent(uint64(l))
	}
	if m.IsInternalSql {
		n += 2
	}
	l = len(m.KeyspaceName)
	if l > 0 {
		n += 1 + l + sovTopsqlAgent(uint64(l))
	}
	return n
}

func (m *PlanMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PlanDigest)
	if l > 0 {
		n += 1 + l + sovTopsqlAgent(uint64(l))
	}
	l = len(m.NormalizedPlan)
	if l > 0 {
		n += 1 + l + sovTopsqlAgent(uint64(l))
	}
	l = len(m.EncodedNormalizedPlan)
	if l > 0 {
		n += 1 + l + sovTopsqlAgent(uint64(l))
	}
	l = len(m.KeyspaceName)
	if l > 0 {
		n += 1 + l + sovTopsqlAgent(uint64(l))
	}
	return n
}

func (m *EmptyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *TopSQLSubRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableTopRu {
		n += 2
	}
	if m.ReportInterval != 0 {
		n += 1 + sovTopsqlAgent(uint64(m.ReportInterval))
	}
	return n
}

func (m *TopSQLSubResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RespOneof != nil {
		n += m.RespOneof.Size()
	}
	return n
}

func (m *TopSQLSubResponse_Record) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Record != nil {
		l = m.Record.Size()
		n += 1 + l + sovTopsqlAgent(uint64(l))
	}
	return n
}
func (m *TopSQLSubResponse_SqlMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SqlMeta != nil {
		l = m.SqlMeta.Size()
		n += 1 + l + sovTopsqlAgent(uint64(l))
	}
	return n
}
func (m *TopSQLSubResponse_PlanMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlanMeta != nil {
		l = m.PlanMeta.Size()
		n += 1 + l + sovTopsqlAgent(uint64(l))
	}
	return n
}
func (m *TopSQLSubResponse_RuRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RuRecord != nil {
		l = m.RuRecord.Size()
		n += 1 + l + sovTopsqlAgent(uint64(l))
	}
	return n
}

func sovTopsqlAgent(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTopsqlAgent(x uint64) (n int) {
	return sovTopsqlAgent(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TopSQLRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopsqlAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopSQLRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopSQLRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SqlDigest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopsqlAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SqlDigest = append(m.SqlDigest[:0], dAtA[iNdEx:postIndex]...)
			if m.SqlDigest == nil {
				m.SqlDigest = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanDigest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopsqlAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlanDigest = append(m.PlanDigest[:0], dAtA[iNdEx:postIndex]...)
			if m.PlanDigest == nil {
				m.PlanDigest = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopsqlAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &TopSQLRecordItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyspaceName", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopsqlAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyspaceName = append(m.KeyspaceName[:0], dAtA[iNdEx:postIndex]...)
			if m.KeyspaceName == nil {
				m.KeyspaceName = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTopsqlAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopRURecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopsqlAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopRURecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopRURecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyspaceName", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopsqlAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyspaceName = append(m.KeyspaceName[:0], dAtA[iNdEx:postIndex]...)
			if m.KeyspaceName == nil {
				m.KeyspaceName = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopsqlAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SqlDigest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopsqlAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SqlDigest = append(m.SqlDigest[:0], dAtA[iNdEx:postIndex]...)
			if m.SqlDigest == nil {
				m.SqlDigest = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanDigest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopsqlAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlanDigest = append(m.PlanDigest[:0], dAtA[iNdEx:postIndex]...)
			if m.PlanDigest == nil {
				m.PlanDigest = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopsqlAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &TopRURecordItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTopsqlAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopRURecordItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopsqlAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopRURecordItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopRURecordItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampSec", wireType)
			}
			m.TimestampSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopsqlAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimestampSec |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRu", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TotalRu = float64(math.Float64frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecCount", wireType)
			}
			m.ExecCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopsqlAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExecCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecDuration", wireType)
			}
			m.ExecDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopsqlAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExecDuration |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTopsqlAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopSQLRecordItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopsqlAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopSQLRecordItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopSQLRecordItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampSec", wireType)
			}
			m.TimestampSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopsqlAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimestampSec |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuTimeMs", wireType)
			}
			m.CpuTimeMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopsqlAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuTimeMs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StmtExecCount", wireType)
			}
			m.StmtExecCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopsqlAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StmtExecCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StmtKvExecCount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopsqlAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StmtKvExecCount == nil {
				m.StmtKvExecCount = make(map[string]uint64)
			}
			var mapkey string
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTopsqlAgent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTopsqlAgent
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTopsqlAgent
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTopsqlAgent
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTopsqlAgent
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTopsqlAgent(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTopsqlAgent
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.StmtKvExecCount[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StmtDurationSumNs", wireType)
			}
			m.StmtDurationSumNs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopsqlAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StmtDurationSumNs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StmtDurationCount", wireType)
			}
			m.StmtDurationCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopsqlAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StmtDurationCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StmtNetworkInBytes", wireType)
			}
			m.StmtNetworkInBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopsqlAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StmtNetworkInBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StmtNetworkOutBytes", wireType)
			}
			m.StmtNetworkOutBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopsqlAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StmtNetworkOutBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTopsqlAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SQLMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopsqlAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SQLMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SQLMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SqlDigest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopsqlAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SqlDigest = append(m.SqlDigest[:0], dAtA[iNdEx:postIndex]...)
			if m.SqlDigest == nil {
				m.SqlDigest = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NormalizedSql", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopsqlAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NormalizedSql = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsInternalSql", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopsqlAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsInternalSql = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyspaceName", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopsqlAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyspaceName = append(m.KeyspaceName[:0], dAtA[iNdEx:postIndex]...)
			if m.KeyspaceName == nil {
				m.KeyspaceName = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTopsqlAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlanMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopsqlAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlanMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlanMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanDigest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopsqlAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlanDigest = append(m.PlanDigest[:0], dAtA[iNdEx:postIndex]...)
			if m.PlanDigest == nil {
				m.PlanDigest = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NormalizedPlan", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopsqlAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NormalizedPlan = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncodedNormalizedPlan", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopsqlAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncodedNormalizedPlan = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyspaceName", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopsqlAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyspaceName = append(m.KeyspaceName[:0], dAtA[iNdEx:postIndex]...)
			if m.KeyspaceName == nil {
				m.KeyspaceName = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTopsqlAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EmptyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopsqlAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmptyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmptyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTopsqlAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopSQLSubRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopsqlAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopSQLSubRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopSQLSubRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableTopRu", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopsqlAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableTopRu = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportInterval", wireType)
			}
			m.ReportInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopsqlAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReportInterval |= ReportInterval(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTopsqlAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopSQLSubResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopsqlAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopSQLSubResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopSQLSubResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Record", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopsqlAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TopSQLRecord{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RespOneof = &TopSQLSubResponse_Record{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SqlMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopsqlAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SQLMeta{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RespOneof = &TopSQLSubResponse_SqlMeta{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopsqlAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PlanMeta{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RespOneof = &TopSQLSubResponse_PlanMeta{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuRecord", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopsqlAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TopRURecord{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RespOneof = &TopSQLSubResponse_RuRecord{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTopsqlAgent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTopsqlAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTopsqlAgent(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTopsqlAgent
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTopsqlAgent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTopsqlAgent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTopsqlAgent
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTopsqlAgent
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTopsqlAgent
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTopsqlAgent        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTopsqlAgent          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTopsqlAgent = fmt.Errorf("proto: unexpected end of group")
)
