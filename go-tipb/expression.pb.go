// Code generated by protoc-gen-gogo.
// source: expression.proto
// DO NOT EDIT!

package tipb

import (
	"fmt"

	proto "github.com/golang/protobuf/proto"

	math "math"

	io "io"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// MySQL data types.
type DataType int32

const (
	DataType_TypeDecimal    DataType = 0
	DataType_TypeTiny       DataType = 1
	DataType_TypeShort      DataType = 2
	DataType_TypeLong       DataType = 3
	DataType_TypeFloat      DataType = 4
	DataType_TypeDouble     DataType = 5
	DataType_TypeNull       DataType = 6
	DataType_TypeTimestamp  DataType = 7
	DataType_TypeLongLong   DataType = 8
	DataType_TypeInt24      DataType = 9
	DataType_TypeDate       DataType = 10
	DataType_TypeDuration   DataType = 11
	DataType_TypeDatetime   DataType = 12
	DataType_TypeYear       DataType = 13
	DataType_TypeNewDate    DataType = 14
	DataType_TypeVarchar    DataType = 15
	DataType_TypeBit        DataType = 16
	DataType_TypeJSON       DataType = 245
	DataType_TypeNewDecimal DataType = 246
	DataType_TypeEnum       DataType = 247
	DataType_TypeSet        DataType = 248
	DataType_TypeTinyBlob   DataType = 249
	DataType_TypeMediumBlob DataType = 250
	DataType_TypeLongBlob   DataType = 251
	DataType_TypeBlob       DataType = 252
	DataType_TypeVarString  DataType = 253
	DataType_TypeString     DataType = 254
	DataType_TypeGeometry   DataType = 255
)

var DataType_name = map[int32]string{
	0:   "TypeDecimal",
	1:   "TypeTiny",
	2:   "TypeShort",
	3:   "TypeLong",
	4:   "TypeFloat",
	5:   "TypeDouble",
	6:   "TypeNull",
	7:   "TypeTimestamp",
	8:   "TypeLongLong",
	9:   "TypeInt24",
	10:  "TypeDate",
	11:  "TypeDuration",
	12:  "TypeDatetime",
	13:  "TypeYear",
	14:  "TypeNewDate",
	15:  "TypeVarchar",
	16:  "TypeBit",
	245: "TypeJSON",
	246: "TypeNewDecimal",
	247: "TypeEnum",
	248: "TypeSet",
	249: "TypeTinyBlob",
	250: "TypeMediumBlob",
	251: "TypeLongBlob",
	252: "TypeBlob",
	253: "TypeVarString",
	254: "TypeString",
	255: "TypeGeometry",
}
var DataType_value = map[string]int32{
	"TypeDecimal":    0,
	"TypeTiny":       1,
	"TypeShort":      2,
	"TypeLong":       3,
	"TypeFloat":      4,
	"TypeDouble":     5,
	"TypeNull":       6,
	"TypeTimestamp":  7,
	"TypeLongLong":   8,
	"TypeInt24":      9,
	"TypeDate":       10,
	"TypeDuration":   11,
	"TypeDatetime":   12,
	"TypeYear":       13,
	"TypeNewDate":    14,
	"TypeVarchar":    15,
	"TypeBit":        16,
	"TypeJSON":       245,
	"TypeNewDecimal": 246,
	"TypeEnum":       247,
	"TypeSet":        248,
	"TypeTinyBlob":   249,
	"TypeMediumBlob": 250,
	"TypeLongBlob":   251,
	"TypeBlob":       252,
	"TypeVarString":  253,
	"TypeString":     254,
	"TypeGeometry":   255,
}

func (x DataType) Enum() *DataType {
	p := new(DataType)
	*p = x
	return p
}
func (x DataType) String() string {
	return proto.EnumName(DataType_name, int32(x))
}
func (x *DataType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DataType_value, data, "DataType")
	if err != nil {
		return err
	}
	*x = DataType(value)
	return nil
}
func (DataType) EnumDescriptor() ([]byte, []int) { return fileDescriptorExpression, []int{0} }

type ExprType int32

const (
	// Values are encoded bytes.
	ExprType_Null    ExprType = 0
	ExprType_Int64   ExprType = 1
	ExprType_Uint64  ExprType = 2
	ExprType_Float32 ExprType = 3
	ExprType_Float64 ExprType = 4
	ExprType_String  ExprType = 5
	ExprType_Bytes   ExprType = 6
	// Mysql specific types.
	ExprType_MysqlBit      ExprType = 101
	ExprType_MysqlDecimal  ExprType = 102
	ExprType_MysqlDuration ExprType = 103
	ExprType_MysqlEnum     ExprType = 104
	ExprType_MysqlHex      ExprType = 105
	ExprType_MysqlSet      ExprType = 106
	ExprType_MysqlTime     ExprType = 107
	// Encoded value list.
	ExprType_ValueList ExprType = 151
	// Column reference. value is int64 column ID.
	ExprType_ColumnRef ExprType = 201
	// Unary operations, children count 1.
	ExprType_Not    ExprType = 1001
	ExprType_Neg    ExprType = 1002
	ExprType_BitNeg ExprType = 1003
	// Comparison operations.
	ExprType_LT     ExprType = 2001
	ExprType_LE     ExprType = 2002
	ExprType_EQ     ExprType = 2003
	ExprType_NE     ExprType = 2004
	ExprType_GE     ExprType = 2005
	ExprType_GT     ExprType = 2006
	ExprType_NullEQ ExprType = 2007
	// Bit operations.
	ExprType_BitAnd    ExprType = 2101
	ExprType_BitOr     ExprType = 2102
	ExprType_BitXor    ExprType = 2103
	ExprType_LeftShift ExprType = 2104
	ExprType_RighShift ExprType = 2105
	// Arithmatic.
	ExprType_Plus   ExprType = 2201
	ExprType_Minus  ExprType = 2202
	ExprType_Mul    ExprType = 2203
	ExprType_Div    ExprType = 2204
	ExprType_IntDiv ExprType = 2205
	ExprType_Mod    ExprType = 2206
	// Logic operations.
	ExprType_And ExprType = 2301
	ExprType_Or  ExprType = 2302
	ExprType_Xor ExprType = 2303
	// Aggregate functions.
	ExprType_Count       ExprType = 3001
	ExprType_Sum         ExprType = 3002
	ExprType_Avg         ExprType = 3003
	ExprType_Min         ExprType = 3004
	ExprType_Max         ExprType = 3005
	ExprType_First       ExprType = 3006
	ExprType_GroupConcat ExprType = 3007
	// Math functions.
	ExprType_Abs   ExprType = 3101
	ExprType_Pow   ExprType = 3102
	ExprType_Round ExprType = 3103
	// String functions.
	ExprType_Concat         ExprType = 3201
	ExprType_ConcatWS       ExprType = 3202
	ExprType_Left           ExprType = 3203
	ExprType_Length         ExprType = 3204
	ExprType_Lower          ExprType = 3205
	ExprType_Repeat         ExprType = 3206
	ExprType_Replace        ExprType = 3207
	ExprType_Upper          ExprType = 3208
	ExprType_Strcmp         ExprType = 3209
	ExprType_Convert        ExprType = 3210
	ExprType_Cast           ExprType = 3211
	ExprType_Substring      ExprType = 3212
	ExprType_SubstringIndex ExprType = 3213
	ExprType_Locate         ExprType = 3214
	ExprType_Trim           ExprType = 3215
	// Control flow functions.
	ExprType_If     ExprType = 3301
	ExprType_NullIf ExprType = 3302
	ExprType_IfNull ExprType = 3303
	// Time functions.
	ExprType_Date        ExprType = 3401
	ExprType_DateAdd     ExprType = 3402
	ExprType_DateSub     ExprType = 3403
	ExprType_Year        ExprType = 3411
	ExprType_YearWeek    ExprType = 3412
	ExprType_Month       ExprType = 3421
	ExprType_Week        ExprType = 3431
	ExprType_Weekday     ExprType = 3432
	ExprType_WeekOfYear  ExprType = 3433
	ExprType_Day         ExprType = 3441
	ExprType_DayName     ExprType = 3442
	ExprType_DayOfYear   ExprType = 3443
	ExprType_DayOfMonth  ExprType = 3444
	ExprType_DayOfWeek   ExprType = 3445
	ExprType_Hour        ExprType = 3451
	ExprType_Minute      ExprType = 3452
	ExprType_Second      ExprType = 3453
	ExprType_Microsecond ExprType = 3454
	ExprType_Extract     ExprType = 3461
	// Other functions;
	ExprType_Coalesce ExprType = 3501
	ExprType_Greatest ExprType = 3502
	ExprType_Least    ExprType = 3503
	// Json functions;
	ExprType_JsonExtract      ExprType = 3601
	ExprType_JsonType         ExprType = 3602
	ExprType_JsonArray        ExprType = 3603
	ExprType_JsonObject       ExprType = 3604
	ExprType_JsonMerge        ExprType = 3605
	ExprType_JsonValid        ExprType = 3606
	ExprType_JsonSet          ExprType = 3607
	ExprType_JsonInsert       ExprType = 3608
	ExprType_JsonReplace      ExprType = 3609
	ExprType_JsonRemove       ExprType = 3610
	ExprType_JsonContains     ExprType = 3611
	ExprType_JsonUnquote      ExprType = 3612
	ExprType_JsonContainsPath ExprType = 3613
	// Other expressions.
	ExprType_In      ExprType = 4001
	ExprType_IsTruth ExprType = 4002
	ExprType_IsNull  ExprType = 4003
	ExprType_ExprRow ExprType = 4004
	ExprType_Like    ExprType = 4005
	ExprType_RLike   ExprType = 4006
	ExprType_Case    ExprType = 4007
	// Scalar Function
	ExprType_ScalarFunc ExprType = 10000
)

var ExprType_name = map[int32]string{
	0:     "Null",
	1:     "Int64",
	2:     "Uint64",
	3:     "Float32",
	4:     "Float64",
	5:     "String",
	6:     "Bytes",
	101:   "MysqlBit",
	102:   "MysqlDecimal",
	103:   "MysqlDuration",
	104:   "MysqlEnum",
	105:   "MysqlHex",
	106:   "MysqlSet",
	107:   "MysqlTime",
	151:   "ValueList",
	201:   "ColumnRef",
	1001:  "Not",
	1002:  "Neg",
	1003:  "BitNeg",
	2001:  "LT",
	2002:  "LE",
	2003:  "EQ",
	2004:  "NE",
	2005:  "GE",
	2006:  "GT",
	2007:  "NullEQ",
	2101:  "BitAnd",
	2102:  "BitOr",
	2103:  "BitXor",
	2104:  "LeftShift",
	2105:  "RighShift",
	2201:  "Plus",
	2202:  "Minus",
	2203:  "Mul",
	2204:  "Div",
	2205:  "IntDiv",
	2206:  "Mod",
	2301:  "And",
	2302:  "Or",
	2303:  "Xor",
	3001:  "Count",
	3002:  "Sum",
	3003:  "Avg",
	3004:  "Min",
	3005:  "Max",
	3006:  "First",
	3007:  "GroupConcat",
	3101:  "Abs",
	3102:  "Pow",
	3103:  "Round",
	3201:  "Concat",
	3202:  "ConcatWS",
	3203:  "Left",
	3204:  "Length",
	3205:  "Lower",
	3206:  "Repeat",
	3207:  "Replace",
	3208:  "Upper",
	3209:  "Strcmp",
	3210:  "Convert",
	3211:  "Cast",
	3212:  "Substring",
	3213:  "SubstringIndex",
	3214:  "Locate",
	3215:  "Trim",
	3301:  "If",
	3302:  "NullIf",
	3303:  "IfNull",
	3401:  "Date",
	3402:  "DateAdd",
	3403:  "DateSub",
	3411:  "Year",
	3412:  "YearWeek",
	3421:  "Month",
	3431:  "Week",
	3432:  "Weekday",
	3433:  "WeekOfYear",
	3441:  "Day",
	3442:  "DayName",
	3443:  "DayOfYear",
	3444:  "DayOfMonth",
	3445:  "DayOfWeek",
	3451:  "Hour",
	3452:  "Minute",
	3453:  "Second",
	3454:  "Microsecond",
	3461:  "Extract",
	3501:  "Coalesce",
	3502:  "Greatest",
	3503:  "Least",
	3601:  "JsonExtract",
	3602:  "JsonType",
	3603:  "JsonArray",
	3604:  "JsonObject",
	3605:  "JsonMerge",
	3606:  "JsonValid",
	3607:  "JsonSet",
	3608:  "JsonInsert",
	3609:  "JsonReplace",
	3610:  "JsonRemove",
	3611:  "JsonContains",
	3612:  "JsonUnquote",
	3613:  "JsonContainsPath",
	4001:  "In",
	4002:  "IsTruth",
	4003:  "IsNull",
	4004:  "ExprRow",
	4005:  "Like",
	4006:  "RLike",
	4007:  "Case",
	10000: "ScalarFunc",
}
var ExprType_value = map[string]int32{
	"Null":             0,
	"Int64":            1,
	"Uint64":           2,
	"Float32":          3,
	"Float64":          4,
	"String":           5,
	"Bytes":            6,
	"MysqlBit":         101,
	"MysqlDecimal":     102,
	"MysqlDuration":    103,
	"MysqlEnum":        104,
	"MysqlHex":         105,
	"MysqlSet":         106,
	"MysqlTime":        107,
	"ValueList":        151,
	"ColumnRef":        201,
	"Not":              1001,
	"Neg":              1002,
	"BitNeg":           1003,
	"LT":               2001,
	"LE":               2002,
	"EQ":               2003,
	"NE":               2004,
	"GE":               2005,
	"GT":               2006,
	"NullEQ":           2007,
	"BitAnd":           2101,
	"BitOr":            2102,
	"BitXor":           2103,
	"LeftShift":        2104,
	"RighShift":        2105,
	"Plus":             2201,
	"Minus":            2202,
	"Mul":              2203,
	"Div":              2204,
	"IntDiv":           2205,
	"Mod":              2206,
	"And":              2301,
	"Or":               2302,
	"Xor":              2303,
	"Count":            3001,
	"Sum":              3002,
	"Avg":              3003,
	"Min":              3004,
	"Max":              3005,
	"First":            3006,
	"GroupConcat":      3007,
	"Abs":              3101,
	"Pow":              3102,
	"Round":            3103,
	"Concat":           3201,
	"ConcatWS":         3202,
	"Left":             3203,
	"Length":           3204,
	"Lower":            3205,
	"Repeat":           3206,
	"Replace":          3207,
	"Upper":            3208,
	"Strcmp":           3209,
	"Convert":          3210,
	"Cast":             3211,
	"Substring":        3212,
	"SubstringIndex":   3213,
	"Locate":           3214,
	"Trim":             3215,
	"If":               3301,
	"NullIf":           3302,
	"IfNull":           3303,
	"Date":             3401,
	"DateAdd":          3402,
	"DateSub":          3403,
	"Year":             3411,
	"YearWeek":         3412,
	"Month":            3421,
	"Week":             3431,
	"Weekday":          3432,
	"WeekOfYear":       3433,
	"Day":              3441,
	"DayName":          3442,
	"DayOfYear":        3443,
	"DayOfMonth":       3444,
	"DayOfWeek":        3445,
	"Hour":             3451,
	"Minute":           3452,
	"Second":           3453,
	"Microsecond":      3454,
	"Extract":          3461,
	"Coalesce":         3501,
	"Greatest":         3502,
	"Least":            3503,
	"JsonExtract":      3601,
	"JsonType":         3602,
	"JsonArray":        3603,
	"JsonObject":       3604,
	"JsonMerge":        3605,
	"JsonValid":        3606,
	"JsonSet":          3607,
	"JsonInsert":       3608,
	"JsonReplace":      3609,
	"JsonRemove":       3610,
	"JsonContains":     3611,
	"JsonUnquote":      3612,
	"JsonContainsPath": 3613,
	"In":               4001,
	"IsTruth":          4002,
	"IsNull":           4003,
	"ExprRow":          4004,
	"Like":             4005,
	"RLike":            4006,
	"Case":             4007,
	"ScalarFunc":       10000,
}

func (x ExprType) Enum() *ExprType {
	p := new(ExprType)
	*p = x
	return p
}
func (x ExprType) String() string {
	return proto.EnumName(ExprType_name, int32(x))
}
func (x *ExprType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ExprType_value, data, "ExprType")
	if err != nil {
		return err
	}
	*x = ExprType(value)
	return nil
}
func (ExprType) EnumDescriptor() ([]byte, []int) { return fileDescriptorExpression, []int{1} }

type ScalarFuncSig int32

const (
	// Casting
	ScalarFuncSig_CastIntAsInt           ScalarFuncSig = 0
	ScalarFuncSig_CastIntAsReal          ScalarFuncSig = 1
	ScalarFuncSig_CastIntAsString        ScalarFuncSig = 2
	ScalarFuncSig_CastIntAsDecimal       ScalarFuncSig = 3
	ScalarFuncSig_CastIntAsTime          ScalarFuncSig = 4
	ScalarFuncSig_CastIntAsDuration      ScalarFuncSig = 5
	ScalarFuncSig_CastRealAsInt          ScalarFuncSig = 10
	ScalarFuncSig_CastRealAsReal         ScalarFuncSig = 11
	ScalarFuncSig_CastRealAsString       ScalarFuncSig = 12
	ScalarFuncSig_CastRealAsDecimal      ScalarFuncSig = 13
	ScalarFuncSig_CastRealAsTime         ScalarFuncSig = 14
	ScalarFuncSig_CastRealAsDuration     ScalarFuncSig = 15
	ScalarFuncSig_CastDecimalAsInt       ScalarFuncSig = 20
	ScalarFuncSig_CastDecimalAsReal      ScalarFuncSig = 21
	ScalarFuncSig_CastDecimalAsString    ScalarFuncSig = 22
	ScalarFuncSig_CastDecimalAsDecimal   ScalarFuncSig = 23
	ScalarFuncSig_CastDecimalAsTime      ScalarFuncSig = 24
	ScalarFuncSig_CastDecimalAsDuration  ScalarFuncSig = 25
	ScalarFuncSig_CastStringAsInt        ScalarFuncSig = 30
	ScalarFuncSig_CastStringAsReal       ScalarFuncSig = 31
	ScalarFuncSig_CastStringAsString     ScalarFuncSig = 32
	ScalarFuncSig_CastStringAsDecimal    ScalarFuncSig = 33
	ScalarFuncSig_CastStringAsTime       ScalarFuncSig = 34
	ScalarFuncSig_CastStringAsDuration   ScalarFuncSig = 35
	ScalarFuncSig_CastTimeAsInt          ScalarFuncSig = 40
	ScalarFuncSig_CastTimeAsReal         ScalarFuncSig = 41
	ScalarFuncSig_CastTimeAsString       ScalarFuncSig = 42
	ScalarFuncSig_CastTimeAsDecimal      ScalarFuncSig = 43
	ScalarFuncSig_CastTimeAsTime         ScalarFuncSig = 44
	ScalarFuncSig_CastTimeAsDuration     ScalarFuncSig = 45
	ScalarFuncSig_CastDurationAsInt      ScalarFuncSig = 50
	ScalarFuncSig_CastDurationAsReal     ScalarFuncSig = 51
	ScalarFuncSig_CastDurationAsString   ScalarFuncSig = 52
	ScalarFuncSig_CastDurationAsDecimal  ScalarFuncSig = 53
	ScalarFuncSig_CastDurationAsTime     ScalarFuncSig = 54
	ScalarFuncSig_CastDurationAsDuration ScalarFuncSig = 55
	ScalarFuncSig_LTInt                  ScalarFuncSig = 100
	ScalarFuncSig_LTReal                 ScalarFuncSig = 101
	ScalarFuncSig_LTDecimal              ScalarFuncSig = 102
	ScalarFuncSig_LTString               ScalarFuncSig = 103
	ScalarFuncSig_LTTime                 ScalarFuncSig = 104
	ScalarFuncSig_LTDuration             ScalarFuncSig = 105
	ScalarFuncSig_LTJson                 ScalarFuncSig = 106
	ScalarFuncSig_LEInt                  ScalarFuncSig = 110
	ScalarFuncSig_LEReal                 ScalarFuncSig = 111
	ScalarFuncSig_LEDecimal              ScalarFuncSig = 112
	ScalarFuncSig_LEString               ScalarFuncSig = 113
	ScalarFuncSig_LETime                 ScalarFuncSig = 114
	ScalarFuncSig_LEDuration             ScalarFuncSig = 115
	ScalarFuncSig_LEJSON                 ScalarFuncSig = 116
	ScalarFuncSig_GTInt                  ScalarFuncSig = 120
	ScalarFuncSig_GTReal                 ScalarFuncSig = 121
	ScalarFuncSig_GTDecimal              ScalarFuncSig = 122
	ScalarFuncSig_GTString               ScalarFuncSig = 123
	ScalarFuncSig_GTTime                 ScalarFuncSig = 124
	ScalarFuncSig_GTDuration             ScalarFuncSig = 125
	ScalarFuncSig_GTJson                 ScalarFuncSig = 126
	ScalarFuncSig_GEInt                  ScalarFuncSig = 130
	ScalarFuncSig_GEReal                 ScalarFuncSig = 131
	ScalarFuncSig_GEDecimal              ScalarFuncSig = 132
	ScalarFuncSig_GEString               ScalarFuncSig = 133
	ScalarFuncSig_GETime                 ScalarFuncSig = 134
	ScalarFuncSig_GEDuration             ScalarFuncSig = 135
	ScalarFuncSig_GEJson                 ScalarFuncSig = 136
	ScalarFuncSig_EQInt                  ScalarFuncSig = 140
	ScalarFuncSig_EQReal                 ScalarFuncSig = 141
	ScalarFuncSig_EQDecimal              ScalarFuncSig = 142
	ScalarFuncSig_EQString               ScalarFuncSig = 143
	ScalarFuncSig_EQTime                 ScalarFuncSig = 144
	ScalarFuncSig_EQDuration             ScalarFuncSig = 145
	ScalarFuncSig_EQJson                 ScalarFuncSig = 146
	ScalarFuncSig_NEInt                  ScalarFuncSig = 150
	ScalarFuncSig_NEReal                 ScalarFuncSig = 151
	ScalarFuncSig_NEDecimal              ScalarFuncSig = 152
	ScalarFuncSig_NEString               ScalarFuncSig = 153
	ScalarFuncSig_NETime                 ScalarFuncSig = 154
	ScalarFuncSig_NEDuration             ScalarFuncSig = 155
	ScalarFuncSig_NEJson                 ScalarFuncSig = 156
	ScalarFuncSig_NullEQInt              ScalarFuncSig = 160
	ScalarFuncSig_NullEQReal             ScalarFuncSig = 161
	ScalarFuncSig_NullEQDecimal          ScalarFuncSig = 162
	ScalarFuncSig_NullEQString           ScalarFuncSig = 163
	ScalarFuncSig_NullEQTime             ScalarFuncSig = 164
	ScalarFuncSig_NullEQDuration         ScalarFuncSig = 165
	ScalarFuncSig_NullEQJSON             ScalarFuncSig = 166
	ScalarFuncSig_PlusReal               ScalarFuncSig = 200
	ScalarFuncSig_PlusDecimal            ScalarFuncSig = 201
	ScalarFuncSig_PlusIntUnsigned        ScalarFuncSig = 202
	ScalarFuncSig_PlusInt                ScalarFuncSig = 203
	ScalarFuncSig_MinusReal              ScalarFuncSig = 204
	ScalarFuncSig_MinusDecimal           ScalarFuncSig = 205
	ScalarFuncSig_MinusIntUnsigned       ScalarFuncSig = 206
	ScalarFuncSig_MinusInt               ScalarFuncSig = 207
	ScalarFuncSig_MultiplyReal           ScalarFuncSig = 208
	ScalarFuncSig_MultiplyDecimal        ScalarFuncSig = 209
	ScalarFuncSig_MultiplyInt            ScalarFuncSig = 210
	ScalarFuncSig_MultiplyIntUnsigned    ScalarFuncSig = 211
	ScalarFuncSig_AbsInt                 ScalarFuncSig = 2101
	ScalarFuncSig_AbsUInt                ScalarFuncSig = 2102
	ScalarFuncSig_AbsReal                ScalarFuncSig = 2103
	ScalarFuncSig_AbsDecimal             ScalarFuncSig = 2104
	ScalarFuncSig_CeilIntToDec           ScalarFuncSig = 2105
	ScalarFuncSig_CeilIntToInt           ScalarFuncSig = 2106
	ScalarFuncSig_CeilDecToInt           ScalarFuncSig = 2107
	ScalarFuncSig_CeilDecToDec           ScalarFuncSig = 2108
	ScalarFuncSig_CeilReal               ScalarFuncSig = 2109
	ScalarFuncSig_FloorIntToDec          ScalarFuncSig = 2110
	ScalarFuncSig_FloorIntToInt          ScalarFuncSig = 2111
	ScalarFuncSig_FloorDecToInt          ScalarFuncSig = 2112
	ScalarFuncSig_FloorDecToDec          ScalarFuncSig = 2113
	ScalarFuncSig_FloorReal              ScalarFuncSig = 2114
	ScalarFuncSig_LogicalAnd             ScalarFuncSig = 3101
	ScalarFuncSig_LogicalOr              ScalarFuncSig = 3102
	ScalarFuncSig_LogicalXor             ScalarFuncSig = 3103
	ScalarFuncSig_UnaryNot               ScalarFuncSig = 3104
	ScalarFuncSig_RealIsTrue             ScalarFuncSig = 3105
	ScalarFuncSig_DecimalIsTrue          ScalarFuncSig = 3106
	ScalarFuncSig_IntIsFalse             ScalarFuncSig = 3107
	ScalarFuncSig_UnaryMinusInt          ScalarFuncSig = 3108
	ScalarFuncSig_UnaryMinusReal         ScalarFuncSig = 3109
	ScalarFuncSig_UnaryMinusDecimal      ScalarFuncSig = 3110
	ScalarFuncSig_DecimalIsNull          ScalarFuncSig = 3111
	ScalarFuncSig_DurationIsNull         ScalarFuncSig = 3112
	ScalarFuncSig_RealIsNull             ScalarFuncSig = 3113
	ScalarFuncSig_StringIsNull           ScalarFuncSig = 3114
	ScalarFuncSig_TimeIsNull             ScalarFuncSig = 3115
	ScalarFuncSig_IntIsNull              ScalarFuncSig = 3116
	ScalarFuncSig_IfNullInt              ScalarFuncSig = 4101
	ScalarFuncSig_IfNullReal             ScalarFuncSig = 4102
	ScalarFuncSig_IfNullDecimal          ScalarFuncSig = 4103
	ScalarFuncSig_IfNullString           ScalarFuncSig = 4104
	ScalarFuncSig_IfNullTime             ScalarFuncSig = 4105
	ScalarFuncSig_IfNullDuration         ScalarFuncSig = 4106
	ScalarFuncSig_IfInt                  ScalarFuncSig = 4107
	ScalarFuncSig_IfReal                 ScalarFuncSig = 4108
	ScalarFuncSig_IfDecimal              ScalarFuncSig = 4109
	ScalarFuncSig_IfString               ScalarFuncSig = 4110
	ScalarFuncSig_IfTime                 ScalarFuncSig = 4111
	ScalarFuncSig_IfDuration             ScalarFuncSig = 4112
)

var ScalarFuncSig_name = map[int32]string{
	0:    "CastIntAsInt",
	1:    "CastIntAsReal",
	2:    "CastIntAsString",
	3:    "CastIntAsDecimal",
	4:    "CastIntAsTime",
	5:    "CastIntAsDuration",
	10:   "CastRealAsInt",
	11:   "CastRealAsReal",
	12:   "CastRealAsString",
	13:   "CastRealAsDecimal",
	14:   "CastRealAsTime",
	15:   "CastRealAsDuration",
	20:   "CastDecimalAsInt",
	21:   "CastDecimalAsReal",
	22:   "CastDecimalAsString",
	23:   "CastDecimalAsDecimal",
	24:   "CastDecimalAsTime",
	25:   "CastDecimalAsDuration",
	30:   "CastStringAsInt",
	31:   "CastStringAsReal",
	32:   "CastStringAsString",
	33:   "CastStringAsDecimal",
	34:   "CastStringAsTime",
	35:   "CastStringAsDuration",
	40:   "CastTimeAsInt",
	41:   "CastTimeAsReal",
	42:   "CastTimeAsString",
	43:   "CastTimeAsDecimal",
	44:   "CastTimeAsTime",
	45:   "CastTimeAsDuration",
	50:   "CastDurationAsInt",
	51:   "CastDurationAsReal",
	52:   "CastDurationAsString",
	53:   "CastDurationAsDecimal",
	54:   "CastDurationAsTime",
	55:   "CastDurationAsDuration",
	100:  "LTInt",
	101:  "LTReal",
	102:  "LTDecimal",
	103:  "LTString",
	104:  "LTTime",
	105:  "LTDuration",
	106:  "LTJson",
	110:  "LEInt",
	111:  "LEReal",
	112:  "LEDecimal",
	113:  "LEString",
	114:  "LETime",
	115:  "LEDuration",
	116:  "LEJSON",
	120:  "GTInt",
	121:  "GTReal",
	122:  "GTDecimal",
	123:  "GTString",
	124:  "GTTime",
	125:  "GTDuration",
	126:  "GTJson",
	130:  "GEInt",
	131:  "GEReal",
	132:  "GEDecimal",
	133:  "GEString",
	134:  "GETime",
	135:  "GEDuration",
	136:  "GEJson",
	140:  "EQInt",
	141:  "EQReal",
	142:  "EQDecimal",
	143:  "EQString",
	144:  "EQTime",
	145:  "EQDuration",
	146:  "EQJson",
	150:  "NEInt",
	151:  "NEReal",
	152:  "NEDecimal",
	153:  "NEString",
	154:  "NETime",
	155:  "NEDuration",
	156:  "NEJson",
	160:  "NullEQInt",
	161:  "NullEQReal",
	162:  "NullEQDecimal",
	163:  "NullEQString",
	164:  "NullEQTime",
	165:  "NullEQDuration",
	166:  "NullEQJSON",
	200:  "PlusReal",
	201:  "PlusDecimal",
	202:  "PlusIntUnsigned",
	203:  "PlusInt",
	204:  "MinusReal",
	205:  "MinusDecimal",
	206:  "MinusIntUnsigned",
	207:  "MinusInt",
	208:  "MultiplyReal",
	209:  "MultiplyDecimal",
	210:  "MultiplyInt",
	211:  "MultiplyIntUnsigned",
	2101: "AbsInt",
	2102: "AbsUInt",
	2103: "AbsReal",
	2104: "AbsDecimal",
	2105: "CeilIntToDec",
	2106: "CeilIntToInt",
	2107: "CeilDecToInt",
	2108: "CeilDecToDec",
	2109: "CeilReal",
	2110: "FloorIntToDec",
	2111: "FloorIntToInt",
	2112: "FloorDecToInt",
	2113: "FloorDecToDec",
	2114: "FloorReal",
	3101: "LogicalAnd",
	3102: "LogicalOr",
	3103: "LogicalXor",
	3104: "UnaryNot",
	3105: "RealIsTrue",
	3106: "DecimalIsTrue",
	3107: "IntIsFalse",
	3108: "UnaryMinusInt",
	3109: "UnaryMinusReal",
	3110: "UnaryMinusDecimal",
	3111: "DecimalIsNull",
	3112: "DurationIsNull",
	3113: "RealIsNull",
	3114: "StringIsNull",
	3115: "TimeIsNull",
	3116: "IntIsNull",
	4101: "IfNullInt",
	4102: "IfNullReal",
	4103: "IfNullDecimal",
	4104: "IfNullString",
	4105: "IfNullTime",
	4106: "IfNullDuration",
	4107: "IfInt",
	4108: "IfReal",
	4109: "IfDecimal",
	4110: "IfString",
	4111: "IfTime",
	4112: "IfDuration",
}
var ScalarFuncSig_value = map[string]int32{
	"CastIntAsInt":           0,
	"CastIntAsReal":          1,
	"CastIntAsString":        2,
	"CastIntAsDecimal":       3,
	"CastIntAsTime":          4,
	"CastIntAsDuration":      5,
	"CastRealAsInt":          10,
	"CastRealAsReal":         11,
	"CastRealAsString":       12,
	"CastRealAsDecimal":      13,
	"CastRealAsTime":         14,
	"CastRealAsDuration":     15,
	"CastDecimalAsInt":       20,
	"CastDecimalAsReal":      21,
	"CastDecimalAsString":    22,
	"CastDecimalAsDecimal":   23,
	"CastDecimalAsTime":      24,
	"CastDecimalAsDuration":  25,
	"CastStringAsInt":        30,
	"CastStringAsReal":       31,
	"CastStringAsString":     32,
	"CastStringAsDecimal":    33,
	"CastStringAsTime":       34,
	"CastStringAsDuration":   35,
	"CastTimeAsInt":          40,
	"CastTimeAsReal":         41,
	"CastTimeAsString":       42,
	"CastTimeAsDecimal":      43,
	"CastTimeAsTime":         44,
	"CastTimeAsDuration":     45,
	"CastDurationAsInt":      50,
	"CastDurationAsReal":     51,
	"CastDurationAsString":   52,
	"CastDurationAsDecimal":  53,
	"CastDurationAsTime":     54,
	"CastDurationAsDuration": 55,
	"LTInt":                  100,
	"LTReal":                 101,
	"LTDecimal":              102,
	"LTString":               103,
	"LTTime":                 104,
	"LTDuration":             105,
	"LTJson":                 106,
	"LEInt":                  110,
	"LEReal":                 111,
	"LEDecimal":              112,
	"LEString":               113,
	"LETime":                 114,
	"LEDuration":             115,
	"LEJSON":                 116,
	"GTInt":                  120,
	"GTReal":                 121,
	"GTDecimal":              122,
	"GTString":               123,
	"GTTime":                 124,
	"GTDuration":             125,
	"GTJson":                 126,
	"GEInt":                  130,
	"GEReal":                 131,
	"GEDecimal":              132,
	"GEString":               133,
	"GETime":                 134,
	"GEDuration":             135,
	"GEJson":                 136,
	"EQInt":                  140,
	"EQReal":                 141,
	"EQDecimal":              142,
	"EQString":               143,
	"EQTime":                 144,
	"EQDuration":             145,
	"EQJson":                 146,
	"NEInt":                  150,
	"NEReal":                 151,
	"NEDecimal":              152,
	"NEString":               153,
	"NETime":                 154,
	"NEDuration":             155,
	"NEJson":                 156,
	"NullEQInt":              160,
	"NullEQReal":             161,
	"NullEQDecimal":          162,
	"NullEQString":           163,
	"NullEQTime":             164,
	"NullEQDuration":         165,
	"NullEQJSON":             166,
	"PlusReal":               200,
	"PlusDecimal":            201,
	"PlusIntUnsigned":        202,
	"PlusInt":                203,
	"MinusReal":              204,
	"MinusDecimal":           205,
	"MinusIntUnsigned":       206,
	"MinusInt":               207,
	"MultiplyReal":           208,
	"MultiplyDecimal":        209,
	"MultiplyInt":            210,
	"MultiplyIntUnsigned":    211,
	"AbsInt":                 2101,
	"AbsUInt":                2102,
	"AbsReal":                2103,
	"AbsDecimal":             2104,
	"CeilIntToDec":           2105,
	"CeilIntToInt":           2106,
	"CeilDecToInt":           2107,
	"CeilDecToDec":           2108,
	"CeilReal":               2109,
	"FloorIntToDec":          2110,
	"FloorIntToInt":          2111,
	"FloorDecToInt":          2112,
	"FloorDecToDec":          2113,
	"FloorReal":              2114,
	"LogicalAnd":             3101,
	"LogicalOr":              3102,
	"LogicalXor":             3103,
	"UnaryNot":               3104,
	"RealIsTrue":             3105,
	"DecimalIsTrue":          3106,
	"IntIsFalse":             3107,
	"UnaryMinusInt":          3108,
	"UnaryMinusReal":         3109,
	"UnaryMinusDecimal":      3110,
	"DecimalIsNull":          3111,
	"DurationIsNull":         3112,
	"RealIsNull":             3113,
	"StringIsNull":           3114,
	"TimeIsNull":             3115,
	"IntIsNull":              3116,
	"IfNullInt":              4101,
	"IfNullReal":             4102,
	"IfNullDecimal":          4103,
	"IfNullString":           4104,
	"IfNullTime":             4105,
	"IfNullDuration":         4106,
	"IfInt":                  4107,
	"IfReal":                 4108,
	"IfDecimal":              4109,
	"IfString":               4110,
	"IfTime":                 4111,
	"IfDuration":             4112,
}

func (x ScalarFuncSig) Enum() *ScalarFuncSig {
	p := new(ScalarFuncSig)
	*p = x
	return p
}
func (x ScalarFuncSig) String() string {
	return proto.EnumName(ScalarFuncSig_name, int32(x))
}
func (x *ScalarFuncSig) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ScalarFuncSig_value, data, "ScalarFuncSig")
	if err != nil {
		return err
	}
	*x = ScalarFuncSig(value)
	return nil
}
func (ScalarFuncSig) EnumDescriptor() ([]byte, []int) { return fileDescriptorExpression, []int{2} }

type FieldType struct {
	Tp               DataType `protobuf:"varint,1,opt,name=tp,enum=tipb.DataType" json:"tp"`
	Flag             *uint32  `protobuf:"varint,2,opt,name=flag" json:"flag,omitempty"`
	Flen             *int32   `protobuf:"varint,3,opt,name=flen" json:"flen,omitempty"`
	Decimal          *int32   `protobuf:"varint,4,opt,name=decimal" json:"decimal,omitempty"`
	Charset          *string  `protobuf:"bytes,5,opt,name=charset" json:"charset,omitempty"`
	Collate          *string  `protobuf:"bytes,6,opt,name=collate" json:"collate,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *FieldType) Reset()                    { *m = FieldType{} }
func (m *FieldType) String() string            { return proto.CompactTextString(m) }
func (*FieldType) ProtoMessage()               {}
func (*FieldType) Descriptor() ([]byte, []int) { return fileDescriptorExpression, []int{0} }

func (m *FieldType) GetTp() DataType {
	if m != nil {
		return m.Tp
	}
	return DataType_TypeDecimal
}

func (m *FieldType) GetFlag() uint32 {
	if m != nil && m.Flag != nil {
		return *m.Flag
	}
	return 0
}

func (m *FieldType) GetFlen() int32 {
	if m != nil && m.Flen != nil {
		return *m.Flen
	}
	return 0
}

func (m *FieldType) GetDecimal() int32 {
	if m != nil && m.Decimal != nil {
		return *m.Decimal
	}
	return 0
}

func (m *FieldType) GetCharset() string {
	if m != nil && m.Charset != nil {
		return *m.Charset
	}
	return ""
}

func (m *FieldType) GetCollate() string {
	if m != nil && m.Collate != nil {
		return *m.Collate
	}
	return ""
}

// Evaluators should implement evaluation functions for every expression type.
type Expr struct {
	Tp               ExprType       `protobuf:"varint,1,opt,name=tp,enum=tipb.ExprType" json:"tp"`
	Val              []byte         `protobuf:"bytes,2,opt,name=val" json:"val,omitempty"`
	Children         []*Expr        `protobuf:"bytes,3,rep,name=children" json:"children,omitempty"`
	Sig              *ScalarFuncSig `protobuf:"varint,4,opt,name=sig,enum=tipb.ScalarFuncSig" json:"sig,omitempty"`
	FieldType        *FieldType     `protobuf:"bytes,5,opt,name=field_type,json=fieldType" json:"field_type,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *Expr) Reset()                    { *m = Expr{} }
func (m *Expr) String() string            { return proto.CompactTextString(m) }
func (*Expr) ProtoMessage()               {}
func (*Expr) Descriptor() ([]byte, []int) { return fileDescriptorExpression, []int{1} }

func (m *Expr) GetTp() ExprType {
	if m != nil {
		return m.Tp
	}
	return ExprType_Null
}

func (m *Expr) GetVal() []byte {
	if m != nil {
		return m.Val
	}
	return nil
}

func (m *Expr) GetChildren() []*Expr {
	if m != nil {
		return m.Children
	}
	return nil
}

func (m *Expr) GetSig() ScalarFuncSig {
	if m != nil && m.Sig != nil {
		return *m.Sig
	}
	return ScalarFuncSig_CastIntAsInt
}

func (m *Expr) GetFieldType() *FieldType {
	if m != nil {
		return m.FieldType
	}
	return nil
}

// ByItem type for group by and order by.
type ByItem struct {
	Expr             *Expr  `protobuf:"bytes,1,opt,name=expr" json:"expr,omitempty"`
	Desc             bool   `protobuf:"varint,2,opt,name=desc" json:"desc"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ByItem) Reset()                    { *m = ByItem{} }
func (m *ByItem) String() string            { return proto.CompactTextString(m) }
func (*ByItem) ProtoMessage()               {}
func (*ByItem) Descriptor() ([]byte, []int) { return fileDescriptorExpression, []int{2} }

func (m *ByItem) GetExpr() *Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *ByItem) GetDesc() bool {
	if m != nil {
		return m.Desc
	}
	return false
}

func init() {
	proto.RegisterType((*FieldType)(nil), "tipb.FieldType")
	proto.RegisterType((*Expr)(nil), "tipb.Expr")
	proto.RegisterType((*ByItem)(nil), "tipb.ByItem")
	proto.RegisterEnum("tipb.DataType", DataType_name, DataType_value)
	proto.RegisterEnum("tipb.ExprType", ExprType_name, ExprType_value)
	proto.RegisterEnum("tipb.ScalarFuncSig", ScalarFuncSig_name, ScalarFuncSig_value)
}
func (m *FieldType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FieldType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintExpression(dAtA, i, uint64(m.Tp))
	if m.Flag != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintExpression(dAtA, i, uint64(*m.Flag))
	}
	if m.Flen != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintExpression(dAtA, i, uint64(*m.Flen))
	}
	if m.Decimal != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintExpression(dAtA, i, uint64(*m.Decimal))
	}
	if m.Charset != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintExpression(dAtA, i, uint64(len(*m.Charset)))
		i += copy(dAtA[i:], *m.Charset)
	}
	if m.Collate != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintExpression(dAtA, i, uint64(len(*m.Collate)))
		i += copy(dAtA[i:], *m.Collate)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Expr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Expr) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintExpression(dAtA, i, uint64(m.Tp))
	if m.Val != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintExpression(dAtA, i, uint64(len(m.Val)))
		i += copy(dAtA[i:], m.Val)
	}
	if len(m.Children) > 0 {
		for _, msg := range m.Children {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintExpression(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Sig != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintExpression(dAtA, i, uint64(*m.Sig))
	}
	if m.FieldType != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintExpression(dAtA, i, uint64(m.FieldType.Size()))
		n1, err := m.FieldType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ByItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ByItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Expr != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintExpression(dAtA, i, uint64(m.Expr.Size()))
		n2, err := m.Expr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	dAtA[i] = 0x10
	i++
	if m.Desc {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeFixed64Expression(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Expression(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintExpression(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *FieldType) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovExpression(uint64(m.Tp))
	if m.Flag != nil {
		n += 1 + sovExpression(uint64(*m.Flag))
	}
	if m.Flen != nil {
		n += 1 + sovExpression(uint64(*m.Flen))
	}
	if m.Decimal != nil {
		n += 1 + sovExpression(uint64(*m.Decimal))
	}
	if m.Charset != nil {
		l = len(*m.Charset)
		n += 1 + l + sovExpression(uint64(l))
	}
	if m.Collate != nil {
		l = len(*m.Collate)
		n += 1 + l + sovExpression(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Expr) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovExpression(uint64(m.Tp))
	if m.Val != nil {
		l = len(m.Val)
		n += 1 + l + sovExpression(uint64(l))
	}
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovExpression(uint64(l))
		}
	}
	if m.Sig != nil {
		n += 1 + sovExpression(uint64(*m.Sig))
	}
	if m.FieldType != nil {
		l = m.FieldType.Size()
		n += 1 + l + sovExpression(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ByItem) Size() (n int) {
	var l int
	_ = l
	if m.Expr != nil {
		l = m.Expr.Size()
		n += 1 + l + sovExpression(uint64(l))
	}
	n += 2
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovExpression(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozExpression(x uint64) (n int) {
	return sovExpression(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FieldType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExpression
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FieldType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FieldType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tp", wireType)
			}
			m.Tp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tp |= (DataType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Flag = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flen", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Flen = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decimal", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Decimal = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Charset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Charset = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Collate = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExpression(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Expr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExpression
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Expr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Expr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tp", wireType)
			}
			m.Tp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tp |= (ExprType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Val = append(m.Val[:0], dAtA[iNdEx:postIndex]...)
			if m.Val == nil {
				m.Val = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &Expr{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sig", wireType)
			}
			var v ScalarFuncSig
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (ScalarFuncSig(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sig = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FieldType == nil {
				m.FieldType = &FieldType{}
			}
			if err := m.FieldType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExpression(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ByItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExpression
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ByItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ByItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Desc = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipExpression(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipExpression(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowExpression
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthExpression
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowExpression
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipExpression(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthExpression = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowExpression   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("expression.proto", fileDescriptorExpression) }

var fileDescriptorExpression = []byte{
	// 2397 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x58, 0x69, 0x90, 0x1b, 0x47,
	0x15, 0xf6, 0xec, 0x6a, 0xaf, 0xde, 0xeb, 0x6d, 0xfb, 0xd2, 0xca, 0x5b, 0xbb, 0xc2, 0x1c, 0xb5,
	0x31, 0xb0, 0x54, 0x6d, 0x8c, 0xf9, 0xbd, 0x87, 0x56, 0x51, 0x4a, 0xab, 0xf5, 0x4a, 0x5a, 0x07,
	0x7e, 0x51, 0x23, 0xa9, 0x25, 0x8d, 0x3d, 0x9a, 0x91, 0x67, 0x5a, 0xf6, 0x8a, 0xab, 0x8a, 0x24,
	0x3e, 0x92, 0xf8, 0x4a, 0x80, 0xc4, 0x67, 0x12, 0xdf, 0xdc, 0xfc, 0xca, 0x1d, 0x27, 0x40, 0x15,
	0x55, 0x76, 0xc2, 0x91, 0xc4, 0x01, 0x8a, 0x1f, 0x50, 0x94, 0x29, 0x08, 0x81, 0x5f, 0x1c, 0xe1,
	0x4a, 0xe2, 0x50, 0xef, 0xf5, 0xf4, 0x68, 0xd7, 0xc9, 0x2f, 0xf7, 0xfb, 0xfa, 0xbd, 0xef, 0xfb,
	0xfa, 0x75, 0x4f, 0x6f, 0xcb, 0x0c, 0xc4, 0x72, 0xdd, 0x13, 0xbe, 0x6f, 0xb9, 0xce, 0x44, 0xdd,
	0x73, 0xa5, 0xcb, 0x23, 0xd2, 0xaa, 0x17, 0x62, 0xeb, 0x2a, 0x6e, 0xc5, 0x25, 0xe0, 0x53, 0x38,
	0x52, 0x73, 0x9b, 0x2f, 0x1b, 0xac, 0x67, 0xce, 0x12, 0x76, 0x29, 0xdf, 0xac, 0x0b, 0xfe, 0x11,
	0xd6, 0x26, 0xeb, 0x51, 0x23, 0x6e, 0x8c, 0x0f, 0x4c, 0x0e, 0x4c, 0x60, 0xd9, 0xc4, 0xac, 0x29,
	0x4d, 0x9c, 0x9b, 0x8e, 0x5c, 0xfd, 0xdd, 0xd8, 0x9a, 0x6c, 0x9b, 0xac, 0x73, 0xce, 0x22, 0x65,
	0xdb, 0xac, 0x44, 0xdb, 0xe2, 0xc6, 0x78, 0x7f, 0x96, 0xc6, 0x0a, 0x13, 0x4e, 0xb4, 0x3d, 0x6e,
	0x8c, 0x77, 0x64, 0x69, 0xcc, 0xa3, 0xac, 0xab, 0x24, 0x8a, 0x56, 0xcd, 0xb4, 0xa3, 0x11, 0x82,
	0x75, 0x88, 0x33, 0xc5, 0xaa, 0xe9, 0xf9, 0x42, 0x46, 0x3b, 0xe2, 0xc6, 0x78, 0x4f, 0x56, 0x87,
	0x34, 0xe3, 0xda, 0xb6, 0x29, 0x45, 0xb4, 0x33, 0x98, 0x51, 0xe1, 0xe6, 0x2b, 0x06, 0x8b, 0x24,
	0x96, 0xeb, 0xde, 0x07, 0x99, 0x44, 0xfc, 0x16, 0x93, 0xc0, 0xda, 0xf7, 0x98, 0x36, 0x79, 0xec,
	0xcb, 0xe2, 0x90, 0x7f, 0x8c, 0x75, 0x17, 0xab, 0x96, 0x5d, 0xf2, 0xc8, 0x66, 0xfb, 0x78, 0xef,
	0x24, 0x6b, 0x55, 0x67, 0xc3, 0x39, 0xfe, 0x51, 0xd6, 0xee, 0x5b, 0x15, 0xb2, 0x3c, 0x30, 0xb9,
	0x56, 0xa5, 0xe4, 0x8a, 0xa6, 0x6d, 0x7a, 0x73, 0x0d, 0xa7, 0x98, 0xb3, 0x2a, 0x59, 0x9c, 0xe7,
	0x13, 0x8c, 0x95, 0xb1, 0x71, 0x9f, 0x97, 0xcd, 0xba, 0xa0, 0x65, 0xf4, 0x4e, 0x0e, 0xaa, 0xec,
	0xb0, 0xa1, 0xd9, 0x9e, 0xb2, 0x1e, 0x6e, 0x9e, 0x66, 0x9d, 0xd3, 0xcd, 0x94, 0x14, 0x35, 0x3e,
	0xca, 0x22, 0xb8, 0x47, 0xb4, 0x84, 0xd5, 0x26, 0x08, 0xe7, 0x51, 0x16, 0x29, 0x09, 0xbf, 0x48,
	0xde, 0xbb, 0x83, 0x25, 0x11, 0xb2, 0xe5, 0x37, 0xed, 0xac, 0x5b, 0x6f, 0x08, 0x1f, 0x64, 0xbd,
	0xf8, 0xef, 0xac, 0xea, 0x29, 0xac, 0xe1, 0x7d, 0xac, 0x1b, 0x81, 0xbc, 0xe5, 0x34, 0xc1, 0xe0,
	0xfd, 0xac, 0x07, 0xa3, 0x5c, 0xd5, 0xf5, 0x24, 0xb4, 0xe9, 0xc9, 0xb4, 0xeb, 0x54, 0xa0, 0x5d,
	0x4f, 0xce, 0xd9, 0xae, 0x29, 0x21, 0xc2, 0x07, 0x18, 0x23, 0x2a, 0xb7, 0x51, 0xb0, 0x05, 0x74,
	0xe8, 0xe4, 0x4c, 0xc3, 0xb6, 0xa1, 0x93, 0x0f, 0xb1, 0x7e, 0xc5, 0x5b, 0x13, 0xbe, 0x34, 0x6b,
	0x75, 0xe8, 0xe2, 0xc0, 0xfa, 0x34, 0x1b, 0x31, 0x76, 0x6b, 0xc6, 0x94, 0x23, 0x27, 0xb7, 0x42,
	0x8f, 0x66, 0x98, 0x35, 0xa5, 0x00, 0xa6, 0xd3, 0x67, 0x1b, 0x9e, 0x29, 0x2d, 0xd7, 0x81, 0xde,
	0x10, 0x31, 0xa5, 0x90, 0x56, 0x4d, 0x40, 0x9f, 0xae, 0xf8, 0x9c, 0x30, 0x3d, 0xe8, 0xd7, 0x8b,
	0xcb, 0x88, 0xbd, 0x44, 0x31, 0xa0, 0x81, 0x1d, 0xa6, 0x87, 0x47, 0x05, 0x06, 0x79, 0x2f, 0xeb,
	0xa2, 0x2d, 0xb7, 0x24, 0x00, 0xef, 0x57, 0xc5, 0x77, 0xe6, 0x16, 0x32, 0xf0, 0x96, 0xc1, 0xd7,
	0xb2, 0x01, 0x5d, 0x1d, 0x74, 0xe7, 0x5f, 0x86, 0xce, 0x49, 0x38, 0x8d, 0x1a, 0xfc, 0xdb, 0xe0,
	0x7d, 0xaa, 0x3e, 0x27, 0x24, 0xfc, 0xc7, 0xe0, 0x43, 0xca, 0x0f, 0xf6, 0x6e, 0xda, 0x76, 0x0b,
	0xf0, 0xdf, 0x90, 0x64, 0x5e, 0x94, 0xac, 0x46, 0x8d, 0xc0, 0xff, 0x85, 0x79, 0xb8, 0x68, 0x82,
	0xde, 0x0e, 0x79, 0x29, 0x7c, 0xc7, 0xe0, 0x5c, 0x75, 0x6b, 0x87, 0xe9, 0xe5, 0xa4, 0x67, 0x39,
	0x15, 0x78, 0xd7, 0xe0, 0x83, 0xaa, 0xbf, 0x01, 0x70, 0x33, 0xa4, 0x49, 0x0a, 0xb7, 0x26, 0xa4,
	0xd7, 0x84, 0xf7, 0x8c, 0x2d, 0x3f, 0xe9, 0x65, 0xdd, 0xfa, 0x1c, 0xf3, 0x6e, 0x16, 0xa1, 0xe6,
	0xaf, 0xe1, 0x3d, 0xac, 0x23, 0xe5, 0xc8, 0x6d, 0x5b, 0xc1, 0xe0, 0x8c, 0x75, 0x2e, 0x59, 0x34,
	0x6e, 0xc3, 0xd5, 0xd3, 0xe6, 0xdd, 0x3e, 0x09, 0xed, 0x61, 0xb0, 0x6d, 0x2b, 0x44, 0x30, 0x2b,
	0xd0, 0xe9, 0xc0, 0xe2, 0xe9, 0xa6, 0x14, 0x3e, 0x74, 0x62, 0x7b, 0xe7, 0x9b, 0xfe, 0x6e, 0x1b,
	0xfb, 0x25, 0xb0, 0xfd, 0x14, 0xe9, 0xf6, 0x94, 0x71, 0x93, 0x15, 0xa2, 0xf7, 0xa8, 0x82, 0x5b,
	0x4a, 0x10, 0x75, 0xac, 0x1a, 0x32, 0xdc, 0x21, 0x96, 0xc1, 0x0a, 0x23, 0xec, 0xdf, 0xce, 0x30,
	0x15, 0xcf, 0x08, 0xec, 0xe2, 0x03, 0xac, 0x67, 0x87, 0x69, 0x37, 0x44, 0xda, 0xf2, 0x25, 0x3c,
	0x62, 0x60, 0x3c, 0xe3, 0xda, 0x8d, 0x9a, 0x93, 0x15, 0x65, 0xb8, 0x66, 0xf0, 0x6e, 0xd6, 0x9e,
	0x71, 0x25, 0xbc, 0xd9, 0x45, 0x23, 0x51, 0x81, 0xbf, 0x74, 0xf1, 0x5e, 0xd6, 0x39, 0x6d, 0x49,
	0x0c, 0xfe, 0xda, 0xc5, 0xbb, 0x58, 0x5b, 0x3a, 0x0f, 0xaf, 0x0e, 0xd2, 0x20, 0x01, 0xaf, 0xd1,
	0x20, 0xb1, 0x08, 0xd7, 0x69, 0x90, 0x49, 0xc0, 0xeb, 0x34, 0x48, 0x26, 0xe0, 0x97, 0x6a, 0x90,
	0x87, 0x5f, 0xe1, 0x91, 0xe8, 0xc4, 0xae, 0x25, 0x16, 0xe1, 0xd7, 0x83, 0x01, 0xdf, 0x94, 0x53,
	0x82, 0x27, 0x80, 0x33, 0xd6, 0x31, 0x6d, 0xc9, 0x05, 0x0f, 0x9e, 0x84, 0x60, 0xe2, 0xb3, 0xae,
	0x07, 0x4f, 0x01, 0x3a, 0x4b, 0x8b, 0xb2, 0xcc, 0x55, 0xad, 0xb2, 0x84, 0xa7, 0x29, 0xce, 0x5a,
	0x95, 0xaa, 0x8a, 0x9f, 0x01, 0xde, 0xc3, 0x22, 0xdb, 0xed, 0x86, 0x0f, 0x27, 0x86, 0x90, 0x63,
	0xde, 0x72, 0x1a, 0x3e, 0x9c, 0x1c, 0x42, 0xdb, 0xf3, 0x0d, 0x1b, 0x4e, 0xd1, 0x68, 0xd6, 0xda,
	0x03, 0xa7, 0x87, 0x90, 0x37, 0xe5, 0x48, 0x0c, 0xce, 0xa8, 0x04, 0xb7, 0x04, 0x8f, 0xd2, 0x08,
	0x4d, 0xbc, 0x3b, 0x84, 0x3e, 0x17, 0x3c, 0xb8, 0x49, 0x10, 0xca, 0xbf, 0x47, 0x9c, 0x33, 0x6e,
	0xc3, 0x91, 0xf0, 0xcc, 0x46, 0x44, 0x73, 0x8d, 0x1a, 0x3c, 0x4b, 0xa3, 0xa9, 0x3d, 0x15, 0x78,
	0x8e, 0x46, 0xf3, 0x96, 0x03, 0xcf, 0xab, 0x91, 0xb9, 0x0c, 0x57, 0x36, 0x62, 0xcd, 0x9c, 0xe5,
	0xf9, 0x12, 0x5e, 0xd8, 0xc8, 0x81, 0xf5, 0x26, 0x3d, 0xb7, 0x51, 0x9f, 0x71, 0x9d, 0xa2, 0x29,
	0xe1, 0x45, 0x55, 0x5b, 0xf0, 0xe1, 0x4c, 0x14, 0x47, 0xdb, 0xdd, 0xbd, 0xf0, 0x68, 0x14, 0x2b,
	0xb2, 0x6e, 0xc3, 0x29, 0xc1, 0x63, 0x51, 0x74, 0x19, 0x24, 0x7f, 0x75, 0x18, 0x8f, 0xae, 0x0a,
	0xee, 0xca, 0xc1, 0xdd, 0xc3, 0xb8, 0x58, 0x6c, 0x06, 0xdc, 0x33, 0x8c, 0x69, 0x69, 0xe1, 0x54,
	0x64, 0x15, 0xee, 0x1d, 0xc6, 0xfa, 0xb4, 0xbb, 0x57, 0x78, 0xb0, 0x8f, 0x26, 0xb2, 0xa2, 0x2e,
	0x4c, 0x09, 0xfb, 0x87, 0xf1, 0x1b, 0xca, 0x8a, 0xba, 0x6d, 0x16, 0x05, 0x1c, 0xa0, 0xb4, 0xa5,
	0x7a, 0x5d, 0x78, 0x70, 0x90, 0xd2, 0x72, 0xd2, 0x2b, 0xd6, 0xea, 0x70, 0x1f, 0xa5, 0xcd, 0xb8,
	0xce, 0x1e, 0xe1, 0x49, 0xb8, 0x9f, 0x54, 0x66, 0x4c, 0x5f, 0xc2, 0x03, 0xc3, 0xd8, 0xed, 0x5c,
	0xa3, 0xe0, 0xab, 0xe3, 0x7a, 0x68, 0x18, 0x3f, 0xb9, 0x30, 0x4e, 0x39, 0x25, 0xb1, 0x0c, 0x87,
	0x95, 0x15, 0xb7, 0x88, 0xb7, 0xc0, 0x11, 0x2a, 0xce, 0x7b, 0x56, 0x0d, 0x8e, 0x0e, 0x63, 0x3b,
	0x53, 0x65, 0xf8, 0xe3, 0xb0, 0xde, 0xf6, 0x54, 0x19, 0xfe, 0x44, 0x41, 0xaa, 0x4c, 0xdf, 0xce,
	0x1b, 0x94, 0x4d, 0xd7, 0xc7, 0xb5, 0x18, 0x7a, 0xc0, 0xe1, 0x54, 0xa9, 0x04, 0x2f, 0x85, 0x51,
	0xae, 0x51, 0x80, 0x97, 0x63, 0x98, 0x46, 0xd7, 0xce, 0xf5, 0x18, 0x76, 0x04, 0x87, 0x77, 0x09,
	0xb1, 0x0b, 0x5e, 0x8f, 0xd1, 0x9e, 0xbb, 0x8e, 0xac, 0xc2, 0x6f, 0x29, 0x8b, 0xe0, 0x37, 0xa8,
	0x1c, 0x87, 0x25, 0xb3, 0x09, 0x7f, 0x8e, 0xe1, 0xd7, 0x8d, 0xd1, 0x42, 0x99, 0x48, 0xde, 0x8c,
	0xd1, 0x99, 0x30, 0x9b, 0xf0, 0xb7, 0x40, 0xa7, 0x99, 0x31, 0x6b, 0x02, 0xfe, 0x1e, 0xc3, 0xe5,
	0xce, 0x9a, 0xcd, 0x20, 0xef, 0x1f, 0x54, 0x48, 0xb1, 0x92, 0xf8, 0x67, 0x2b, 0x81, 0x74, 0xde,
	0x22, 0xc9, 0x3b, 0xdc, 0x86, 0x07, 0x6f, 0xc7, 0x70, 0x5d, 0x78, 0xfa, 0xa4, 0x80, 0x77, 0x28,
	0xc8, 0x89, 0xa2, 0x8b, 0xc7, 0x2a, 0x86, 0x67, 0x60, 0xde, 0x2a, 0x7a, 0xae, 0xaf, 0x90, 0x9b,
	0xa4, 0x9a, 0x58, 0x96, 0x9e, 0x59, 0x94, 0xb0, 0x6f, 0x93, 0xda, 0x64, 0xd3, 0x16, 0x7e, 0x51,
	0xc0, 0xf7, 0x28, 0x4c, 0x7a, 0xc2, 0x94, 0xc2, 0x97, 0xf0, 0xfd, 0x4d, 0xb4, 0xb7, 0x02, 0xb7,
	0xe3, 0x07, 0x9b, 0x90, 0xe9, 0x4e, 0xdf, 0x75, 0x74, 0xed, 0x83, 0x23, 0x98, 0x8c, 0x08, 0xde,
	0x49, 0xf0, 0xd0, 0x08, 0xfa, 0xc3, 0x70, 0xca, 0xf3, 0xcc, 0x26, 0x7c, 0x6d, 0x04, 0x17, 0x80,
	0xf1, 0x42, 0x61, 0xa7, 0x28, 0x4a, 0xf8, 0x7a, 0x98, 0x30, 0x2f, 0xbc, 0x8a, 0x80, 0x6f, 0x84,
	0xf1, 0x0e, 0xd3, 0xb6, 0x4a, 0xf0, 0xf0, 0x08, 0x3a, 0xc3, 0x18, 0x2f, 0x8d, 0x47, 0xc2, 0xf2,
	0x94, 0xe3, 0xe3, 0xd1, 0x38, 0x3e, 0xa2, 0x0d, 0xe8, 0x33, 0x75, 0x22, 0x4c, 0xc9, 0x8a, 0x9a,
	0xbb, 0x47, 0xc0, 0xc9, 0x11, 0xbc, 0x39, 0x11, 0x98, 0x71, 0x1d, 0x69, 0x5a, 0x8e, 0x0f, 0xa7,
	0xc2, 0xaa, 0x25, 0x67, 0x77, 0xc3, 0x95, 0x02, 0x4e, 0x8f, 0xf0, 0xf5, 0x0c, 0x56, 0x26, 0x6d,
	0x37, 0x65, 0x15, 0xce, 0x8c, 0xd0, 0x89, 0x71, 0xe0, 0xec, 0x18, 0xda, 0x48, 0xf9, 0x79, 0xaf,
	0x21, 0xab, 0x70, 0x6e, 0x8c, 0x8e, 0x8c, 0x4f, 0x47, 0xe6, 0xfc, 0x98, 0xea, 0x5d, 0xdd, 0xcb,
	0xba, 0x7b, 0xe1, 0xc2, 0x18, 0x7d, 0x11, 0xd6, 0x2e, 0x01, 0x17, 0xc7, 0xe8, 0x23, 0xa2, 0xf1,
	0xa5, 0xb1, 0xe0, 0x08, 0x0b, 0xb8, 0x3c, 0x86, 0x06, 0x5b, 0x8f, 0x03, 0x38, 0x96, 0xd9, 0x72,
	0x65, 0x2d, 0xeb, 0x5f, 0xf5, 0x5c, 0xc0, 0xcb, 0x16, 0x0f, 0x7c, 0xca, 0x91, 0x53, 0x7e, 0xca,
	0x91, 0xb0, 0x06, 0x2f, 0xdb, 0x10, 0xc9, 0x0a, 0xd3, 0x06, 0xfc, 0x6b, 0x33, 0x18, 0x42, 0xc1,
	0xfd, 0xdd, 0xc6, 0xd7, 0x31, 0x08, 0x41, 0x7d, 0x55, 0xb7, 0xaf, 0xaa, 0xa6, 0x0b, 0x37, 0xc2,
	0xd7, 0xb3, 0xa1, 0x56, 0xa2, 0xbe, 0xc1, 0x3b, 0x74, 0x26, 0x4a, 0x28, 0x69, 0xc6, 0x39, 0x1b,
	0x68, 0x41, 0xa4, 0xdd, 0xab, 0x65, 0x14, 0x16, 0x88, 0xf7, 0x69, 0x4e, 0x85, 0x6a, 0xf5, 0xfe,
	0xd5, 0x04, 0x24, 0x3f, 0xc0, 0x37, 0x30, 0xbe, 0x22, 0x55, 0xeb, 0x0f, 0x6a, 0xe2, 0xa0, 0x58,
	0x59, 0x58, 0xa7, 0x89, 0x43, 0x94, 0x5c, 0xac, 0xe7, 0x1b, 0xd9, 0xda, 0x55, 0x70, 0x60, 0x64,
	0x03, 0x8f, 0xb2, 0x75, 0xab, 0x26, 0xb4, 0x97, 0x8d, 0xef, 0x63, 0x22, 0x3b, 0x51, 0x3e, 0xcc,
	0xd6, 0xaf, 0x2e, 0xd0, 0x8e, 0x86, 0x75, 0x9b, 0x15, 0xb7, 0x32, 0x34, 0xaa, 0x6d, 0x6a, 0x90,
	0xfc, 0x8c, 0xe9, 0x45, 0x69, 0x34, 0xb0, 0x13, 0xd7, 0x3e, 0x35, 0xae, 0xdd, 0x7c, 0xe8, 0x56,
	0x1a, 0x32, 0xb3, 0x59, 0xbb, 0x0f, 0xd3, 0xb5, 0x97, 0x0f, 0xeb, 0xdd, 0xc1, 0x3c, 0xe5, 0x64,
	0x5c, 0x37, 0x57, 0x41, 0xe4, 0xe3, 0x36, 0x4d, 0xab, 0xb0, 0xc0, 0xc5, 0x16, 0xbd, 0x74, 0x85,
	0x6a, 0x0f, 0x1f, 0x5f, 0x4d, 0x40, 0x0e, 0x3e, 0xa1, 0x17, 0x12, 0xa4, 0x6a, 0xfd, 0x4f, 0x86,
	0xdd, 0x0b, 0x10, 0xe5, 0x61, 0x52, 0xa7, 0xb7, 0x60, 0xf2, 0x71, 0x7b, 0xb8, 0x0d, 0x21, 0x1e,
	0x78, 0xd9, 0x1a, 0xf6, 0x3b, 0x9c, 0xd1, 0x7e, 0x3e, 0xfd, 0x7e, 0x32, 0xf2, 0xb4, 0x8d, 0xc7,
	0xd8, 0x86, 0x5b, 0x4a, 0xb4, 0xaf, 0xcf, 0xe0, 0xab, 0x25, 0x9d, 0x47, 0x2f, 0x25, 0x7c, 0xcc,
	0xa4, 0xf3, 0xa4, 0x2f, 0xf0, 0x8d, 0x91, 0xce, 0xb7, 0x1e, 0x2c, 0x7d, 0xac, 0x3b, 0x9d, 0x0f,
	0x2c, 0x54, 0x54, 0x22, 0x71, 0x57, 0xf1, 0x35, 0x9b, 0xce, 0x87, 0x7c, 0x96, 0x9a, 0xc3, 0xfb,
	0x00, 0x76, 0x12, 0x77, 0x02, 0xb9, 0x1d, 0x82, 0x13, 0xc4, 0xed, 0x12, 0x77, 0x42, 0x73, 0xd7,
	0x89, 0x3b, 0x11, 0x70, 0xef, 0x56, 0x89, 0xc4, 0xed, 0x11, 0x77, 0x22, 0xe4, 0xf6, 0xd5, 0x1c,
	0x3d, 0x3b, 0x25, 0x72, 0x27, 0xc9, 0xf7, 0x32, 0xc2, 0x49, 0xe5, 0xbb, 0x89, 0xdc, 0xc9, 0xd0,
	0xf7, 0x17, 0x90, 0x3b, 0xa9, 0x7d, 0x7f, 0x51, 0x25, 0x12, 0xf7, 0x97, 0x90, 0x3b, 0xd9, 0xf2,
	0xfd, 0x65, 0x35, 0x47, 0xbe, 0xbf, 0x82, 0xb7, 0x4f, 0x92, 0x7c, 0xdf, 0x6d, 0xe0, 0x7d, 0x95,
	0x54, 0xc6, 0xef, 0xa1, 0xa7, 0x55, 0x32, 0x74, 0x7e, 0x2f, 0xbd, 0x46, 0x93, 0xda, 0xfa, 0xbe,
	0x20, 0x97, 0xf8, 0xf7, 0xd3, 0x33, 0x34, 0xd9, 0x32, 0x7f, 0x20, 0x98, 0x25, 0x85, 0x83, 0xf8,
	0xbc, 0xec, 0x48, 0x2c, 0xa2, 0xc4, 0x21, 0x9a, 0x48, 0x2c, 0x92, 0xc4, 0x61, 0x92, 0x48, 0x2c,
	0x6a, 0x89, 0x23, 0x24, 0x91, 0x58, 0x0c, 0x24, 0x8e, 0x06, 0xb9, 0x24, 0x71, 0x8c, 0x24, 0x12,
	0x8b, 0xa1, 0xc4, 0x83, 0xc1, 0x2c, 0x49, 0x3c, 0x44, 0x12, 0x19, 0x5a, 0xc5, 0xc3, 0x34, 0x91,
	0x51, 0xab, 0x50, 0x0f, 0xc4, 0x4c, 0xb8, 0x8a, 0xe3, 0x24, 0x91, 0xd1, 0xab, 0x38, 0x11, 0xe4,
	0x92, 0xc4, 0x49, 0x92, 0xc8, 0xb4, 0x56, 0x71, 0x2a, 0x98, 0x25, 0x89, 0xd3, 0x8a, 0x89, 0xde,
	0x80, 0x28, 0xf3, 0xb8, 0xca, 0xa6, 0x98, 0xa4, 0xce, 0xd2, 0xfb, 0x5c, 0x01, 0x5a, 0xee, 0x1c,
	0x3d, 0xc7, 0x15, 0x16, 0x48, 0x9e, 0x5f, 0x51, 0x47, 0xb2, 0x17, 0xe8, 0xe7, 0x40, 0x50, 0xa7,
	0xa5, 0x2f, 0xae, 0xc8, 0xa2, 0x23, 0x70, 0x89, 0x8c, 0xe3, 0x7b, 0x91, 0xc4, 0xae, 0x1a, 0xf8,
	0xa7, 0x09, 0x43, 0x2d, 0x75, 0xcd, 0xe0, 0xeb, 0xd8, 0x20, 0x22, 0x29, 0x47, 0x2e, 0x39, 0xbe,
	0x55, 0x71, 0x44, 0x09, 0x5e, 0xa2, 0x1f, 0x23, 0x01, 0x0a, 0x2f, 0xd3, 0x1a, 0xe8, 0xa5, 0x49,
	0x2c, 0x3f, 0x25, 0x7b, 0x14, 0x6b, 0x9a, 0x9f, 0x19, 0xf8, 0x17, 0x8e, 0xa0, 0x95, 0x3c, 0x3f,
	0x27, 0x79, 0x0d, 0xc3, 0x2f, 0x54, 0x61, 0xc3, 0x96, 0x56, 0xdd, 0x6e, 0x12, 0xd7, 0x2b, 0xa4,
	0xaf, 0x21, 0x4d, 0xf7, 0x2a, 0xf9, 0xd4, 0x28, 0x96, 0xbe, 0x66, 0xf0, 0x28, 0x5b, 0xbb, 0x02,
	0x09, 0x35, 0xae, 0x53, 0xbb, 0xa7, 0x0a, 0xa4, 0xf0, 0x04, 0xa0, 0xf1, 0xa9, 0x82, 0xbf, 0x84,
	0xd1, 0x93, 0x3a, 0x22, 0xa9, 0xa7, 0x00, 0x9b, 0x33, 0x55, 0x08, 0x4d, 0x3f, 0x0d, 0x68, 0x67,
	0x46, 0x58, 0x76, 0xca, 0x91, 0x79, 0x77, 0x56, 0x14, 0xf1, 0x7d, 0xbd, 0x12, 0x42, 0x92, 0x67,
	0x43, 0x68, 0x56, 0x14, 0x15, 0xf4, 0xdc, 0x6a, 0x08, 0x0b, 0x9f, 0xa7, 0x5f, 0x7c, 0x08, 0x91,
	0xd6, 0x15, 0xc0, 0x5d, 0x9d, 0xb3, 0x5d, 0xd7, 0x0b, 0xb9, 0x5f, 0xb8, 0x05, 0x43, 0xa6, 0x17,
	0x5b, 0x58, 0xc8, 0xfe, 0xc3, 0x5b, 0x30, 0xac, 0xfd, 0x11, 0xfd, 0x0e, 0x20, 0x8c, 0xf8, 0x7f,
	0x4c, 0x6b, 0x49, 0xbb, 0x15, 0xab, 0x68, 0xda, 0xf8, 0x98, 0x3f, 0x13, 0xa5, 0x1f, 0x0e, 0x0a,
	0x58, 0xf0, 0xf0, 0x8d, 0xdd, 0x4a, 0xc0, 0xa7, 0xfd, 0x63, 0x51, 0x34, 0xb8, 0xe4, 0x98, 0x5e,
	0x13, 0x7f, 0xe8, 0x3c, 0x4e, 0xf3, 0xc8, 0x45, 0xcf, 0x0e, 0x01, 0x67, 0xa3, 0xa8, 0x1a, 0xb4,
	0x26, 0xc0, 0xce, 0x51, 0x52, 0xca, 0x91, 0x29, 0x7f, 0xce, 0xb4, 0x7d, 0x01, 0xe7, 0x29, 0x89,
	0x48, 0xc2, 0x4d, 0xbd, 0x10, 0xc5, 0x83, 0xd8, 0xc2, 0xc8, 0xdf, 0xc5, 0x28, 0xdf, 0xc0, 0x86,
	0x5a, 0xa0, 0x6e, 0xf9, 0xa5, 0xd5, 0x2a, 0xf4, 0xc4, 0xb9, 0x4c, 0x04, 0xfa, 0x0c, 0x07, 0xe0,
	0x37, 0x57, 0xf8, 0x23, 0xe0, 0x5b, 0x51, 0xec, 0xb9, 0xfa, 0x1a, 0x02, 0xe8, 0xdb, 0x94, 0x83,
	0x5f, 0x43, 0x00, 0x7c, 0x87, 0x9a, 0x40, 0x7e, 0x29, 0xfe, 0xae, 0x8a, 0xe9, 0xf1, 0x8d, 0x56,
	0xf7, 0xc5, 0x69, 0x3d, 0x14, 0x93, 0xcd, 0xfd, 0x71, 0xb4, 0xa3, 0x00, 0x6d, 0xf1, 0x40, 0x1c,
	0x85, 0x14, 0x16, 0x7c, 0x7c, 0x07, 0x57, 0xd4, 0xd1, 0xc7, 0x77, 0x5f, 0x1c, 0x2d, 0x07, 0x75,
	0xfa, 0xe3, 0xbb, 0x3f, 0x8e, 0xb7, 0x49, 0xaa, 0x8c, 0x4a, 0x0f, 0xc4, 0xd5, 0xb3, 0x9f, 0x54,
	0x0e, 0xc5, 0x95, 0x0d, 0xad, 0x70, 0x38, 0x8e, 0x5b, 0x91, 0x2a, 0x07, 0xec, 0x47, 0x82, 0x5c,
	0x62, 0x3e, 0x1a, 0x48, 0x85, 0xac, 0xc7, 0xe2, 0xd3, 0xb7, 0x5d, 0xbd, 0x31, 0x6a, 0xbc, 0x72,
	0x63, 0xd4, 0xf8, 0xfd, 0x8d, 0x51, 0xe3, 0xf8, 0x1f, 0x46, 0xd7, 0xb0, 0xf5, 0x45, 0xb7, 0x36,
	0x51, 0xb7, 0x9c, 0x4a, 0xd1, 0xac, 0x4f, 0x48, 0xab, 0x54, 0xa0, 0xff, 0xb1, 0xd9, 0x6e, 0xfc,
	0x3f, 0x00, 0x00, 0xff, 0xff, 0xfa, 0x77, 0x84, 0x54, 0x6b, 0x13, 0x00, 0x00,
}
