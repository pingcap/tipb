// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: executor.proto

package tipb

import (
	"fmt"

	proto "github.com/golang/protobuf/proto"

	math "math"

	io "io"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type ExecType int32

const (
	ExecType_TypeTableScan          ExecType = 0
	ExecType_TypeIndexScan          ExecType = 1
	ExecType_TypeSelection          ExecType = 2
	ExecType_TypeAggregation        ExecType = 3
	ExecType_TypeTopN               ExecType = 4
	ExecType_TypeLimit              ExecType = 5
	ExecType_TypeStreamAgg          ExecType = 6
	ExecType_TypeJoin               ExecType = 7
	ExecType_TypeKill               ExecType = 8
	ExecType_TypeExchangeSender     ExecType = 9
	ExecType_TypeExchangeReceiver   ExecType = 10
	ExecType_TypeProjection         ExecType = 11
	ExecType_TypePartitionTableScan ExecType = 12
	ExecType_TypeSort               ExecType = 13
	ExecType_TypeWindow             ExecType = 14
	ExecType_TypeExpand             ExecType = 15
)

var ExecType_name = map[int32]string{
	0:  "TypeTableScan",
	1:  "TypeIndexScan",
	2:  "TypeSelection",
	3:  "TypeAggregation",
	4:  "TypeTopN",
	5:  "TypeLimit",
	6:  "TypeStreamAgg",
	7:  "TypeJoin",
	8:  "TypeKill",
	9:  "TypeExchangeSender",
	10: "TypeExchangeReceiver",
	11: "TypeProjection",
	12: "TypePartitionTableScan",
	13: "TypeSort",
	14: "TypeWindow",
	15: "TypeExpand",
}
var ExecType_value = map[string]int32{
	"TypeTableScan":          0,
	"TypeIndexScan":          1,
	"TypeSelection":          2,
	"TypeAggregation":        3,
	"TypeTopN":               4,
	"TypeLimit":              5,
	"TypeStreamAgg":          6,
	"TypeJoin":               7,
	"TypeKill":               8,
	"TypeExchangeSender":     9,
	"TypeExchangeReceiver":   10,
	"TypeProjection":         11,
	"TypePartitionTableScan": 12,
	"TypeSort":               13,
	"TypeWindow":             14,
	"TypeExpand":             15,
}

func (x ExecType) Enum() *ExecType {
	p := new(ExecType)
	*p = x
	return p
}
func (x ExecType) String() string {
	return proto.EnumName(ExecType_name, int32(x))
}
func (x *ExecType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ExecType_value, data, "ExecType")
	if err != nil {
		return err
	}
	*x = ExecType(value)
	return nil
}
func (ExecType) EnumDescriptor() ([]byte, []int) { return fileDescriptorExecutor, []int{0} }

type ExchangeType int32

const (
	ExchangeType_PassThrough ExchangeType = 0
	ExchangeType_Broadcast   ExchangeType = 1
	ExchangeType_Hash        ExchangeType = 2
)

var ExchangeType_name = map[int32]string{
	0: "PassThrough",
	1: "Broadcast",
	2: "Hash",
}
var ExchangeType_value = map[string]int32{
	"PassThrough": 0,
	"Broadcast":   1,
	"Hash":        2,
}

func (x ExchangeType) Enum() *ExchangeType {
	p := new(ExchangeType)
	*p = x
	return p
}
func (x ExchangeType) String() string {
	return proto.EnumName(ExchangeType_name, int32(x))
}
func (x *ExchangeType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ExchangeType_value, data, "ExchangeType")
	if err != nil {
		return err
	}
	*x = ExchangeType(value)
	return nil
}
func (ExchangeType) EnumDescriptor() ([]byte, []int) { return fileDescriptorExecutor, []int{1} }

// Data compression mode
type CompressionMode int32

const (
	CompressionMode_NONE             CompressionMode = 0
	CompressionMode_FAST             CompressionMode = 1
	CompressionMode_HIGH_COMPRESSION CompressionMode = 2
)

var CompressionMode_name = map[int32]string{
	0: "NONE",
	1: "FAST",
	2: "HIGH_COMPRESSION",
}
var CompressionMode_value = map[string]int32{
	"NONE":             0,
	"FAST":             1,
	"HIGH_COMPRESSION": 2,
}

func (x CompressionMode) Enum() *CompressionMode {
	p := new(CompressionMode)
	*p = x
	return p
}
func (x CompressionMode) String() string {
	return proto.EnumName(CompressionMode_name, int32(x))
}
func (x *CompressionMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CompressionMode_value, data, "CompressionMode")
	if err != nil {
		return err
	}
	*x = CompressionMode(value)
	return nil
}
func (CompressionMode) EnumDescriptor() ([]byte, []int) { return fileDescriptorExecutor, []int{2} }

type EngineType int32

const (
	EngineType_Local   EngineType = 0
	EngineType_TiKV    EngineType = 1
	EngineType_TiFlash EngineType = 2
)

var EngineType_name = map[int32]string{
	0: "Local",
	1: "TiKV",
	2: "TiFlash",
}
var EngineType_value = map[string]int32{
	"Local":   0,
	"TiKV":    1,
	"TiFlash": 2,
}

func (x EngineType) Enum() *EngineType {
	p := new(EngineType)
	*p = x
	return p
}
func (x EngineType) String() string {
	return proto.EnumName(EngineType_name, int32(x))
}
func (x *EngineType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EngineType_value, data, "EngineType")
	if err != nil {
		return err
	}
	*x = EngineType(value)
	return nil
}
func (EngineType) EnumDescriptor() ([]byte, []int) { return fileDescriptorExecutor, []int{3} }

type JoinType int32

const (
	JoinType_TypeInnerJoin             JoinType = 0
	JoinType_TypeLeftOuterJoin         JoinType = 1
	JoinType_TypeRightOuterJoin        JoinType = 2
	JoinType_TypeSemiJoin              JoinType = 3
	JoinType_TypeAntiSemiJoin          JoinType = 4
	JoinType_TypeLeftOuterSemiJoin     JoinType = 5
	JoinType_TypeAntiLeftOuterSemiJoin JoinType = 6
)

var JoinType_name = map[int32]string{
	0: "TypeInnerJoin",
	1: "TypeLeftOuterJoin",
	2: "TypeRightOuterJoin",
	3: "TypeSemiJoin",
	4: "TypeAntiSemiJoin",
	5: "TypeLeftOuterSemiJoin",
	6: "TypeAntiLeftOuterSemiJoin",
}
var JoinType_value = map[string]int32{
	"TypeInnerJoin":             0,
	"TypeLeftOuterJoin":         1,
	"TypeRightOuterJoin":        2,
	"TypeSemiJoin":              3,
	"TypeAntiSemiJoin":          4,
	"TypeLeftOuterSemiJoin":     5,
	"TypeAntiLeftOuterSemiJoin": 6,
}

func (x JoinType) Enum() *JoinType {
	p := new(JoinType)
	*p = x
	return p
}
func (x JoinType) String() string {
	return proto.EnumName(JoinType_name, int32(x))
}
func (x *JoinType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(JoinType_value, data, "JoinType")
	if err != nil {
		return err
	}
	*x = JoinType(value)
	return nil
}
func (JoinType) EnumDescriptor() ([]byte, []int) { return fileDescriptorExecutor, []int{4} }

type JoinExecType int32

const (
	JoinExecType_TypeHashJoin JoinExecType = 0
)

var JoinExecType_name = map[int32]string{
	0: "TypeHashJoin",
}
var JoinExecType_value = map[string]int32{
	"TypeHashJoin": 0,
}

func (x JoinExecType) Enum() *JoinExecType {
	p := new(JoinExecType)
	*p = x
	return p
}
func (x JoinExecType) String() string {
	return proto.EnumName(JoinExecType_name, int32(x))
}
func (x *JoinExecType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(JoinExecType_value, data, "JoinExecType")
	if err != nil {
		return err
	}
	*x = JoinExecType(value)
	return nil
}
func (JoinExecType) EnumDescriptor() ([]byte, []int) { return fileDescriptorExecutor, []int{5} }

type WindowBoundType int32

const (
	WindowBoundType_Following  WindowBoundType = 0
	WindowBoundType_Preceding  WindowBoundType = 1
	WindowBoundType_CurrentRow WindowBoundType = 2
)

var WindowBoundType_name = map[int32]string{
	0: "Following",
	1: "Preceding",
	2: "CurrentRow",
}
var WindowBoundType_value = map[string]int32{
	"Following":  0,
	"Preceding":  1,
	"CurrentRow": 2,
}

func (x WindowBoundType) Enum() *WindowBoundType {
	p := new(WindowBoundType)
	*p = x
	return p
}
func (x WindowBoundType) String() string {
	return proto.EnumName(WindowBoundType_name, int32(x))
}
func (x *WindowBoundType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(WindowBoundType_value, data, "WindowBoundType")
	if err != nil {
		return err
	}
	*x = WindowBoundType(value)
	return nil
}
func (WindowBoundType) EnumDescriptor() ([]byte, []int) { return fileDescriptorExecutor, []int{6} }

type WindowFrameType int32

const (
	WindowFrameType_Rows   WindowFrameType = 0
	WindowFrameType_Ranges WindowFrameType = 1
	WindowFrameType_Groups WindowFrameType = 2
)

var WindowFrameType_name = map[int32]string{
	0: "Rows",
	1: "Ranges",
	2: "Groups",
}
var WindowFrameType_value = map[string]int32{
	"Rows":   0,
	"Ranges": 1,
	"Groups": 2,
}

func (x WindowFrameType) Enum() *WindowFrameType {
	p := new(WindowFrameType)
	*p = x
	return p
}
func (x WindowFrameType) String() string {
	return proto.EnumName(WindowFrameType_name, int32(x))
}
func (x *WindowFrameType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(WindowFrameType_value, data, "WindowFrameType")
	if err != nil {
		return err
	}
	*x = WindowFrameType(value)
	return nil
}
func (WindowFrameType) EnumDescriptor() ([]byte, []int) { return fileDescriptorExecutor, []int{7} }

// It represents a Executor.
type Executor struct {
	Tp                            ExecType            `protobuf:"varint,1,opt,name=tp,enum=tipb.ExecType" json:"tp"`
	TblScan                       *TableScan          `protobuf:"bytes,2,opt,name=tbl_scan,json=tblScan" json:"tbl_scan,omitempty"`
	IdxScan                       *IndexScan          `protobuf:"bytes,3,opt,name=idx_scan,json=idxScan" json:"idx_scan,omitempty"`
	Selection                     *Selection          `protobuf:"bytes,4,opt,name=selection" json:"selection,omitempty"`
	Aggregation                   *Aggregation        `protobuf:"bytes,5,opt,name=aggregation" json:"aggregation,omitempty"`
	TopN                          *TopN               `protobuf:"bytes,6,opt,name=topN" json:"topN,omitempty"`
	Limit                         *Limit              `protobuf:"bytes,7,opt,name=limit" json:"limit,omitempty"`
	ExchangeReceiver              *ExchangeReceiver   `protobuf:"bytes,8,opt,name=exchange_receiver,json=exchangeReceiver" json:"exchange_receiver,omitempty"`
	Join                          *Join               `protobuf:"bytes,9,opt,name=join" json:"join,omitempty"`
	ExecutorId                    *string             `protobuf:"bytes,10,opt,name=executor_id,json=executorId" json:"executor_id,omitempty"`
	Kill                          *Kill               `protobuf:"bytes,11,opt,name=kill" json:"kill,omitempty"`
	ExchangeSender                *ExchangeSender     `protobuf:"bytes,12,opt,name=exchange_sender,json=exchangeSender" json:"exchange_sender,omitempty"`
	Projection                    *Projection         `protobuf:"bytes,13,opt,name=Projection" json:"Projection,omitempty"`
	PartitionTableScan            *PartitionTableScan `protobuf:"bytes,14,opt,name=partition_table_scan,json=partitionTableScan" json:"partition_table_scan,omitempty"`
	Sort                          *Sort               `protobuf:"bytes,15,opt,name=sort" json:"sort,omitempty"`
	Window                        *Window             `protobuf:"bytes,16,opt,name=window" json:"window,omitempty"`
	FineGrainedShuffleStreamCount uint64              `protobuf:"varint,17,opt,name=fine_grained_shuffle_stream_count,json=fineGrainedShuffleStreamCount" json:"fine_grained_shuffle_stream_count"`
	FineGrainedShuffleBatchSize   uint64              `protobuf:"varint,18,opt,name=fine_grained_shuffle_batch_size,json=fineGrainedShuffleBatchSize" json:"fine_grained_shuffle_batch_size"`
	Expand                        *Expand             `protobuf:"bytes,19,opt,name=expand" json:"expand,omitempty"`
	XXX_unrecognized              []byte              `json:"-"`
}

func (m *Executor) Reset()                    { *m = Executor{} }
func (m *Executor) String() string            { return proto.CompactTextString(m) }
func (*Executor) ProtoMessage()               {}
func (*Executor) Descriptor() ([]byte, []int) { return fileDescriptorExecutor, []int{0} }

func (m *Executor) GetTp() ExecType {
	if m != nil {
		return m.Tp
	}
	return ExecType_TypeTableScan
}

func (m *Executor) GetTblScan() *TableScan {
	if m != nil {
		return m.TblScan
	}
	return nil
}

func (m *Executor) GetIdxScan() *IndexScan {
	if m != nil {
		return m.IdxScan
	}
	return nil
}

func (m *Executor) GetSelection() *Selection {
	if m != nil {
		return m.Selection
	}
	return nil
}

func (m *Executor) GetAggregation() *Aggregation {
	if m != nil {
		return m.Aggregation
	}
	return nil
}

func (m *Executor) GetTopN() *TopN {
	if m != nil {
		return m.TopN
	}
	return nil
}

func (m *Executor) GetLimit() *Limit {
	if m != nil {
		return m.Limit
	}
	return nil
}

func (m *Executor) GetExchangeReceiver() *ExchangeReceiver {
	if m != nil {
		return m.ExchangeReceiver
	}
	return nil
}

func (m *Executor) GetJoin() *Join {
	if m != nil {
		return m.Join
	}
	return nil
}

func (m *Executor) GetExecutorId() string {
	if m != nil && m.ExecutorId != nil {
		return *m.ExecutorId
	}
	return ""
}

func (m *Executor) GetKill() *Kill {
	if m != nil {
		return m.Kill
	}
	return nil
}

func (m *Executor) GetExchangeSender() *ExchangeSender {
	if m != nil {
		return m.ExchangeSender
	}
	return nil
}

func (m *Executor) GetProjection() *Projection {
	if m != nil {
		return m.Projection
	}
	return nil
}

func (m *Executor) GetPartitionTableScan() *PartitionTableScan {
	if m != nil {
		return m.PartitionTableScan
	}
	return nil
}

func (m *Executor) GetSort() *Sort {
	if m != nil {
		return m.Sort
	}
	return nil
}

func (m *Executor) GetWindow() *Window {
	if m != nil {
		return m.Window
	}
	return nil
}

func (m *Executor) GetFineGrainedShuffleStreamCount() uint64 {
	if m != nil {
		return m.FineGrainedShuffleStreamCount
	}
	return 0
}

func (m *Executor) GetFineGrainedShuffleBatchSize() uint64 {
	if m != nil {
		return m.FineGrainedShuffleBatchSize
	}
	return 0
}

func (m *Executor) GetExpand() *Expand {
	if m != nil {
		return m.Expand
	}
	return nil
}

// ExchangeSender will build connection with ExchangeReceiver.
type ExchangeSender struct {
	Tp               ExchangeType    `protobuf:"varint,1,opt,name=tp,enum=tipb.ExchangeType" json:"tp"`
	EncodedTaskMeta  [][]byte        `protobuf:"bytes,2,rep,name=encoded_task_meta,json=encodedTaskMeta" json:"encoded_task_meta,omitempty"`
	PartitionKeys    []*Expr         `protobuf:"bytes,3,rep,name=partition_keys,json=partitionKeys" json:"partition_keys,omitempty"`
	Child            *Executor       `protobuf:"bytes,4,opt,name=child" json:"child,omitempty"`
	Types            []*FieldType    `protobuf:"bytes,5,rep,name=types" json:"types,omitempty"`
	AllFieldTypes    []*FieldType    `protobuf:"bytes,6,rep,name=all_field_types,json=allFieldTypes" json:"all_field_types,omitempty"`
	Compression      CompressionMode `protobuf:"varint,7,opt,name=compression,enum=tipb.CompressionMode" json:"compression"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *ExchangeSender) Reset()                    { *m = ExchangeSender{} }
func (m *ExchangeSender) String() string            { return proto.CompactTextString(m) }
func (*ExchangeSender) ProtoMessage()               {}
func (*ExchangeSender) Descriptor() ([]byte, []int) { return fileDescriptorExecutor, []int{1} }

func (m *ExchangeSender) GetTp() ExchangeType {
	if m != nil {
		return m.Tp
	}
	return ExchangeType_PassThrough
}

func (m *ExchangeSender) GetEncodedTaskMeta() [][]byte {
	if m != nil {
		return m.EncodedTaskMeta
	}
	return nil
}

func (m *ExchangeSender) GetPartitionKeys() []*Expr {
	if m != nil {
		return m.PartitionKeys
	}
	return nil
}

func (m *ExchangeSender) GetChild() *Executor {
	if m != nil {
		return m.Child
	}
	return nil
}

func (m *ExchangeSender) GetTypes() []*FieldType {
	if m != nil {
		return m.Types
	}
	return nil
}

func (m *ExchangeSender) GetAllFieldTypes() []*FieldType {
	if m != nil {
		return m.AllFieldTypes
	}
	return nil
}

func (m *ExchangeSender) GetCompression() CompressionMode {
	if m != nil {
		return m.Compression
	}
	return CompressionMode_NONE
}

// ExchangeReceiver accept connection and receiver data from ExchangeSender.
type ExchangeReceiver struct {
	EncodedTaskMeta  [][]byte      `protobuf:"bytes,1,rep,name=encoded_task_meta,json=encodedTaskMeta" json:"encoded_task_meta,omitempty"`
	FieldTypes       []*FieldType  `protobuf:"bytes,2,rep,name=field_types,json=fieldTypes" json:"field_types,omitempty"`
	Tp               *ExchangeType `protobuf:"varint,3,opt,name=tp,enum=tipb.ExchangeType" json:"tp,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *ExchangeReceiver) Reset()                    { *m = ExchangeReceiver{} }
func (m *ExchangeReceiver) String() string            { return proto.CompactTextString(m) }
func (*ExchangeReceiver) ProtoMessage()               {}
func (*ExchangeReceiver) Descriptor() ([]byte, []int) { return fileDescriptorExecutor, []int{2} }

func (m *ExchangeReceiver) GetEncodedTaskMeta() [][]byte {
	if m != nil {
		return m.EncodedTaskMeta
	}
	return nil
}

func (m *ExchangeReceiver) GetFieldTypes() []*FieldType {
	if m != nil {
		return m.FieldTypes
	}
	return nil
}

func (m *ExchangeReceiver) GetTp() ExchangeType {
	if m != nil && m.Tp != nil {
		return *m.Tp
	}
	return ExchangeType_PassThrough
}

type TableScan struct {
	TableId                    int64         `protobuf:"varint,1,opt,name=table_id,json=tableId" json:"table_id"`
	Columns                    []*ColumnInfo `protobuf:"bytes,2,rep,name=columns" json:"columns,omitempty"`
	Desc                       bool          `protobuf:"varint,3,opt,name=desc" json:"desc"`
	PrimaryColumnIds           []int64       `protobuf:"varint,4,rep,name=primary_column_ids,json=primaryColumnIds" json:"primary_column_ids,omitempty"`
	NextReadEngine             EngineType    `protobuf:"varint,5,opt,name=next_read_engine,json=nextReadEngine,enum=tipb.EngineType" json:"next_read_engine"`
	Ranges                     []KeyRange    `protobuf:"bytes,6,rep,name=ranges" json:"ranges"`
	PrimaryPrefixColumnIds     []int64       `protobuf:"varint,7,rep,name=primary_prefix_column_ids,json=primaryPrefixColumnIds" json:"primary_prefix_column_ids,omitempty"`
	KeepOrder                  *bool         `protobuf:"varint,8,opt,name=keep_order,json=keepOrder" json:"keep_order,omitempty"`
	IsFastScan                 *bool         `protobuf:"varint,9,opt,name=is_fast_scan,json=isFastScan" json:"is_fast_scan,omitempty"`
	PushedDownFilterConditions []*Expr       `protobuf:"bytes,10,rep,name=pushed_down_filter_conditions,json=pushedDownFilterConditions" json:"pushed_down_filter_conditions,omitempty"`
	XXX_unrecognized           []byte        `json:"-"`
}

func (m *TableScan) Reset()                    { *m = TableScan{} }
func (m *TableScan) String() string            { return proto.CompactTextString(m) }
func (*TableScan) ProtoMessage()               {}
func (*TableScan) Descriptor() ([]byte, []int) { return fileDescriptorExecutor, []int{3} }

func (m *TableScan) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *TableScan) GetColumns() []*ColumnInfo {
	if m != nil {
		return m.Columns
	}
	return nil
}

func (m *TableScan) GetDesc() bool {
	if m != nil {
		return m.Desc
	}
	return false
}

func (m *TableScan) GetPrimaryColumnIds() []int64 {
	if m != nil {
		return m.PrimaryColumnIds
	}
	return nil
}

func (m *TableScan) GetNextReadEngine() EngineType {
	if m != nil {
		return m.NextReadEngine
	}
	return EngineType_Local
}

func (m *TableScan) GetRanges() []KeyRange {
	if m != nil {
		return m.Ranges
	}
	return nil
}

func (m *TableScan) GetPrimaryPrefixColumnIds() []int64 {
	if m != nil {
		return m.PrimaryPrefixColumnIds
	}
	return nil
}

func (m *TableScan) GetKeepOrder() bool {
	if m != nil && m.KeepOrder != nil {
		return *m.KeepOrder
	}
	return false
}

func (m *TableScan) GetIsFastScan() bool {
	if m != nil && m.IsFastScan != nil {
		return *m.IsFastScan
	}
	return false
}

func (m *TableScan) GetPushedDownFilterConditions() []*Expr {
	if m != nil {
		return m.PushedDownFilterConditions
	}
	return nil
}

type PartitionTableScan struct {
	TableId                    int64         `protobuf:"varint,1,opt,name=table_id,json=tableId" json:"table_id"`
	Columns                    []*ColumnInfo `protobuf:"bytes,2,rep,name=columns" json:"columns,omitempty"`
	Desc                       bool          `protobuf:"varint,3,opt,name=desc" json:"desc"`
	PrimaryColumnIds           []int64       `protobuf:"varint,4,rep,name=primary_column_ids,json=primaryColumnIds" json:"primary_column_ids,omitempty"`
	PrimaryPrefixColumnIds     []int64       `protobuf:"varint,5,rep,name=primary_prefix_column_ids,json=primaryPrefixColumnIds" json:"primary_prefix_column_ids,omitempty"`
	PartitionIds               []int64       `protobuf:"varint,6,rep,name=partition_ids,json=partitionIds" json:"partition_ids,omitempty"`
	IsFastScan                 *bool         `protobuf:"varint,7,opt,name=is_fast_scan,json=isFastScan" json:"is_fast_scan,omitempty"`
	PushedDownFilterConditions []*Expr       `protobuf:"bytes,8,rep,name=pushed_down_filter_conditions,json=pushedDownFilterConditions" json:"pushed_down_filter_conditions,omitempty"`
	XXX_unrecognized           []byte        `json:"-"`
}

func (m *PartitionTableScan) Reset()                    { *m = PartitionTableScan{} }
func (m *PartitionTableScan) String() string            { return proto.CompactTextString(m) }
func (*PartitionTableScan) ProtoMessage()               {}
func (*PartitionTableScan) Descriptor() ([]byte, []int) { return fileDescriptorExecutor, []int{4} }

func (m *PartitionTableScan) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *PartitionTableScan) GetColumns() []*ColumnInfo {
	if m != nil {
		return m.Columns
	}
	return nil
}

func (m *PartitionTableScan) GetDesc() bool {
	if m != nil {
		return m.Desc
	}
	return false
}

func (m *PartitionTableScan) GetPrimaryColumnIds() []int64 {
	if m != nil {
		return m.PrimaryColumnIds
	}
	return nil
}

func (m *PartitionTableScan) GetPrimaryPrefixColumnIds() []int64 {
	if m != nil {
		return m.PrimaryPrefixColumnIds
	}
	return nil
}

func (m *PartitionTableScan) GetPartitionIds() []int64 {
	if m != nil {
		return m.PartitionIds
	}
	return nil
}

func (m *PartitionTableScan) GetIsFastScan() bool {
	if m != nil && m.IsFastScan != nil {
		return *m.IsFastScan
	}
	return false
}

func (m *PartitionTableScan) GetPushedDownFilterConditions() []*Expr {
	if m != nil {
		return m.PushedDownFilterConditions
	}
	return nil
}

type Join struct {
	JoinType      JoinType     `protobuf:"varint,1,opt,name=join_type,json=joinType,enum=tipb.JoinType" json:"join_type"`
	JoinExecType  JoinExecType `protobuf:"varint,2,opt,name=join_exec_type,json=joinExecType,enum=tipb.JoinExecType" json:"join_exec_type"`
	Children      []*Executor  `protobuf:"bytes,3,rep,name=children" json:"children,omitempty"`
	InnerIdx      int64        `protobuf:"varint,4,opt,name=inner_idx,json=innerIdx" json:"inner_idx"`
	LeftJoinKeys  []*Expr      `protobuf:"bytes,5,rep,name=left_join_keys,json=leftJoinKeys" json:"left_join_keys,omitempty"`
	RightJoinKeys []*Expr      `protobuf:"bytes,6,rep,name=right_join_keys,json=rightJoinKeys" json:"right_join_keys,omitempty"`
	// used by TiFlash join when new collation is enabled.
	ProbeTypes              []*FieldType `protobuf:"bytes,7,rep,name=probe_types,json=probeTypes" json:"probe_types,omitempty"`
	BuildTypes              []*FieldType `protobuf:"bytes,8,rep,name=build_types,json=buildTypes" json:"build_types,omitempty"`
	LeftConditions          []*Expr      `protobuf:"bytes,9,rep,name=left_conditions,json=leftConditions" json:"left_conditions,omitempty"`
	RightConditions         []*Expr      `protobuf:"bytes,10,rep,name=right_conditions,json=rightConditions" json:"right_conditions,omitempty"`
	OtherConditions         []*Expr      `protobuf:"bytes,11,rep,name=other_conditions,json=otherConditions" json:"other_conditions,omitempty"`
	OtherEqConditionsFromIn []*Expr      `protobuf:"bytes,12,rep,name=other_eq_conditions_from_in,json=otherEqConditionsFromIn" json:"other_eq_conditions_from_in,omitempty"`
	IsNullAwareSemiJoin     *bool        `protobuf:"varint,13,opt,name=is_null_aware_semi_join,json=isNullAwareSemiJoin" json:"is_null_aware_semi_join,omitempty"`
	XXX_unrecognized        []byte       `json:"-"`
}

func (m *Join) Reset()                    { *m = Join{} }
func (m *Join) String() string            { return proto.CompactTextString(m) }
func (*Join) ProtoMessage()               {}
func (*Join) Descriptor() ([]byte, []int) { return fileDescriptorExecutor, []int{5} }

func (m *Join) GetJoinType() JoinType {
	if m != nil {
		return m.JoinType
	}
	return JoinType_TypeInnerJoin
}

func (m *Join) GetJoinExecType() JoinExecType {
	if m != nil {
		return m.JoinExecType
	}
	return JoinExecType_TypeHashJoin
}

func (m *Join) GetChildren() []*Executor {
	if m != nil {
		return m.Children
	}
	return nil
}

func (m *Join) GetInnerIdx() int64 {
	if m != nil {
		return m.InnerIdx
	}
	return 0
}

func (m *Join) GetLeftJoinKeys() []*Expr {
	if m != nil {
		return m.LeftJoinKeys
	}
	return nil
}

func (m *Join) GetRightJoinKeys() []*Expr {
	if m != nil {
		return m.RightJoinKeys
	}
	return nil
}

func (m *Join) GetProbeTypes() []*FieldType {
	if m != nil {
		return m.ProbeTypes
	}
	return nil
}

func (m *Join) GetBuildTypes() []*FieldType {
	if m != nil {
		return m.BuildTypes
	}
	return nil
}

func (m *Join) GetLeftConditions() []*Expr {
	if m != nil {
		return m.LeftConditions
	}
	return nil
}

func (m *Join) GetRightConditions() []*Expr {
	if m != nil {
		return m.RightConditions
	}
	return nil
}

func (m *Join) GetOtherConditions() []*Expr {
	if m != nil {
		return m.OtherConditions
	}
	return nil
}

func (m *Join) GetOtherEqConditionsFromIn() []*Expr {
	if m != nil {
		return m.OtherEqConditionsFromIn
	}
	return nil
}

func (m *Join) GetIsNullAwareSemiJoin() bool {
	if m != nil && m.IsNullAwareSemiJoin != nil {
		return *m.IsNullAwareSemiJoin
	}
	return false
}

type IndexScan struct {
	TableId          int64         `protobuf:"varint,1,opt,name=table_id,json=tableId" json:"table_id"`
	IndexId          int64         `protobuf:"varint,2,opt,name=index_id,json=indexId" json:"index_id"`
	Columns          []*ColumnInfo `protobuf:"bytes,3,rep,name=columns" json:"columns,omitempty"`
	Desc             bool          `protobuf:"varint,4,opt,name=desc" json:"desc"`
	Unique           *bool         `protobuf:"varint,5,opt,name=unique" json:"unique,omitempty"`
	PrimaryColumnIds []int64       `protobuf:"varint,6,rep,name=primary_column_ids,json=primaryColumnIds" json:"primary_column_ids,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *IndexScan) Reset()                    { *m = IndexScan{} }
func (m *IndexScan) String() string            { return proto.CompactTextString(m) }
func (*IndexScan) ProtoMessage()               {}
func (*IndexScan) Descriptor() ([]byte, []int) { return fileDescriptorExecutor, []int{6} }

func (m *IndexScan) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *IndexScan) GetIndexId() int64 {
	if m != nil {
		return m.IndexId
	}
	return 0
}

func (m *IndexScan) GetColumns() []*ColumnInfo {
	if m != nil {
		return m.Columns
	}
	return nil
}

func (m *IndexScan) GetDesc() bool {
	if m != nil {
		return m.Desc
	}
	return false
}

func (m *IndexScan) GetUnique() bool {
	if m != nil && m.Unique != nil {
		return *m.Unique
	}
	return false
}

func (m *IndexScan) GetPrimaryColumnIds() []int64 {
	if m != nil {
		return m.PrimaryColumnIds
	}
	return nil
}

type Selection struct {
	// Where conditions.
	Conditions       []*Expr    `protobuf:"bytes,1,rep,name=conditions" json:"conditions,omitempty"`
	RpnConditions    []*RpnExpr `protobuf:"bytes,2,rep,name=rpn_conditions,json=rpnConditions" json:"rpn_conditions,omitempty"`
	Child            *Executor  `protobuf:"bytes,3,opt,name=child" json:"child,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *Selection) Reset()                    { *m = Selection{} }
func (m *Selection) String() string            { return proto.CompactTextString(m) }
func (*Selection) ProtoMessage()               {}
func (*Selection) Descriptor() ([]byte, []int) { return fileDescriptorExecutor, []int{7} }

func (m *Selection) GetConditions() []*Expr {
	if m != nil {
		return m.Conditions
	}
	return nil
}

func (m *Selection) GetRpnConditions() []*RpnExpr {
	if m != nil {
		return m.RpnConditions
	}
	return nil
}

func (m *Selection) GetChild() *Executor {
	if m != nil {
		return m.Child
	}
	return nil
}

type Projection struct {
	// Projection expressions.
	Exprs            []*Expr    `protobuf:"bytes,1,rep,name=exprs" json:"exprs,omitempty"`
	RpnExprs         []*RpnExpr `protobuf:"bytes,2,rep,name=rpn_exprs,json=rpnExprs" json:"rpn_exprs,omitempty"`
	Child            *Executor  `protobuf:"bytes,3,opt,name=child" json:"child,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *Projection) Reset()                    { *m = Projection{} }
func (m *Projection) String() string            { return proto.CompactTextString(m) }
func (*Projection) ProtoMessage()               {}
func (*Projection) Descriptor() ([]byte, []int) { return fileDescriptorExecutor, []int{8} }

func (m *Projection) GetExprs() []*Expr {
	if m != nil {
		return m.Exprs
	}
	return nil
}

func (m *Projection) GetRpnExprs() []*RpnExpr {
	if m != nil {
		return m.RpnExprs
	}
	return nil
}

func (m *Projection) GetChild() *Executor {
	if m != nil {
		return m.Child
	}
	return nil
}

type Aggregation struct {
	// Group by clause.
	GroupBy    []*Expr    `protobuf:"bytes,1,rep,name=group_by,json=groupBy" json:"group_by,omitempty"`
	RpnGroupBy []*RpnExpr `protobuf:"bytes,4,rep,name=rpn_group_by,json=rpnGroupBy" json:"rpn_group_by,omitempty"`
	// Aggregate functions.
	AggFunc    []*Expr    `protobuf:"bytes,2,rep,name=agg_func,json=aggFunc" json:"agg_func,omitempty"`
	RpnAggFunc []*RpnExpr `protobuf:"bytes,5,rep,name=rpn_agg_func,json=rpnAggFunc" json:"rpn_agg_func,omitempty"`
	// If it is a stream aggregation.
	Streamed         bool      `protobuf:"varint,3,opt,name=streamed" json:"streamed"`
	Child            *Executor `protobuf:"bytes,6,opt,name=child" json:"child,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *Aggregation) Reset()                    { *m = Aggregation{} }
func (m *Aggregation) String() string            { return proto.CompactTextString(m) }
func (*Aggregation) ProtoMessage()               {}
func (*Aggregation) Descriptor() ([]byte, []int) { return fileDescriptorExecutor, []int{9} }

func (m *Aggregation) GetGroupBy() []*Expr {
	if m != nil {
		return m.GroupBy
	}
	return nil
}

func (m *Aggregation) GetRpnGroupBy() []*RpnExpr {
	if m != nil {
		return m.RpnGroupBy
	}
	return nil
}

func (m *Aggregation) GetAggFunc() []*Expr {
	if m != nil {
		return m.AggFunc
	}
	return nil
}

func (m *Aggregation) GetRpnAggFunc() []*RpnExpr {
	if m != nil {
		return m.RpnAggFunc
	}
	return nil
}

func (m *Aggregation) GetStreamed() bool {
	if m != nil {
		return m.Streamed
	}
	return false
}

func (m *Aggregation) GetChild() *Executor {
	if m != nil {
		return m.Child
	}
	return nil
}

type TopN struct {
	// Order by clause.
	OrderBy []*ByItem `protobuf:"bytes,1,rep,name=order_by,json=orderBy" json:"order_by,omitempty"`
	Limit   uint64    `protobuf:"varint,2,opt,name=limit" json:"limit"`
	Child   *Executor `protobuf:"bytes,3,opt,name=child" json:"child,omitempty"`
	// If partition_by is not empty, it means need to return topN of each partition.
	// Generally used in sqls like `where row_number() over (partition by ... order by ...) < X`
	PartitionBy      []*ByItem `protobuf:"bytes,4,rep,name=partition_by,json=partitionBy" json:"partition_by,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *TopN) Reset()                    { *m = TopN{} }
func (m *TopN) String() string            { return proto.CompactTextString(m) }
func (*TopN) ProtoMessage()               {}
func (*TopN) Descriptor() ([]byte, []int) { return fileDescriptorExecutor, []int{10} }

func (m *TopN) GetOrderBy() []*ByItem {
	if m != nil {
		return m.OrderBy
	}
	return nil
}

func (m *TopN) GetLimit() uint64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *TopN) GetChild() *Executor {
	if m != nil {
		return m.Child
	}
	return nil
}

func (m *TopN) GetPartitionBy() []*ByItem {
	if m != nil {
		return m.PartitionBy
	}
	return nil
}

type Limit struct {
	// Limit the result to be returned.
	Limit uint64    `protobuf:"varint,1,opt,name=limit" json:"limit"`
	Child *Executor `protobuf:"bytes,2,opt,name=child" json:"child,omitempty"`
	// If partition_by is not empty, it means need to return limitN of each partition.
	// Generally used in sqls like `where row_number() over (partition by ...) < X`
	PartitionBy      []*ByItem `protobuf:"bytes,3,rep,name=partition_by,json=partitionBy" json:"partition_by,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *Limit) Reset()                    { *m = Limit{} }
func (m *Limit) String() string            { return proto.CompactTextString(m) }
func (*Limit) ProtoMessage()               {}
func (*Limit) Descriptor() ([]byte, []int) { return fileDescriptorExecutor, []int{11} }

func (m *Limit) GetLimit() uint64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *Limit) GetChild() *Executor {
	if m != nil {
		return m.Child
	}
	return nil
}

func (m *Limit) GetPartitionBy() []*ByItem {
	if m != nil {
		return m.PartitionBy
	}
	return nil
}

type Kill struct {
	ConnID uint64 `protobuf:"varint,1,opt,name=connID" json:"connID"`
	// Query indicates whether terminate a single query on this connection or the whole connection.
	//   If Query is true, terminates the statement the connection is currently executing, but leaves the connection itself intact.
	//   If Query is false, terminates the connection associated with the given ConnectionID, after terminating any statement the connection is executing.
	//   See https://dev.mysql.com/doc/refman/8.0/en/kill.html.
	Query            bool   `protobuf:"varint,2,opt,name=query" json:"query"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Kill) Reset()                    { *m = Kill{} }
func (m *Kill) String() string            { return proto.CompactTextString(m) }
func (*Kill) ProtoMessage()               {}
func (*Kill) Descriptor() ([]byte, []int) { return fileDescriptorExecutor, []int{12} }

func (m *Kill) GetConnID() uint64 {
	if m != nil {
		return m.ConnID
	}
	return 0
}

func (m *Kill) GetQuery() bool {
	if m != nil {
		return m.Query
	}
	return false
}

type ExecutorExecutionSummary struct {
	// Total time cost in this executor. Includes self time cost and children time cost.
	TimeProcessedNs *uint64 `protobuf:"varint,1,opt,name=time_processed_ns,json=timeProcessedNs" json:"time_processed_ns,omitempty"`
	// How many rows this executor produced totally.
	NumProducedRows *uint64 `protobuf:"varint,2,opt,name=num_produced_rows,json=numProducedRows" json:"num_produced_rows,omitempty"`
	// How many times executor's `next()` is called.
	NumIterations *uint64 `protobuf:"varint,3,opt,name=num_iterations,json=numIterations" json:"num_iterations,omitempty"`
	// Coresponding executor id
	ExecutorId *string `protobuf:"bytes,4,opt,name=executor_id,json=executorId" json:"executor_id,omitempty"`
	// The execution concurrency for this executor
	Concurrency *uint64 `protobuf:"varint,5,opt,name=concurrency" json:"concurrency,omitempty"`
	// Types that are valid to be assigned to DetailInfo:
	//	*ExecutorExecutionSummary_TiflashScanContext
	DetailInfo       isExecutorExecutionSummary_DetailInfo `protobuf_oneof:"DetailInfo"`
	XXX_unrecognized []byte                                `json:"-"`
}

func (m *ExecutorExecutionSummary) Reset()         { *m = ExecutorExecutionSummary{} }
func (m *ExecutorExecutionSummary) String() string { return proto.CompactTextString(m) }
func (*ExecutorExecutionSummary) ProtoMessage()    {}
func (*ExecutorExecutionSummary) Descriptor() ([]byte, []int) {
	return fileDescriptorExecutor, []int{13}
}

type isExecutorExecutionSummary_DetailInfo interface {
	isExecutorExecutionSummary_DetailInfo()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ExecutorExecutionSummary_TiflashScanContext struct {
	TiflashScanContext *TiFlashScanContext `protobuf:"bytes,6,opt,name=tiflash_scan_context,json=tiflashScanContext,oneof"`
}

func (*ExecutorExecutionSummary_TiflashScanContext) isExecutorExecutionSummary_DetailInfo() {}

func (m *ExecutorExecutionSummary) GetDetailInfo() isExecutorExecutionSummary_DetailInfo {
	if m != nil {
		return m.DetailInfo
	}
	return nil
}

func (m *ExecutorExecutionSummary) GetTimeProcessedNs() uint64 {
	if m != nil && m.TimeProcessedNs != nil {
		return *m.TimeProcessedNs
	}
	return 0
}

func (m *ExecutorExecutionSummary) GetNumProducedRows() uint64 {
	if m != nil && m.NumProducedRows != nil {
		return *m.NumProducedRows
	}
	return 0
}

func (m *ExecutorExecutionSummary) GetNumIterations() uint64 {
	if m != nil && m.NumIterations != nil {
		return *m.NumIterations
	}
	return 0
}

func (m *ExecutorExecutionSummary) GetExecutorId() string {
	if m != nil && m.ExecutorId != nil {
		return *m.ExecutorId
	}
	return ""
}

func (m *ExecutorExecutionSummary) GetConcurrency() uint64 {
	if m != nil && m.Concurrency != nil {
		return *m.Concurrency
	}
	return 0
}

func (m *ExecutorExecutionSummary) GetTiflashScanContext() *TiFlashScanContext {
	if x, ok := m.GetDetailInfo().(*ExecutorExecutionSummary_TiflashScanContext); ok {
		return x.TiflashScanContext
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ExecutorExecutionSummary) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ExecutorExecutionSummary_OneofMarshaler, _ExecutorExecutionSummary_OneofUnmarshaler, _ExecutorExecutionSummary_OneofSizer, []interface{}{
		(*ExecutorExecutionSummary_TiflashScanContext)(nil),
	}
}

func _ExecutorExecutionSummary_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ExecutorExecutionSummary)
	// DetailInfo
	switch x := m.DetailInfo.(type) {
	case *ExecutorExecutionSummary_TiflashScanContext:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TiflashScanContext); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ExecutorExecutionSummary.DetailInfo has unexpected type %T", x)
	}
	return nil
}

func _ExecutorExecutionSummary_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ExecutorExecutionSummary)
	switch tag {
	case 6: // DetailInfo.tiflash_scan_context
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TiFlashScanContext)
		err := b.DecodeMessage(msg)
		m.DetailInfo = &ExecutorExecutionSummary_TiflashScanContext{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ExecutorExecutionSummary_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ExecutorExecutionSummary)
	// DetailInfo
	switch x := m.DetailInfo.(type) {
	case *ExecutorExecutionSummary_TiflashScanContext:
		s := proto.Size(x.TiflashScanContext)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type TiFlashScanContext struct {
	TotalDmfileScannedPacks            *uint64 `protobuf:"varint,1,opt,name=total_dmfile_scanned_packs,json=totalDmfileScannedPacks" json:"total_dmfile_scanned_packs,omitempty"`
	TotalDmfileSkippedPacks            *uint64 `protobuf:"varint,2,opt,name=total_dmfile_skipped_packs,json=totalDmfileSkippedPacks" json:"total_dmfile_skipped_packs,omitempty"`
	TotalDmfileScannedRows             *uint64 `protobuf:"varint,3,opt,name=total_dmfile_scanned_rows,json=totalDmfileScannedRows" json:"total_dmfile_scanned_rows,omitempty"`
	TotalDmfileSkippedRows             *uint64 `protobuf:"varint,4,opt,name=total_dmfile_skipped_rows,json=totalDmfileSkippedRows" json:"total_dmfile_skipped_rows,omitempty"`
	TotalDmfileRoughSetIndexLoadTimeMs *uint64 `protobuf:"varint,5,opt,name=total_dmfile_rough_set_index_load_time_ms,json=totalDmfileRoughSetIndexLoadTimeMs" json:"total_dmfile_rough_set_index_load_time_ms,omitempty"`
	TotalDmfileReadTimeMs              *uint64 `protobuf:"varint,6,opt,name=total_dmfile_read_time_ms,json=totalDmfileReadTimeMs" json:"total_dmfile_read_time_ms,omitempty"`
	TotalCreateSnapshotTimeMs          *uint64 `protobuf:"varint,7,opt,name=total_create_snapshot_time_ms,json=totalCreateSnapshotTimeMs" json:"total_create_snapshot_time_ms,omitempty"`
	TotalLocalRegionNum                *uint64 `protobuf:"varint,8,opt,name=total_local_region_num,json=totalLocalRegionNum" json:"total_local_region_num,omitempty"`
	TotalRemoteRegionNum               *uint64 `protobuf:"varint,9,opt,name=total_remote_region_num,json=totalRemoteRegionNum" json:"total_remote_region_num,omitempty"`
	XXX_unrecognized                   []byte  `json:"-"`
}

func (m *TiFlashScanContext) Reset()                    { *m = TiFlashScanContext{} }
func (m *TiFlashScanContext) String() string            { return proto.CompactTextString(m) }
func (*TiFlashScanContext) ProtoMessage()               {}
func (*TiFlashScanContext) Descriptor() ([]byte, []int) { return fileDescriptorExecutor, []int{14} }

func (m *TiFlashScanContext) GetTotalDmfileScannedPacks() uint64 {
	if m != nil && m.TotalDmfileScannedPacks != nil {
		return *m.TotalDmfileScannedPacks
	}
	return 0
}

func (m *TiFlashScanContext) GetTotalDmfileSkippedPacks() uint64 {
	if m != nil && m.TotalDmfileSkippedPacks != nil {
		return *m.TotalDmfileSkippedPacks
	}
	return 0
}

func (m *TiFlashScanContext) GetTotalDmfileScannedRows() uint64 {
	if m != nil && m.TotalDmfileScannedRows != nil {
		return *m.TotalDmfileScannedRows
	}
	return 0
}

func (m *TiFlashScanContext) GetTotalDmfileSkippedRows() uint64 {
	if m != nil && m.TotalDmfileSkippedRows != nil {
		return *m.TotalDmfileSkippedRows
	}
	return 0
}

func (m *TiFlashScanContext) GetTotalDmfileRoughSetIndexLoadTimeMs() uint64 {
	if m != nil && m.TotalDmfileRoughSetIndexLoadTimeMs != nil {
		return *m.TotalDmfileRoughSetIndexLoadTimeMs
	}
	return 0
}

func (m *TiFlashScanContext) GetTotalDmfileReadTimeMs() uint64 {
	if m != nil && m.TotalDmfileReadTimeMs != nil {
		return *m.TotalDmfileReadTimeMs
	}
	return 0
}

func (m *TiFlashScanContext) GetTotalCreateSnapshotTimeMs() uint64 {
	if m != nil && m.TotalCreateSnapshotTimeMs != nil {
		return *m.TotalCreateSnapshotTimeMs
	}
	return 0
}

func (m *TiFlashScanContext) GetTotalLocalRegionNum() uint64 {
	if m != nil && m.TotalLocalRegionNum != nil {
		return *m.TotalLocalRegionNum
	}
	return 0
}

func (m *TiFlashScanContext) GetTotalRemoteRegionNum() uint64 {
	if m != nil && m.TotalRemoteRegionNum != nil {
		return *m.TotalRemoteRegionNum
	}
	return 0
}

type Sort struct {
	ByItems          []*ByItem `protobuf:"bytes,1,rep,name=byItems" json:"byItems,omitempty"`
	IsPartialSort    *bool     `protobuf:"varint,2,opt,name=isPartialSort" json:"isPartialSort,omitempty"`
	Child            *Executor `protobuf:"bytes,3,opt,name=child" json:"child,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *Sort) Reset()                    { *m = Sort{} }
func (m *Sort) String() string            { return proto.CompactTextString(m) }
func (*Sort) ProtoMessage()               {}
func (*Sort) Descriptor() ([]byte, []int) { return fileDescriptorExecutor, []int{15} }

func (m *Sort) GetByItems() []*ByItem {
	if m != nil {
		return m.ByItems
	}
	return nil
}

func (m *Sort) GetIsPartialSort() bool {
	if m != nil && m.IsPartialSort != nil {
		return *m.IsPartialSort
	}
	return false
}

func (m *Sort) GetChild() *Executor {
	if m != nil {
		return m.Child
	}
	return nil
}

type WindowFrameBound struct {
	Type             WindowBoundType `protobuf:"varint,1,opt,name=type,enum=tipb.WindowBoundType" json:"type"`
	Unbounded        bool            `protobuf:"varint,2,opt,name=unbounded" json:"unbounded"`
	Offset           *uint64         `protobuf:"varint,3,opt,name=offset" json:"offset,omitempty"`
	CalcFuncs        []*Expr         `protobuf:"bytes,4,rep,name=calcFuncs" json:"calcFuncs,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *WindowFrameBound) Reset()                    { *m = WindowFrameBound{} }
func (m *WindowFrameBound) String() string            { return proto.CompactTextString(m) }
func (*WindowFrameBound) ProtoMessage()               {}
func (*WindowFrameBound) Descriptor() ([]byte, []int) { return fileDescriptorExecutor, []int{16} }

func (m *WindowFrameBound) GetType() WindowBoundType {
	if m != nil {
		return m.Type
	}
	return WindowBoundType_Following
}

func (m *WindowFrameBound) GetUnbounded() bool {
	if m != nil {
		return m.Unbounded
	}
	return false
}

func (m *WindowFrameBound) GetOffset() uint64 {
	if m != nil && m.Offset != nil {
		return *m.Offset
	}
	return 0
}

func (m *WindowFrameBound) GetCalcFuncs() []*Expr {
	if m != nil {
		return m.CalcFuncs
	}
	return nil
}

type WindowFrame struct {
	Type             WindowFrameType   `protobuf:"varint,1,opt,name=type,enum=tipb.WindowFrameType" json:"type"`
	Start            *WindowFrameBound `protobuf:"bytes,2,opt,name=start" json:"start,omitempty"`
	End              *WindowFrameBound `protobuf:"bytes,3,opt,name=end" json:"end,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *WindowFrame) Reset()                    { *m = WindowFrame{} }
func (m *WindowFrame) String() string            { return proto.CompactTextString(m) }
func (*WindowFrame) ProtoMessage()               {}
func (*WindowFrame) Descriptor() ([]byte, []int) { return fileDescriptorExecutor, []int{17} }

func (m *WindowFrame) GetType() WindowFrameType {
	if m != nil {
		return m.Type
	}
	return WindowFrameType_Rows
}

func (m *WindowFrame) GetStart() *WindowFrameBound {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *WindowFrame) GetEnd() *WindowFrameBound {
	if m != nil {
		return m.End
	}
	return nil
}

type Window struct {
	FuncDesc         []*Expr      `protobuf:"bytes,1,rep,name=func_desc,json=funcDesc" json:"func_desc,omitempty"`
	PartitionBy      []*ByItem    `protobuf:"bytes,2,rep,name=partition_by,json=partitionBy" json:"partition_by,omitempty"`
	OrderBy          []*ByItem    `protobuf:"bytes,3,rep,name=order_by,json=orderBy" json:"order_by,omitempty"`
	Frame            *WindowFrame `protobuf:"bytes,4,opt,name=frame" json:"frame,omitempty"`
	Child            *Executor    `protobuf:"bytes,5,opt,name=child" json:"child,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *Window) Reset()                    { *m = Window{} }
func (m *Window) String() string            { return proto.CompactTextString(m) }
func (*Window) ProtoMessage()               {}
func (*Window) Descriptor() ([]byte, []int) { return fileDescriptorExecutor, []int{18} }

func (m *Window) GetFuncDesc() []*Expr {
	if m != nil {
		return m.FuncDesc
	}
	return nil
}

func (m *Window) GetPartitionBy() []*ByItem {
	if m != nil {
		return m.PartitionBy
	}
	return nil
}

func (m *Window) GetOrderBy() []*ByItem {
	if m != nil {
		return m.OrderBy
	}
	return nil
}

func (m *Window) GetFrame() *WindowFrame {
	if m != nil {
		return m.Frame
	}
	return nil
}

func (m *Window) GetChild() *Executor {
	if m != nil {
		return m.Child
	}
	return nil
}

type GroupingExpr struct {
	GroupingExpr     []*Expr `protobuf:"bytes,1,rep,name=grouping_expr,json=groupingExpr" json:"grouping_expr,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *GroupingExpr) Reset()                    { *m = GroupingExpr{} }
func (m *GroupingExpr) String() string            { return proto.CompactTextString(m) }
func (*GroupingExpr) ProtoMessage()               {}
func (*GroupingExpr) Descriptor() ([]byte, []int) { return fileDescriptorExecutor, []int{19} }

func (m *GroupingExpr) GetGroupingExpr() []*Expr {
	if m != nil {
		return m.GroupingExpr
	}
	return nil
}

type GroupingSet struct {
	GroupingExprs    []*GroupingExpr `protobuf:"bytes,1,rep,name=grouping_exprs,json=groupingExprs" json:"grouping_exprs,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *GroupingSet) Reset()                    { *m = GroupingSet{} }
func (m *GroupingSet) String() string            { return proto.CompactTextString(m) }
func (*GroupingSet) ProtoMessage()               {}
func (*GroupingSet) Descriptor() ([]byte, []int) { return fileDescriptorExecutor, []int{20} }

func (m *GroupingSet) GetGroupingExprs() []*GroupingExpr {
	if m != nil {
		return m.GroupingExprs
	}
	return nil
}

type Expand struct {
	GroupingSets     []*GroupingSet `protobuf:"bytes,1,rep,name=grouping_sets,json=groupingSets" json:"grouping_sets,omitempty"`
	Child            *Executor      `protobuf:"bytes,2,opt,name=child" json:"child,omitempty"`
	Version          *uint64        `protobuf:"varint,3,opt,name=version" json:"version,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *Expand) Reset()                    { *m = Expand{} }
func (m *Expand) String() string            { return proto.CompactTextString(m) }
func (*Expand) ProtoMessage()               {}
func (*Expand) Descriptor() ([]byte, []int) { return fileDescriptorExecutor, []int{21} }

func (m *Expand) GetGroupingSets() []*GroupingSet {
	if m != nil {
		return m.GroupingSets
	}
	return nil
}

func (m *Expand) GetChild() *Executor {
	if m != nil {
		return m.Child
	}
	return nil
}

func (m *Expand) GetVersion() uint64 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return 0
}

func init() {
	proto.RegisterType((*Executor)(nil), "tipb.Executor")
	proto.RegisterType((*ExchangeSender)(nil), "tipb.ExchangeSender")
	proto.RegisterType((*ExchangeReceiver)(nil), "tipb.ExchangeReceiver")
	proto.RegisterType((*TableScan)(nil), "tipb.TableScan")
	proto.RegisterType((*PartitionTableScan)(nil), "tipb.PartitionTableScan")
	proto.RegisterType((*Join)(nil), "tipb.Join")
	proto.RegisterType((*IndexScan)(nil), "tipb.IndexScan")
	proto.RegisterType((*Selection)(nil), "tipb.Selection")
	proto.RegisterType((*Projection)(nil), "tipb.Projection")
	proto.RegisterType((*Aggregation)(nil), "tipb.Aggregation")
	proto.RegisterType((*TopN)(nil), "tipb.TopN")
	proto.RegisterType((*Limit)(nil), "tipb.Limit")
	proto.RegisterType((*Kill)(nil), "tipb.Kill")
	proto.RegisterType((*ExecutorExecutionSummary)(nil), "tipb.ExecutorExecutionSummary")
	proto.RegisterType((*TiFlashScanContext)(nil), "tipb.TiFlashScanContext")
	proto.RegisterType((*Sort)(nil), "tipb.Sort")
	proto.RegisterType((*WindowFrameBound)(nil), "tipb.WindowFrameBound")
	proto.RegisterType((*WindowFrame)(nil), "tipb.WindowFrame")
	proto.RegisterType((*Window)(nil), "tipb.Window")
	proto.RegisterType((*GroupingExpr)(nil), "tipb.GroupingExpr")
	proto.RegisterType((*GroupingSet)(nil), "tipb.GroupingSet")
	proto.RegisterType((*Expand)(nil), "tipb.Expand")
	proto.RegisterEnum("tipb.ExecType", ExecType_name, ExecType_value)
	proto.RegisterEnum("tipb.ExchangeType", ExchangeType_name, ExchangeType_value)
	proto.RegisterEnum("tipb.CompressionMode", CompressionMode_name, CompressionMode_value)
	proto.RegisterEnum("tipb.EngineType", EngineType_name, EngineType_value)
	proto.RegisterEnum("tipb.JoinType", JoinType_name, JoinType_value)
	proto.RegisterEnum("tipb.JoinExecType", JoinExecType_name, JoinExecType_value)
	proto.RegisterEnum("tipb.WindowBoundType", WindowBoundType_name, WindowBoundType_value)
	proto.RegisterEnum("tipb.WindowFrameType", WindowFrameType_name, WindowFrameType_value)
}
func (m *Executor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Executor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintExecutor(dAtA, i, uint64(m.Tp))
	if m.TblScan != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(m.TblScan.Size()))
		n1, err := m.TblScan.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.IdxScan != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(m.IdxScan.Size()))
		n2, err := m.IdxScan.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Selection != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(m.Selection.Size()))
		n3, err := m.Selection.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Aggregation != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(m.Aggregation.Size()))
		n4, err := m.Aggregation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.TopN != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(m.TopN.Size()))
		n5, err := m.TopN.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Limit != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(m.Limit.Size()))
		n6, err := m.Limit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.ExchangeReceiver != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(m.ExchangeReceiver.Size()))
		n7, err := m.ExchangeReceiver.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Join != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(m.Join.Size()))
		n8, err := m.Join.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.ExecutorId != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(len(*m.ExecutorId)))
		i += copy(dAtA[i:], *m.ExecutorId)
	}
	if m.Kill != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(m.Kill.Size()))
		n9, err := m.Kill.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.ExchangeSender != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(m.ExchangeSender.Size()))
		n10, err := m.ExchangeSender.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Projection != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(m.Projection.Size()))
		n11, err := m.Projection.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.PartitionTableScan != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(m.PartitionTableScan.Size()))
		n12, err := m.PartitionTableScan.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.Sort != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(m.Sort.Size()))
		n13, err := m.Sort.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.Window != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(m.Window.Size()))
		n14, err := m.Window.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	dAtA[i] = 0x88
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintExecutor(dAtA, i, uint64(m.FineGrainedShuffleStreamCount))
	dAtA[i] = 0x90
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintExecutor(dAtA, i, uint64(m.FineGrainedShuffleBatchSize))
	if m.Expand != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(m.Expand.Size()))
		n15, err := m.Expand.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExchangeSender) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExchangeSender) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintExecutor(dAtA, i, uint64(m.Tp))
	if len(m.EncodedTaskMeta) > 0 {
		for _, b := range m.EncodedTaskMeta {
			dAtA[i] = 0x12
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.PartitionKeys) > 0 {
		for _, msg := range m.PartitionKeys {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Child != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(m.Child.Size()))
		n16, err := m.Child.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if len(m.Types) > 0 {
		for _, msg := range m.Types {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AllFieldTypes) > 0 {
		for _, msg := range m.AllFieldTypes {
			dAtA[i] = 0x32
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x38
	i++
	i = encodeVarintExecutor(dAtA, i, uint64(m.Compression))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExchangeReceiver) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExchangeReceiver) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EncodedTaskMeta) > 0 {
		for _, b := range m.EncodedTaskMeta {
			dAtA[i] = 0xa
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.FieldTypes) > 0 {
		for _, msg := range m.FieldTypes {
			dAtA[i] = 0x12
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Tp != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(*m.Tp))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TableScan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableScan) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintExecutor(dAtA, i, uint64(m.TableId))
	if len(m.Columns) > 0 {
		for _, msg := range m.Columns {
			dAtA[i] = 0x12
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x18
	i++
	if m.Desc {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if len(m.PrimaryColumnIds) > 0 {
		for _, num := range m.PrimaryColumnIds {
			dAtA[i] = 0x20
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(num))
		}
	}
	dAtA[i] = 0x28
	i++
	i = encodeVarintExecutor(dAtA, i, uint64(m.NextReadEngine))
	if len(m.Ranges) > 0 {
		for _, msg := range m.Ranges {
			dAtA[i] = 0x32
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PrimaryPrefixColumnIds) > 0 {
		for _, num := range m.PrimaryPrefixColumnIds {
			dAtA[i] = 0x38
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(num))
		}
	}
	if m.KeepOrder != nil {
		dAtA[i] = 0x40
		i++
		if *m.KeepOrder {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsFastScan != nil {
		dAtA[i] = 0x48
		i++
		if *m.IsFastScan {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.PushedDownFilterConditions) > 0 {
		for _, msg := range m.PushedDownFilterConditions {
			dAtA[i] = 0x52
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PartitionTableScan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionTableScan) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintExecutor(dAtA, i, uint64(m.TableId))
	if len(m.Columns) > 0 {
		for _, msg := range m.Columns {
			dAtA[i] = 0x12
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x18
	i++
	if m.Desc {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if len(m.PrimaryColumnIds) > 0 {
		for _, num := range m.PrimaryColumnIds {
			dAtA[i] = 0x20
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(num))
		}
	}
	if len(m.PrimaryPrefixColumnIds) > 0 {
		for _, num := range m.PrimaryPrefixColumnIds {
			dAtA[i] = 0x28
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(num))
		}
	}
	if len(m.PartitionIds) > 0 {
		for _, num := range m.PartitionIds {
			dAtA[i] = 0x30
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(num))
		}
	}
	if m.IsFastScan != nil {
		dAtA[i] = 0x38
		i++
		if *m.IsFastScan {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.PushedDownFilterConditions) > 0 {
		for _, msg := range m.PushedDownFilterConditions {
			dAtA[i] = 0x42
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Join) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Join) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintExecutor(dAtA, i, uint64(m.JoinType))
	dAtA[i] = 0x10
	i++
	i = encodeVarintExecutor(dAtA, i, uint64(m.JoinExecType))
	if len(m.Children) > 0 {
		for _, msg := range m.Children {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x20
	i++
	i = encodeVarintExecutor(dAtA, i, uint64(m.InnerIdx))
	if len(m.LeftJoinKeys) > 0 {
		for _, msg := range m.LeftJoinKeys {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RightJoinKeys) > 0 {
		for _, msg := range m.RightJoinKeys {
			dAtA[i] = 0x32
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ProbeTypes) > 0 {
		for _, msg := range m.ProbeTypes {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.BuildTypes) > 0 {
		for _, msg := range m.BuildTypes {
			dAtA[i] = 0x42
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.LeftConditions) > 0 {
		for _, msg := range m.LeftConditions {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RightConditions) > 0 {
		for _, msg := range m.RightConditions {
			dAtA[i] = 0x52
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.OtherConditions) > 0 {
		for _, msg := range m.OtherConditions {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.OtherEqConditionsFromIn) > 0 {
		for _, msg := range m.OtherEqConditionsFromIn {
			dAtA[i] = 0x62
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.IsNullAwareSemiJoin != nil {
		dAtA[i] = 0x68
		i++
		if *m.IsNullAwareSemiJoin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *IndexScan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexScan) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintExecutor(dAtA, i, uint64(m.TableId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintExecutor(dAtA, i, uint64(m.IndexId))
	if len(m.Columns) > 0 {
		for _, msg := range m.Columns {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x20
	i++
	if m.Desc {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if m.Unique != nil {
		dAtA[i] = 0x28
		i++
		if *m.Unique {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.PrimaryColumnIds) > 0 {
		for _, num := range m.PrimaryColumnIds {
			dAtA[i] = 0x30
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(num))
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Selection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Selection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for _, msg := range m.Conditions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RpnConditions) > 0 {
		for _, msg := range m.RpnConditions {
			dAtA[i] = 0x12
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Child != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(m.Child.Size()))
		n17, err := m.Child.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Projection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Projection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Exprs) > 0 {
		for _, msg := range m.Exprs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RpnExprs) > 0 {
		for _, msg := range m.RpnExprs {
			dAtA[i] = 0x12
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Child != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(m.Child.Size()))
		n18, err := m.Child.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Aggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Aggregation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GroupBy) > 0 {
		for _, msg := range m.GroupBy {
			dAtA[i] = 0xa
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AggFunc) > 0 {
		for _, msg := range m.AggFunc {
			dAtA[i] = 0x12
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x18
	i++
	if m.Streamed {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if len(m.RpnGroupBy) > 0 {
		for _, msg := range m.RpnGroupBy {
			dAtA[i] = 0x22
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RpnAggFunc) > 0 {
		for _, msg := range m.RpnAggFunc {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Child != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(m.Child.Size()))
		n19, err := m.Child.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TopN) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopN) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OrderBy) > 0 {
		for _, msg := range m.OrderBy {
			dAtA[i] = 0xa
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x10
	i++
	i = encodeVarintExecutor(dAtA, i, uint64(m.Limit))
	if m.Child != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(m.Child.Size()))
		n20, err := m.Child.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if len(m.PartitionBy) > 0 {
		for _, msg := range m.PartitionBy {
			dAtA[i] = 0x22
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Limit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Limit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintExecutor(dAtA, i, uint64(m.Limit))
	if m.Child != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(m.Child.Size()))
		n21, err := m.Child.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if len(m.PartitionBy) > 0 {
		for _, msg := range m.PartitionBy {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Kill) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Kill) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintExecutor(dAtA, i, uint64(m.ConnID))
	dAtA[i] = 0x10
	i++
	if m.Query {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExecutorExecutionSummary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecutorExecutionSummary) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TimeProcessedNs != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(*m.TimeProcessedNs))
	}
	if m.NumProducedRows != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(*m.NumProducedRows))
	}
	if m.NumIterations != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(*m.NumIterations))
	}
	if m.ExecutorId != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(len(*m.ExecutorId)))
		i += copy(dAtA[i:], *m.ExecutorId)
	}
	if m.Concurrency != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(*m.Concurrency))
	}
	if m.DetailInfo != nil {
		nn22, err := m.DetailInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn22
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExecutorExecutionSummary_TiflashScanContext) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TiflashScanContext != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(m.TiflashScanContext.Size()))
		n23, err := m.TiflashScanContext.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}
func (m *TiFlashScanContext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TiFlashScanContext) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TotalDmfileScannedPacks != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(*m.TotalDmfileScannedPacks))
	}
	if m.TotalDmfileSkippedPacks != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(*m.TotalDmfileSkippedPacks))
	}
	if m.TotalDmfileScannedRows != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(*m.TotalDmfileScannedRows))
	}
	if m.TotalDmfileSkippedRows != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(*m.TotalDmfileSkippedRows))
	}
	if m.TotalDmfileRoughSetIndexLoadTimeMs != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(*m.TotalDmfileRoughSetIndexLoadTimeMs))
	}
	if m.TotalDmfileReadTimeMs != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(*m.TotalDmfileReadTimeMs))
	}
	if m.TotalCreateSnapshotTimeMs != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(*m.TotalCreateSnapshotTimeMs))
	}
	if m.TotalLocalRegionNum != nil {
		dAtA[i] = 0x40
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(*m.TotalLocalRegionNum))
	}
	if m.TotalRemoteRegionNum != nil {
		dAtA[i] = 0x48
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(*m.TotalRemoteRegionNum))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Sort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sort) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ByItems) > 0 {
		for _, msg := range m.ByItems {
			dAtA[i] = 0xa
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.IsPartialSort != nil {
		dAtA[i] = 0x10
		i++
		if *m.IsPartialSort {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Child != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(m.Child.Size()))
		n24, err := m.Child.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WindowFrameBound) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WindowFrameBound) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintExecutor(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x10
	i++
	if m.Unbounded {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if m.Offset != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(*m.Offset))
	}
	if len(m.CalcFuncs) > 0 {
		for _, msg := range m.CalcFuncs {
			dAtA[i] = 0x22
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WindowFrame) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WindowFrame) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintExecutor(dAtA, i, uint64(m.Type))
	if m.Start != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(m.Start.Size()))
		n25, err := m.Start.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.End != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(m.End.Size()))
		n26, err := m.End.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Window) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Window) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FuncDesc) > 0 {
		for _, msg := range m.FuncDesc {
			dAtA[i] = 0xa
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PartitionBy) > 0 {
		for _, msg := range m.PartitionBy {
			dAtA[i] = 0x12
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.OrderBy) > 0 {
		for _, msg := range m.OrderBy {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Frame != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(m.Frame.Size()))
		n27, err := m.Frame.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.Child != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(m.Child.Size()))
		n28, err := m.Child.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GroupingExpr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupingExpr) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GroupingExpr) > 0 {
		for _, msg := range m.GroupingExpr {
			dAtA[i] = 0xa
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GroupingSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupingSet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GroupingExprs) > 0 {
		for _, msg := range m.GroupingExprs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Expand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Expand) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GroupingSets) > 0 {
		for _, msg := range m.GroupingSets {
			dAtA[i] = 0xa
			i++
			i = encodeVarintExecutor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Child != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(m.Child.Size()))
		n29, err := m.Child.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.Version != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintExecutor(dAtA, i, uint64(*m.Version))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintExecutor(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Executor) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovExecutor(uint64(m.Tp))
	if m.TblScan != nil {
		l = m.TblScan.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.IdxScan != nil {
		l = m.IdxScan.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.Selection != nil {
		l = m.Selection.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.Aggregation != nil {
		l = m.Aggregation.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.TopN != nil {
		l = m.TopN.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.Limit != nil {
		l = m.Limit.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.ExchangeReceiver != nil {
		l = m.ExchangeReceiver.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.Join != nil {
		l = m.Join.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.ExecutorId != nil {
		l = len(*m.ExecutorId)
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.Kill != nil {
		l = m.Kill.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.ExchangeSender != nil {
		l = m.ExchangeSender.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.Projection != nil {
		l = m.Projection.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.PartitionTableScan != nil {
		l = m.PartitionTableScan.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.Sort != nil {
		l = m.Sort.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.Window != nil {
		l = m.Window.Size()
		n += 2 + l + sovExecutor(uint64(l))
	}
	n += 2 + sovExecutor(uint64(m.FineGrainedShuffleStreamCount))
	n += 2 + sovExecutor(uint64(m.FineGrainedShuffleBatchSize))
	if m.Expand != nil {
		l = m.Expand.Size()
		n += 2 + l + sovExecutor(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExchangeSender) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovExecutor(uint64(m.Tp))
	if len(m.EncodedTaskMeta) > 0 {
		for _, b := range m.EncodedTaskMeta {
			l = len(b)
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.PartitionKeys) > 0 {
		for _, e := range m.PartitionKeys {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if m.Child != nil {
		l = m.Child.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if len(m.Types) > 0 {
		for _, e := range m.Types {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.AllFieldTypes) > 0 {
		for _, e := range m.AllFieldTypes {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	n += 1 + sovExecutor(uint64(m.Compression))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExchangeReceiver) Size() (n int) {
	var l int
	_ = l
	if len(m.EncodedTaskMeta) > 0 {
		for _, b := range m.EncodedTaskMeta {
			l = len(b)
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.FieldTypes) > 0 {
		for _, e := range m.FieldTypes {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if m.Tp != nil {
		n += 1 + sovExecutor(uint64(*m.Tp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableScan) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovExecutor(uint64(m.TableId))
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	n += 2
	if len(m.PrimaryColumnIds) > 0 {
		for _, e := range m.PrimaryColumnIds {
			n += 1 + sovExecutor(uint64(e))
		}
	}
	n += 1 + sovExecutor(uint64(m.NextReadEngine))
	if len(m.Ranges) > 0 {
		for _, e := range m.Ranges {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.PrimaryPrefixColumnIds) > 0 {
		for _, e := range m.PrimaryPrefixColumnIds {
			n += 1 + sovExecutor(uint64(e))
		}
	}
	if m.KeepOrder != nil {
		n += 2
	}
	if m.IsFastScan != nil {
		n += 2
	}
	if len(m.PushedDownFilterConditions) > 0 {
		for _, e := range m.PushedDownFilterConditions {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PartitionTableScan) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovExecutor(uint64(m.TableId))
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	n += 2
	if len(m.PrimaryColumnIds) > 0 {
		for _, e := range m.PrimaryColumnIds {
			n += 1 + sovExecutor(uint64(e))
		}
	}
	if len(m.PrimaryPrefixColumnIds) > 0 {
		for _, e := range m.PrimaryPrefixColumnIds {
			n += 1 + sovExecutor(uint64(e))
		}
	}
	if len(m.PartitionIds) > 0 {
		for _, e := range m.PartitionIds {
			n += 1 + sovExecutor(uint64(e))
		}
	}
	if m.IsFastScan != nil {
		n += 2
	}
	if len(m.PushedDownFilterConditions) > 0 {
		for _, e := range m.PushedDownFilterConditions {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Join) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovExecutor(uint64(m.JoinType))
	n += 1 + sovExecutor(uint64(m.JoinExecType))
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	n += 1 + sovExecutor(uint64(m.InnerIdx))
	if len(m.LeftJoinKeys) > 0 {
		for _, e := range m.LeftJoinKeys {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.RightJoinKeys) > 0 {
		for _, e := range m.RightJoinKeys {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.ProbeTypes) > 0 {
		for _, e := range m.ProbeTypes {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.BuildTypes) > 0 {
		for _, e := range m.BuildTypes {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.LeftConditions) > 0 {
		for _, e := range m.LeftConditions {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.RightConditions) > 0 {
		for _, e := range m.RightConditions {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.OtherConditions) > 0 {
		for _, e := range m.OtherConditions {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.OtherEqConditionsFromIn) > 0 {
		for _, e := range m.OtherEqConditionsFromIn {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if m.IsNullAwareSemiJoin != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IndexScan) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovExecutor(uint64(m.TableId))
	n += 1 + sovExecutor(uint64(m.IndexId))
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	n += 2
	if m.Unique != nil {
		n += 2
	}
	if len(m.PrimaryColumnIds) > 0 {
		for _, e := range m.PrimaryColumnIds {
			n += 1 + sovExecutor(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Selection) Size() (n int) {
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.RpnConditions) > 0 {
		for _, e := range m.RpnConditions {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if m.Child != nil {
		l = m.Child.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Projection) Size() (n int) {
	var l int
	_ = l
	if len(m.Exprs) > 0 {
		for _, e := range m.Exprs {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.RpnExprs) > 0 {
		for _, e := range m.RpnExprs {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if m.Child != nil {
		l = m.Child.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Aggregation) Size() (n int) {
	var l int
	_ = l
	if len(m.GroupBy) > 0 {
		for _, e := range m.GroupBy {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.AggFunc) > 0 {
		for _, e := range m.AggFunc {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	n += 2
	if len(m.RpnGroupBy) > 0 {
		for _, e := range m.RpnGroupBy {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.RpnAggFunc) > 0 {
		for _, e := range m.RpnAggFunc {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if m.Child != nil {
		l = m.Child.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TopN) Size() (n int) {
	var l int
	_ = l
	if len(m.OrderBy) > 0 {
		for _, e := range m.OrderBy {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	n += 1 + sovExecutor(uint64(m.Limit))
	if m.Child != nil {
		l = m.Child.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if len(m.PartitionBy) > 0 {
		for _, e := range m.PartitionBy {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Limit) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovExecutor(uint64(m.Limit))
	if m.Child != nil {
		l = m.Child.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if len(m.PartitionBy) > 0 {
		for _, e := range m.PartitionBy {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Kill) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovExecutor(uint64(m.ConnID))
	n += 2
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExecutorExecutionSummary) Size() (n int) {
	var l int
	_ = l
	if m.TimeProcessedNs != nil {
		n += 1 + sovExecutor(uint64(*m.TimeProcessedNs))
	}
	if m.NumProducedRows != nil {
		n += 1 + sovExecutor(uint64(*m.NumProducedRows))
	}
	if m.NumIterations != nil {
		n += 1 + sovExecutor(uint64(*m.NumIterations))
	}
	if m.ExecutorId != nil {
		l = len(*m.ExecutorId)
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.Concurrency != nil {
		n += 1 + sovExecutor(uint64(*m.Concurrency))
	}
	if m.DetailInfo != nil {
		n += m.DetailInfo.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExecutorExecutionSummary_TiflashScanContext) Size() (n int) {
	var l int
	_ = l
	if m.TiflashScanContext != nil {
		l = m.TiflashScanContext.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	return n
}
func (m *TiFlashScanContext) Size() (n int) {
	var l int
	_ = l
	if m.TotalDmfileScannedPacks != nil {
		n += 1 + sovExecutor(uint64(*m.TotalDmfileScannedPacks))
	}
	if m.TotalDmfileSkippedPacks != nil {
		n += 1 + sovExecutor(uint64(*m.TotalDmfileSkippedPacks))
	}
	if m.TotalDmfileScannedRows != nil {
		n += 1 + sovExecutor(uint64(*m.TotalDmfileScannedRows))
	}
	if m.TotalDmfileSkippedRows != nil {
		n += 1 + sovExecutor(uint64(*m.TotalDmfileSkippedRows))
	}
	if m.TotalDmfileRoughSetIndexLoadTimeMs != nil {
		n += 1 + sovExecutor(uint64(*m.TotalDmfileRoughSetIndexLoadTimeMs))
	}
	if m.TotalDmfileReadTimeMs != nil {
		n += 1 + sovExecutor(uint64(*m.TotalDmfileReadTimeMs))
	}
	if m.TotalCreateSnapshotTimeMs != nil {
		n += 1 + sovExecutor(uint64(*m.TotalCreateSnapshotTimeMs))
	}
	if m.TotalLocalRegionNum != nil {
		n += 1 + sovExecutor(uint64(*m.TotalLocalRegionNum))
	}
	if m.TotalRemoteRegionNum != nil {
		n += 1 + sovExecutor(uint64(*m.TotalRemoteRegionNum))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Sort) Size() (n int) {
	var l int
	_ = l
	if len(m.ByItems) > 0 {
		for _, e := range m.ByItems {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if m.IsPartialSort != nil {
		n += 2
	}
	if m.Child != nil {
		l = m.Child.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WindowFrameBound) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovExecutor(uint64(m.Type))
	n += 2
	if m.Offset != nil {
		n += 1 + sovExecutor(uint64(*m.Offset))
	}
	if len(m.CalcFuncs) > 0 {
		for _, e := range m.CalcFuncs {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WindowFrame) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovExecutor(uint64(m.Type))
	if m.Start != nil {
		l = m.Start.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.End != nil {
		l = m.End.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Window) Size() (n int) {
	var l int
	_ = l
	if len(m.FuncDesc) > 0 {
		for _, e := range m.FuncDesc {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.PartitionBy) > 0 {
		for _, e := range m.PartitionBy {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.OrderBy) > 0 {
		for _, e := range m.OrderBy {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if m.Frame != nil {
		l = m.Frame.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.Child != nil {
		l = m.Child.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GroupingExpr) Size() (n int) {
	var l int
	_ = l
	if len(m.GroupingExpr) > 0 {
		for _, e := range m.GroupingExpr {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GroupingSet) Size() (n int) {
	var l int
	_ = l
	if len(m.GroupingExprs) > 0 {
		for _, e := range m.GroupingExprs {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Expand) Size() (n int) {
	var l int
	_ = l
	if len(m.GroupingSets) > 0 {
		for _, e := range m.GroupingSets {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if m.Child != nil {
		l = m.Child.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.Version != nil {
		n += 1 + sovExecutor(uint64(*m.Version))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovExecutor(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozExecutor(x uint64) (n int) {
	return sovExecutor(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Executor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Executor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Executor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tp", wireType)
			}
			m.Tp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tp |= (ExecType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TblScan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TblScan == nil {
				m.TblScan = &TableScan{}
			}
			if err := m.TblScan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdxScan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdxScan == nil {
				m.IdxScan = &IndexScan{}
			}
			if err := m.IdxScan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Selection == nil {
				m.Selection = &Selection{}
			}
			if err := m.Selection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggregation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aggregation == nil {
				m.Aggregation = &Aggregation{}
			}
			if err := m.Aggregation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopN", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TopN == nil {
				m.TopN = &TopN{}
			}
			if err := m.TopN.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Limit == nil {
				m.Limit = &Limit{}
			}
			if err := m.Limit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeReceiver", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExchangeReceiver == nil {
				m.ExchangeReceiver = &ExchangeReceiver{}
			}
			if err := m.ExchangeReceiver.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Join", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Join == nil {
				m.Join = &Join{}
			}
			if err := m.Join.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ExecutorId = &s
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kill", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Kill == nil {
				m.Kill = &Kill{}
			}
			if err := m.Kill.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeSender", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExchangeSender == nil {
				m.ExchangeSender = &ExchangeSender{}
			}
			if err := m.ExchangeSender.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Projection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Projection == nil {
				m.Projection = &Projection{}
			}
			if err := m.Projection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionTableScan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PartitionTableScan == nil {
				m.PartitionTableScan = &PartitionTableScan{}
			}
			if err := m.PartitionTableScan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sort == nil {
				m.Sort = &Sort{}
			}
			if err := m.Sort.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Window", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Window == nil {
				m.Window = &Window{}
			}
			if err := m.Window.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FineGrainedShuffleStreamCount", wireType)
			}
			m.FineGrainedShuffleStreamCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FineGrainedShuffleStreamCount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FineGrainedShuffleBatchSize", wireType)
			}
			m.FineGrainedShuffleBatchSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FineGrainedShuffleBatchSize |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expand", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expand == nil {
				m.Expand = &Expand{}
			}
			if err := m.Expand.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExchangeSender) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExchangeSender: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExchangeSender: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tp", wireType)
			}
			m.Tp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tp |= (ExchangeType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncodedTaskMeta", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncodedTaskMeta = append(m.EncodedTaskMeta, make([]byte, postIndex-iNdEx))
			copy(m.EncodedTaskMeta[len(m.EncodedTaskMeta)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionKeys = append(m.PartitionKeys, &Expr{})
			if err := m.PartitionKeys[len(m.PartitionKeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Child", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Child == nil {
				m.Child = &Executor{}
			}
			if err := m.Child.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, &FieldType{})
			if err := m.Types[len(m.Types)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllFieldTypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllFieldTypes = append(m.AllFieldTypes, &FieldType{})
			if err := m.AllFieldTypes[len(m.AllFieldTypes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compression", wireType)
			}
			m.Compression = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Compression |= (CompressionMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExchangeReceiver) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExchangeReceiver: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExchangeReceiver: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncodedTaskMeta", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncodedTaskMeta = append(m.EncodedTaskMeta, make([]byte, postIndex-iNdEx))
			copy(m.EncodedTaskMeta[len(m.EncodedTaskMeta)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldTypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FieldTypes = append(m.FieldTypes, &FieldType{})
			if err := m.FieldTypes[len(m.FieldTypes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tp", wireType)
			}
			var v ExchangeType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (ExchangeType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Tp = &v
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableScan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableScan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableScan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &ColumnInfo{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Desc = bool(v != 0)
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PrimaryColumnIds = append(m.PrimaryColumnIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExecutor
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExecutor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PrimaryColumnIds = append(m.PrimaryColumnIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryColumnIds", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextReadEngine", wireType)
			}
			m.NextReadEngine = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextReadEngine |= (EngineType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ranges = append(m.Ranges, KeyRange{})
			if err := m.Ranges[len(m.Ranges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PrimaryPrefixColumnIds = append(m.PrimaryPrefixColumnIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExecutor
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExecutor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PrimaryPrefixColumnIds = append(m.PrimaryPrefixColumnIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryPrefixColumnIds", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeepOrder", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.KeepOrder = &b
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFastScan", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsFastScan = &b
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushedDownFilterConditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PushedDownFilterConditions = append(m.PushedDownFilterConditions, &Expr{})
			if err := m.PushedDownFilterConditions[len(m.PushedDownFilterConditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionTableScan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionTableScan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionTableScan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &ColumnInfo{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Desc = bool(v != 0)
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PrimaryColumnIds = append(m.PrimaryColumnIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExecutor
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExecutor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PrimaryColumnIds = append(m.PrimaryColumnIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryColumnIds", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PrimaryPrefixColumnIds = append(m.PrimaryPrefixColumnIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExecutor
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExecutor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PrimaryPrefixColumnIds = append(m.PrimaryPrefixColumnIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryPrefixColumnIds", wireType)
			}
		case 6:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PartitionIds = append(m.PartitionIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExecutor
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExecutor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PartitionIds = append(m.PartitionIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionIds", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFastScan", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsFastScan = &b
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushedDownFilterConditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PushedDownFilterConditions = append(m.PushedDownFilterConditions, &Expr{})
			if err := m.PushedDownFilterConditions[len(m.PushedDownFilterConditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Join) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Join: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Join: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinType", wireType)
			}
			m.JoinType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinType |= (JoinType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinExecType", wireType)
			}
			m.JoinExecType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinExecType |= (JoinExecType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &Executor{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InnerIdx", wireType)
			}
			m.InnerIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InnerIdx |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftJoinKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeftJoinKeys = append(m.LeftJoinKeys, &Expr{})
			if err := m.LeftJoinKeys[len(m.LeftJoinKeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightJoinKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RightJoinKeys = append(m.RightJoinKeys, &Expr{})
			if err := m.RightJoinKeys[len(m.RightJoinKeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProbeTypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProbeTypes = append(m.ProbeTypes, &FieldType{})
			if err := m.ProbeTypes[len(m.ProbeTypes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildTypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildTypes = append(m.BuildTypes, &FieldType{})
			if err := m.BuildTypes[len(m.BuildTypes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftConditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeftConditions = append(m.LeftConditions, &Expr{})
			if err := m.LeftConditions[len(m.LeftConditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightConditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RightConditions = append(m.RightConditions, &Expr{})
			if err := m.RightConditions[len(m.RightConditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherConditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OtherConditions = append(m.OtherConditions, &Expr{})
			if err := m.OtherConditions[len(m.OtherConditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherEqConditionsFromIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OtherEqConditionsFromIn = append(m.OtherEqConditionsFromIn, &Expr{})
			if err := m.OtherEqConditionsFromIn[len(m.OtherEqConditionsFromIn)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNullAwareSemiJoin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsNullAwareSemiJoin = &b
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexScan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexScan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexScan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			m.IndexId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &ColumnInfo{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Desc = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unique", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Unique = &b
		case 6:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PrimaryColumnIds = append(m.PrimaryColumnIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExecutor
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExecutor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PrimaryColumnIds = append(m.PrimaryColumnIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryColumnIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Selection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Selection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Selection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &Expr{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpnConditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RpnConditions = append(m.RpnConditions, &RpnExpr{})
			if err := m.RpnConditions[len(m.RpnConditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Child", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Child == nil {
				m.Child = &Executor{}
			}
			if err := m.Child.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Projection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Projection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Projection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exprs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exprs = append(m.Exprs, &Expr{})
			if err := m.Exprs[len(m.Exprs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpnExprs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RpnExprs = append(m.RpnExprs, &RpnExpr{})
			if err := m.RpnExprs[len(m.RpnExprs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Child", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Child == nil {
				m.Child = &Executor{}
			}
			if err := m.Child.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Aggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Aggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Aggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupBy = append(m.GroupBy, &Expr{})
			if err := m.GroupBy[len(m.GroupBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggFunc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AggFunc = append(m.AggFunc, &Expr{})
			if err := m.AggFunc[len(m.AggFunc)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Streamed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Streamed = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpnGroupBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RpnGroupBy = append(m.RpnGroupBy, &RpnExpr{})
			if err := m.RpnGroupBy[len(m.RpnGroupBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpnAggFunc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RpnAggFunc = append(m.RpnAggFunc, &RpnExpr{})
			if err := m.RpnAggFunc[len(m.RpnAggFunc)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Child", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Child == nil {
				m.Child = &Executor{}
			}
			if err := m.Child.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopN) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopN: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopN: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderBy = append(m.OrderBy, &ByItem{})
			if err := m.OrderBy[len(m.OrderBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Child", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Child == nil {
				m.Child = &Executor{}
			}
			if err := m.Child.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionBy = append(m.PartitionBy, &ByItem{})
			if err := m.PartitionBy[len(m.PartitionBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Limit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Limit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Limit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Child", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Child == nil {
				m.Child = &Executor{}
			}
			if err := m.Child.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionBy = append(m.PartitionBy, &ByItem{})
			if err := m.PartitionBy[len(m.PartitionBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Kill) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Kill: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Kill: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnID", wireType)
			}
			m.ConnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Query = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecutorExecutionSummary) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecutorExecutionSummary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecutorExecutionSummary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeProcessedNs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimeProcessedNs = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumProducedRows", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NumProducedRows = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumIterations", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NumIterations = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ExecutorId = &s
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Concurrency", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Concurrency = &v
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TiflashScanContext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TiFlashScanContext{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DetailInfo = &ExecutorExecutionSummary_TiflashScanContext{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TiFlashScanContext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TiFlashScanContext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TiFlashScanContext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDmfileScannedPacks", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalDmfileScannedPacks = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDmfileSkippedPacks", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalDmfileSkippedPacks = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDmfileScannedRows", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalDmfileScannedRows = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDmfileSkippedRows", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalDmfileSkippedRows = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDmfileRoughSetIndexLoadTimeMs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalDmfileRoughSetIndexLoadTimeMs = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDmfileReadTimeMs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalDmfileReadTimeMs = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCreateSnapshotTimeMs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalCreateSnapshotTimeMs = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalLocalRegionNum", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalLocalRegionNum = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRemoteRegionNum", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalRemoteRegionNum = &v
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sort) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sort: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sort: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ByItems = append(m.ByItems, &ByItem{})
			if err := m.ByItems[len(m.ByItems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPartialSort", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsPartialSort = &b
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Child", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Child == nil {
				m.Child = &Executor{}
			}
			if err := m.Child.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WindowFrameBound) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WindowFrameBound: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WindowFrameBound: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (WindowBoundType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unbounded", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Unbounded = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Offset = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CalcFuncs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CalcFuncs = append(m.CalcFuncs, &Expr{})
			if err := m.CalcFuncs[len(m.CalcFuncs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WindowFrame) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WindowFrame: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WindowFrame: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (WindowFrameType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Start == nil {
				m.Start = &WindowFrameBound{}
			}
			if err := m.Start.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.End == nil {
				m.End = &WindowFrameBound{}
			}
			if err := m.End.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Window) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Window: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Window: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FuncDesc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FuncDesc = append(m.FuncDesc, &Expr{})
			if err := m.FuncDesc[len(m.FuncDesc)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionBy = append(m.PartitionBy, &ByItem{})
			if err := m.PartitionBy[len(m.PartitionBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderBy = append(m.OrderBy, &ByItem{})
			if err := m.OrderBy[len(m.OrderBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frame", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Frame == nil {
				m.Frame = &WindowFrame{}
			}
			if err := m.Frame.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Child", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Child == nil {
				m.Child = &Executor{}
			}
			if err := m.Child.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupingExpr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupingExpr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupingExpr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupingExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupingExpr = append(m.GroupingExpr, &Expr{})
			if err := m.GroupingExpr[len(m.GroupingExpr)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupingSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupingSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupingSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupingExprs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupingExprs = append(m.GroupingExprs, &GroupingExpr{})
			if err := m.GroupingExprs[len(m.GroupingExprs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Expand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Expand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Expand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupingSets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupingSets = append(m.GroupingSets, &GroupingSet{})
			if err := m.GroupingSets[len(m.GroupingSets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Child", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Child == nil {
				m.Child = &Executor{}
			}
			if err := m.Child.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Version = &v
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipExecutor(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthExecutor
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowExecutor
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipExecutor(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthExecutor = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowExecutor   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("executor.proto", fileDescriptorExecutor) }

var fileDescriptorExecutor = []byte{
	// 2628 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0xcf, 0x73, 0xdb, 0xc6,
	0xf5, 0x17, 0xf8, 0x9b, 0x8f, 0x14, 0x09, 0xad, 0x65, 0x07, 0x76, 0xbe, 0xb6, 0x15, 0x7e, 0x9d,
	0x46, 0xd1, 0xa4, 0x8e, 0x63, 0x27, 0x6d, 0x32, 0x99, 0x34, 0xb1, 0x64, 0x29, 0x56, 0x6c, 0xcb,
	0x1a, 0x50, 0x6d, 0x8f, 0x18, 0x08, 0x58, 0x52, 0x6b, 0x81, 0xbb, 0x30, 0xb0, 0x88, 0x24, 0x9f,
	0x7a, 0xe9, 0x5f, 0xd0, 0x4e, 0xa7, 0xd3, 0x63, 0x6f, 0xbd, 0xf4, 0xd4, 0xce, 0xf4, 0xde, 0x4b,
	0x8e, 0xbd, 0xb6, 0x9d, 0xc9, 0x74, 0xd2, 0xff, 0xa2, 0xa7, 0xce, 0xbe, 0x5d, 0x80, 0xa0, 0x48,
	0x2b, 0xf6, 0xad, 0x27, 0x12, 0xef, 0x7d, 0x3e, 0x6f, 0xdf, 0xbe, 0xb7, 0xfb, 0xf6, 0xed, 0x42,
	0x8f, 0x9e, 0xd2, 0x20, 0x93, 0x22, 0xb9, 0x1d, 0x27, 0x42, 0x0a, 0x52, 0x93, 0x2c, 0x3e, 0xbc,
	0x66, 0xd3, 0xd3, 0x38, 0xa1, 0x69, 0xca, 0x04, 0xd7, 0xf2, 0x6b, 0xdd, 0x34, 0x38, 0xa2, 0x13,
	0xdf, 0x7c, 0xad, 0x8e, 0xc5, 0x58, 0xe0, 0xdf, 0xf7, 0xd5, 0x3f, 0x2d, 0x1d, 0xfc, 0xae, 0x09,
	0xad, 0x6d, 0x63, 0x8e, 0xdc, 0x82, 0x8a, 0x8c, 0x1d, 0x6b, 0xcd, 0x5a, 0xef, 0xdd, 0xed, 0xdd,
	0x56, 0x56, 0x6f, 0x2b, 0xdd, 0xc1, 0x59, 0x4c, 0x37, 0x6b, 0xdf, 0x7c, 0x7b, 0x73, 0xc9, 0xad,
	0xc8, 0x98, 0x6c, 0x40, 0x4b, 0x1e, 0x46, 0x5e, 0x1a, 0xf8, 0xdc, 0xa9, 0xac, 0x59, 0xeb, 0x9d,
	0xbb, 0x7d, 0x8d, 0x3d, 0xf0, 0x0f, 0x23, 0x3a, 0x0c, 0x7c, 0xee, 0x36, 0xe5, 0x61, 0xa4, 0xfe,
	0x28, 0x2c, 0x0b, 0x4f, 0x35, 0xb6, 0x5a, 0xc6, 0xee, 0xf2, 0x90, 0x9e, 0x6a, 0x2c, 0x0b, 0xf1,
	0x0f, 0xf9, 0x21, 0xb4, 0x53, 0x1a, 0xd1, 0x40, 0x32, 0xc1, 0x9d, 0x5a, 0x19, 0x3c, 0xcc, 0xc5,
	0xee, 0x14, 0x41, 0xee, 0x41, 0xc7, 0x1f, 0x8f, 0x13, 0x3a, 0xf6, 0x91, 0x50, 0x47, 0xc2, 0x8a,
	0x26, 0xdc, 0x9f, 0x2a, 0xdc, 0x32, 0x8a, 0xdc, 0x80, 0x9a, 0x14, 0xf1, 0x9e, 0xd3, 0x40, 0x34,
	0x18, 0xbf, 0x45, 0xbc, 0xe7, 0xa2, 0x9c, 0xbc, 0x05, 0xf5, 0x88, 0x4d, 0x98, 0x74, 0x9a, 0x08,
	0xe8, 0x68, 0xc0, 0x63, 0x25, 0x72, 0xb5, 0x86, 0x6c, 0xc1, 0x0a, 0x3d, 0x0d, 0x8e, 0x7c, 0x3e,
	0xa6, 0x5e, 0x42, 0x03, 0xca, 0xbe, 0xa6, 0x89, 0xd3, 0x42, 0xf8, 0x95, 0x3c, 0x66, 0x5a, 0xed,
	0x1a, 0xad, 0x6b, 0xd3, 0x73, 0x12, 0xe5, 0xc7, 0x33, 0xc1, 0xb8, 0xd3, 0x2e, 0xfb, 0xf1, 0x95,
	0x60, 0xdc, 0x45, 0x39, 0xb9, 0x09, 0x9d, 0x3c, 0xc9, 0x1e, 0x0b, 0x1d, 0x58, 0xb3, 0xd6, 0xdb,
	0x2e, 0xe4, 0xa2, 0xdd, 0x50, 0x19, 0x38, 0x66, 0x51, 0xe4, 0x74, 0xca, 0x06, 0x1e, 0xb1, 0x28,
	0x72, 0x51, 0x4e, 0x3e, 0x83, 0x7e, 0xe1, 0x65, 0x4a, 0x79, 0x48, 0x13, 0xa7, 0x8b, 0xd0, 0xd5,
	0x59, 0x1f, 0x87, 0xa8, 0x73, 0x7b, 0x74, 0xe6, 0x9b, 0xdc, 0x01, 0xd8, 0x4f, 0xc4, 0x33, 0x93,
	0x8c, 0x65, 0x64, 0xda, 0x9a, 0x39, 0x95, 0xbb, 0x25, 0x0c, 0xf9, 0x0a, 0x56, 0x63, 0x3f, 0x91,
	0x4c, 0x7d, 0x78, 0x52, 0xad, 0x04, 0x9d, 0xf5, 0x1e, 0x72, 0x1d, 0xc3, 0xcd, 0x11, 0xd3, 0xa5,
	0x42, 0xe2, 0x39, 0x99, 0x9a, 0x5c, 0x2a, 0x12, 0xe9, 0xf4, 0xcb, 0x93, 0x1b, 0x8a, 0x44, 0xba,
	0x28, 0x27, 0xb7, 0xa0, 0x71, 0xc2, 0x78, 0x28, 0x4e, 0x1c, 0x1b, 0x11, 0x5d, 0x8d, 0xf8, 0x39,
	0xca, 0x5c, 0xa3, 0x23, 0x7b, 0xf0, 0xd6, 0x88, 0x71, 0xea, 0x8d, 0x13, 0x9f, 0x71, 0x1a, 0x7a,
	0xe9, 0x51, 0x36, 0x1a, 0x29, 0xb7, 0x64, 0x42, 0xfd, 0x89, 0x17, 0x88, 0x8c, 0x4b, 0x67, 0x65,
	0xcd, 0x5a, 0xaf, 0x99, 0xc5, 0x7d, 0x5d, 0xc1, 0xbf, 0xd4, 0xe8, 0xa1, 0x06, 0x0f, 0x11, 0xbb,
	0xa5, 0xa0, 0xe4, 0x2b, 0xb8, 0xb9, 0xd0, 0xde, 0xa1, 0x2f, 0x83, 0x23, 0x2f, 0x65, 0x2f, 0xa8,
	0x43, 0x4a, 0xd6, 0xde, 0x9c, 0xb7, 0xb6, 0xa9, 0x90, 0x43, 0xf6, 0x82, 0xaa, 0x19, 0xd0, 0xd3,
	0xd8, 0xe7, 0xa1, 0x73, 0xa9, 0x3c, 0x83, 0x6d, 0x94, 0xb9, 0x46, 0x37, 0xf8, 0xb6, 0x02, 0xbd,
	0xd9, 0x44, 0x91, 0xf5, 0xd2, 0x16, 0x25, 0xb3, 0xa9, 0x9c, 0xdb, 0xa6, 0x2b, 0x94, 0x07, 0x22,
	0xa4, 0xa1, 0x27, 0xfd, 0xf4, 0xd8, 0x9b, 0x50, 0xe9, 0x3b, 0x95, 0xb5, 0xea, 0x7a, 0xd7, 0xed,
	0x1b, 0xc5, 0x81, 0x9f, 0x1e, 0x3f, 0xa1, 0xd2, 0x27, 0x1f, 0x40, 0x6f, 0x9a, 0xbc, 0x63, 0x7a,
	0x96, 0x3a, 0xd5, 0xb5, 0xea, 0x34, 0xf4, 0xdb, 0xa7, 0x71, 0xe2, 0x2e, 0x17, 0x88, 0x47, 0xf4,
	0x2c, 0x25, 0xb7, 0xa0, 0x1e, 0x1c, 0xb1, 0x28, 0x34, 0x3b, 0xb5, 0x54, 0x2e, 0xd4, 0x0a, 0x75,
	0xb5, 0x92, 0xbc, 0x0d, 0x75, 0x79, 0x16, 0xd3, 0xd4, 0xa9, 0xa3, 0x3d, 0xb3, 0x9f, 0x77, 0x18,
	0x8d, 0x42, 0xe5, 0xae, 0xab, 0xb5, 0xe4, 0xc7, 0xd0, 0xf7, 0xa3, 0xc8, 0x1b, 0x29, 0xb9, 0xa7,
	0x09, 0x8d, 0xc5, 0x84, 0x65, 0x3f, 0x8a, 0x8a, 0xaf, 0x94, 0x7c, 0x06, 0x9d, 0x40, 0x4c, 0xf2,
	0xba, 0x87, 0xbb, 0xb6, 0x77, 0xf7, 0xb2, 0x26, 0x6d, 0x4d, 0x15, 0x4f, 0x44, 0x98, 0x87, 0xa6,
	0x8c, 0x1f, 0xfc, 0xda, 0x02, 0xfb, 0xfc, 0x6e, 0x5d, 0x1c, 0x38, 0x6b, 0x71, 0xe0, 0xee, 0x40,
	0xa7, 0xec, 0x74, 0x65, 0xb1, 0xd3, 0x30, 0x9a, 0x7a, 0x3c, 0xc0, 0x04, 0x56, 0x5f, 0x96, 0x40,
	0x95, 0xba, 0xc1, 0x3f, 0xab, 0xd0, 0x9e, 0xee, 0x86, 0x9b, 0xd0, 0xd2, 0xfb, 0x89, 0x85, 0x98,
	0xf8, 0xaa, 0x99, 0x49, 0x13, 0xa5, 0xbb, 0x21, 0xd9, 0x80, 0x66, 0x20, 0xa2, 0x6c, 0xc2, 0x73,
	0x07, 0xec, 0x3c, 0x00, 0x4a, 0xb8, 0xcb, 0x47, 0xc2, 0xcd, 0x01, 0xc4, 0x81, 0x5a, 0x48, 0xd3,
	0x00, 0x1d, 0x68, 0x19, 0x43, 0x28, 0x21, 0xef, 0x01, 0x89, 0x13, 0x36, 0xf1, 0x93, 0x33, 0x4f,
	0x83, 0x3d, 0x16, 0xa6, 0x4e, 0x6d, 0xad, 0xba, 0x5e, 0x75, 0x6d, 0xa3, 0x31, 0x16, 0xc3, 0x94,
	0x7c, 0x01, 0x36, 0xa7, 0xa7, 0xd2, 0x4b, 0xa8, 0x1f, 0x7a, 0x94, 0x8f, 0x19, 0xa7, 0x58, 0x82,
	0x7b, 0xf9, 0xe0, 0xdb, 0x28, 0x2b, 0xad, 0xc9, 0x9e, 0xc2, 0xbb, 0xd4, 0x0f, 0xb5, 0x86, 0xbc,
	0x07, 0x8d, 0x44, 0xcd, 0x3a, 0x4f, 0xb5, 0x59, 0x41, 0x8f, 0xe8, 0x99, 0xab, 0xc4, 0x86, 0x65,
	0x30, 0xe4, 0x13, 0xb8, 0x9a, 0x7b, 0x17, 0x27, 0x74, 0xc4, 0x4e, 0xcb, 0x4e, 0x36, 0xd1, 0xc9,
	0x2b, 0x06, 0xb0, 0x8f, 0xfa, 0xa9, 0xab, 0xd7, 0x01, 0x8e, 0x29, 0x8d, 0x3d, 0x91, 0x84, 0xa6,
	0x52, 0xb7, 0xdc, 0xb6, 0x92, 0x3c, 0x55, 0x02, 0xb2, 0x06, 0x5d, 0x96, 0x7a, 0x23, 0x3f, 0x95,
	0xba, 0x60, 0xb5, 0x11, 0x00, 0x2c, 0xdd, 0xf1, 0x53, 0x89, 0x09, 0x78, 0x02, 0xd7, 0xe3, 0x2c,
	0x3d, 0xa2, 0xa1, 0x17, 0x8a, 0x13, 0xee, 0x8d, 0x58, 0x24, 0x69, 0xe2, 0x05, 0x82, 0x87, 0xb8,
	0x1d, 0x52, 0x07, 0xe6, 0x36, 0xcb, 0x35, 0x4d, 0x78, 0x20, 0x4e, 0xf8, 0x0e, 0xc2, 0xb7, 0x0a,
	0xf4, 0xe0, 0x3f, 0x15, 0x20, 0xf3, 0x85, 0xf0, 0x7f, 0x33, 0xcd, 0x17, 0x86, 0xbd, 0x7e, 0x61,
	0xd8, 0xff, 0x1f, 0xa6, 0x15, 0x03, 0xe1, 0x0d, 0x84, 0x77, 0x0b, 0xa1, 0x02, 0x9d, 0x0f, 0x7e,
	0xf3, 0xf5, 0x83, 0xdf, 0x7a, 0xad, 0xe0, 0xff, 0xb9, 0x0e, 0x35, 0x75, 0xce, 0x92, 0x0f, 0xa0,
	0xad, 0x4e, 0x5a, 0xdc, 0xb8, 0xb3, 0x2d, 0x8f, 0x52, 0x97, 0xd6, 0x6d, 0xeb, 0x99, 0xf9, 0x26,
	0x3f, 0x81, 0x1e, 0x52, 0xd4, 0x31, 0xac, 0x79, 0x95, 0xf2, 0x36, 0x56, 0xbc, 0x73, 0xed, 0x52,
	0xf7, 0x59, 0x49, 0xa6, 0x9a, 0x21, 0xac, 0x8a, 0x09, 0xe5, 0xa6, 0xbe, 0x9e, 0xaf, 0x9a, 0x85,
	0x9e, 0xbc, 0x05, 0x6d, 0xc6, 0x39, 0x55, 0xa7, 0xff, 0x29, 0x96, 0xd8, 0x7c, 0x39, 0xb4, 0x50,
	0xbc, 0x1b, 0x9e, 0x92, 0x3b, 0xd0, 0x8b, 0xe8, 0x48, 0x7a, 0xe8, 0x13, 0x16, 0xed, 0xfa, 0x5c,
	0x28, 0xba, 0x0a, 0xa1, 0x1c, 0xc3, 0x9a, 0x7d, 0x17, 0xfa, 0x09, 0x1b, 0x1f, 0x95, 0x29, 0x8d,
	0xf9, 0x3a, 0x8f, 0x90, 0x82, 0x73, 0x07, 0x3a, 0x71, 0x22, 0x0e, 0xa9, 0xa9, 0x70, 0xcd, 0x97,
	0x54, 0x38, 0xc4, 0xe8, 0x0a, 0x77, 0x07, 0x3a, 0x87, 0x19, 0x2b, 0x6a, 0x62, 0xeb, 0x25, 0x0c,
	0xc4, 0x68, 0xc6, 0x3d, 0xe8, 0xe3, 0x4c, 0x4a, 0x59, 0x6d, 0xcf, 0xf9, 0x85, 0x93, 0x9d, 0x66,
	0x92, 0x7c, 0x04, 0xb6, 0x9e, 0xcc, 0x85, 0x1b, 0x51, 0x4f, 0x78, 0x96, 0x26, 0xe4, 0xd1, 0xec,
	0x12, 0xea, 0xcc, 0xd3, 0x10, 0x53, 0xa2, 0x3d, 0x84, 0x37, 0x35, 0x8d, 0x3e, 0x2f, 0x31, 0xbd,
	0x51, 0x22, 0x26, 0x1e, 0xe3, 0x4e, 0x77, 0xce, 0xc2, 0x1b, 0x08, 0xdf, 0x7e, 0x3e, 0xb5, 0xb1,
	0x93, 0x88, 0xc9, 0x2e, 0x27, 0x1f, 0xc2, 0x1b, 0x2c, 0xf5, 0x78, 0x16, 0x45, 0x9e, 0x7f, 0xe2,
	0x27, 0xaa, 0x3d, 0x9b, 0x30, 0xcc, 0x08, 0xf6, 0x59, 0x2d, 0xf7, 0x12, 0x4b, 0xf7, 0xb2, 0x28,
	0xba, 0xaf, 0x94, 0x43, 0x3a, 0x61, 0x2a, 0x15, 0x83, 0xbf, 0x5b, 0xd0, 0x2e, 0x7a, 0xe6, 0xef,
	0xaf, 0x15, 0x37, 0xa1, 0xc5, 0x14, 0x5a, 0x01, 0x2a, 0x65, 0x00, 0x4a, 0x67, 0x8b, 0x49, 0xf5,
	0x55, 0x8b, 0x49, 0x6d, 0xae, 0x98, 0x5c, 0x81, 0x46, 0xc6, 0xd9, 0xf3, 0x4c, 0xd7, 0xfe, 0x96,
	0x6b, 0xbe, 0x5e, 0x52, 0x64, 0x1a, 0x8b, 0x8b, 0xcc, 0xe0, 0x57, 0x16, 0xb4, 0x8b, 0x16, 0x9f,
	0x6c, 0x00, 0x94, 0x52, 0x63, 0xcd, 0x05, 0xb6, 0xa4, 0x25, 0x1f, 0x42, 0x2f, 0x89, 0x79, 0x39,
	0x95, 0xba, 0x32, 0x2e, 0x6b, 0xbc, 0x1b, 0x73, 0xb3, 0xa4, 0x63, 0x5e, 0xca, 0x65, 0xd1, 0xba,
	0x54, 0x2f, 0x68, 0x5d, 0x06, 0xbf, 0xb0, 0xca, 0x3d, 0x30, 0x59, 0x83, 0xba, 0xba, 0x60, 0x2d,
	0xf2, 0x48, 0x2b, 0xc8, 0x06, 0xb4, 0x95, 0x33, 0x1a, 0xb5, 0xd0, 0x8f, 0x56, 0xa2, 0xff, 0xbc,
	0xaa, 0x0b, 0xbf, 0xac, 0x40, 0xa7, 0x74, 0x95, 0x21, 0x6f, 0x43, 0x6b, 0x9c, 0x88, 0x2c, 0xf6,
	0x0e, 0xcf, 0x16, 0xb8, 0xd1, 0x44, 0xdd, 0xe6, 0x99, 0x82, 0xf9, 0xe3, 0xb1, 0x37, 0xca, 0x78,
	0x60, 0xfc, 0x98, 0x81, 0xf9, 0xe3, 0xf1, 0x4e, 0xc6, 0x03, 0xb2, 0x06, 0x2d, 0xdd, 0x0a, 0xd3,
	0x70, 0xe6, 0x9c, 0x28, 0xa4, 0xe4, 0x7d, 0xe8, 0xaa, 0x19, 0x15, 0x63, 0xd6, 0x16, 0x4d, 0x0a,
	0x92, 0x98, 0x7f, 0x69, 0x46, 0x36, 0x84, 0x62, 0xf4, 0xfa, 0xcb, 0x08, 0xf7, 0x8d, 0x0f, 0x45,
	0x1c, 0x1a, 0x17, 0xc5, 0xe1, 0xf7, 0x16, 0xd4, 0xd4, 0x25, 0x8d, 0xbc, 0x03, 0x2d, 0x3c, 0xc5,
	0xa7, 0x01, 0x30, 0x8d, 0xf3, 0xe6, 0xd9, 0xae, 0xa4, 0x13, 0xb7, 0x89, 0xda, 0xcd, 0x33, 0x72,
	0x2d, 0xbf, 0xc7, 0x55, 0x4a, 0x1d, 0xb9, 0xb9, 0xc0, 0xbd, 0x52, 0xec, 0xd5, 0x54, 0xa6, 0xc7,
	0x57, 0x31, 0xf7, 0xd9, 0xe1, 0x3a, 0x05, 0x62, 0xf3, 0x6c, 0xf0, 0x02, 0xea, 0x78, 0x4f, 0x9c,
	0x8e, 0x6d, 0x5d, 0x30, 0x76, 0xe5, 0x75, 0xc6, 0xae, 0x7e, 0xdf, 0xd8, 0x5f, 0x40, 0x4d, 0xdd,
	0xfd, 0xc8, 0xff, 0x41, 0x23, 0x10, 0x9c, 0xef, 0x3e, 0x98, 0x19, 0xdb, 0xc8, 0x94, 0x63, 0xcf,
	0x33, 0x9a, 0x9c, 0xe1, 0xe0, 0x79, 0xb6, 0xb5, 0x68, 0xf0, 0x97, 0x0a, 0x38, 0xb9, 0x1b, 0xfa,
	0x97, 0x09, 0x3e, 0xcc, 0x26, 0x6a, 0xa7, 0xaa, 0x8e, 0x58, 0xb2, 0x09, 0xf5, 0xe2, 0x44, 0x04,
	0x34, 0x4d, 0x69, 0xe8, 0xe1, 0xce, 0xb4, 0xd6, 0x6b, 0x6e, 0x5f, 0x29, 0xf6, 0x73, 0xf9, 0x9e,
	0xda, 0x05, 0x2b, 0x3c, 0x9b, 0x28, 0x68, 0x98, 0x05, 0x34, 0xf4, 0x12, 0x71, 0x92, 0xea, 0x2c,
	0xb8, 0x7d, 0x9e, 0x4d, 0xf6, 0x8d, 0xdc, 0x15, 0x27, 0x29, 0x79, 0x1b, 0x7a, 0x0a, 0xcb, 0x24,
	0x4d, 0x7c, 0xbd, 0x7d, 0xab, 0x08, 0x5c, 0xe6, 0xd9, 0x64, 0xb7, 0x10, 0x9e, 0xbf, 0x0c, 0xd7,
	0xe6, 0x2e, 0xc3, 0x6b, 0xea, 0x16, 0xc0, 0x83, 0x2c, 0x49, 0x28, 0x0f, 0xce, 0xb0, 0x16, 0xd5,
	0xdc, 0xb2, 0x88, 0x3c, 0x86, 0x55, 0xc9, 0x46, 0x91, 0x9f, 0x1e, 0x61, 0x9f, 0xa1, 0x2a, 0x86,
	0xa4, 0xa7, 0xd2, 0x2c, 0x3b, 0x73, 0x3b, 0x3d, 0x60, 0x3b, 0x0a, 0xa1, 0x2a, 0xec, 0x96, 0xd6,
	0x3f, 0x5c, 0x72, 0x89, 0xe1, 0x95, 0xa4, 0x9b, 0x5d, 0x80, 0x07, 0x54, 0xfa, 0x2c, 0x52, 0x75,
	0x72, 0xf0, 0xd7, 0x1a, 0x90, 0x79, 0x2a, 0xf9, 0x14, 0xae, 0x49, 0x21, 0xfd, 0xc8, 0x0b, 0x27,
	0x23, 0x66, 0x6e, 0xc3, 0xea, 0xda, 0x18, 0xfb, 0xc1, 0x71, 0x1e, 0xbd, 0x37, 0x10, 0xf1, 0x00,
	0x01, 0x43, 0xad, 0xdf, 0x57, 0xea, 0x79, 0xf2, 0x31, 0x8b, 0xe3, 0x82, 0x5c, 0x99, 0x27, 0x6b,
	0xbd, 0x26, 0x7f, 0x02, 0x57, 0x17, 0x8e, 0x8c, 0xa9, 0xd0, 0x11, 0xbe, 0x32, 0x3f, 0x30, 0x66,
	0x64, 0x8e, 0x6a, 0xc6, 0x45, 0x6a, 0x6d, 0x9e, 0xaa, 0xd5, 0x48, 0xfd, 0x29, 0xbc, 0x3b, 0x43,
	0x4d, 0x44, 0x36, 0x3e, 0xf2, 0x52, 0x2a, 0x3d, 0x7d, 0x12, 0x45, 0xc2, 0x0f, 0x3d, 0x5c, 0x46,
	0x93, 0xd4, 0xa4, 0x68, 0x50, 0x32, 0xe5, 0x2a, 0xf8, 0x90, 0x4a, 0x3c, 0xe4, 0x1e, 0x0b, 0x3f,
	0x3c, 0x60, 0x13, 0xfa, 0x24, 0x25, 0x1f, 0x9f, 0xf3, 0x08, 0x2f, 0x1c, 0xb9, 0x99, 0x06, 0x9a,
	0xb9, 0x5c, 0x36, 0x43, 0x0b, 0xe6, 0x17, 0x70, 0x5d, 0x33, 0x83, 0x84, 0xfa, 0x92, 0x7a, 0x29,
	0xf7, 0xe3, 0xf4, 0x48, 0xc8, 0x82, 0xdd, 0x44, 0xb6, 0x36, 0xbf, 0x85, 0x98, 0xa1, 0x81, 0x18,
	0x0b, 0xf7, 0x40, 0x4f, 0xd6, 0x8b, 0x44, 0xe0, 0x47, 0x5e, 0x42, 0xc7, 0x6a, 0x43, 0xf2, 0x6c,
	0x82, 0xb7, 0x88, 0x9a, 0x7b, 0x09, 0xb5, 0x8f, 0x95, 0xd2, 0x45, 0xdd, 0x5e, 0x36, 0x21, 0x1f,
	0x81, 0x4e, 0x8c, 0x97, 0xd0, 0x89, 0x90, 0xb4, 0xcc, 0x6a, 0x23, 0x6b, 0x15, 0xd5, 0x2e, 0x6a,
	0x0b, 0xda, 0xe0, 0x05, 0xd4, 0x86, 0x22, 0x91, 0xe4, 0x07, 0xd0, 0x3c, 0xc4, 0x1d, 0x9e, 0x2e,
	0xae, 0x70, 0x46, 0x49, 0x6e, 0xc1, 0x32, 0x4b, 0xf1, 0x1a, 0xe1, 0x47, 0x8a, 0xa8, 0x37, 0xb5,
	0x3b, 0x2b, 0x7c, 0xc5, 0x73, 0xe6, 0x0f, 0x16, 0xd8, 0xfa, 0xf1, 0x64, 0x27, 0xf1, 0x27, 0x74,
	0x53, 0x64, 0x5c, 0x15, 0xa1, 0x5a, 0xa9, 0x37, 0xbe, 0x5c, 0x7e, 0x62, 0x41, 0x40, 0xa9, 0xcd,
	0x45, 0x20, 0x19, 0x40, 0x3b, 0xe3, 0x87, 0x4a, 0x45, 0xc3, 0x99, 0x12, 0x33, 0x15, 0xab, 0x86,
	0x41, 0x8c, 0x46, 0x29, 0x95, 0x66, 0x1d, 0x9a, 0x2f, 0xb2, 0x0e, 0xed, 0xc0, 0x8f, 0x02, 0x75,
	0x26, 0xa4, 0xa6, 0xd4, 0x96, 0xcf, 0xac, 0xa9, 0x72, 0xf0, 0x1b, 0x0b, 0x3a, 0x25, 0x5f, 0x2f,
	0x72, 0x13, 0x01, 0x73, 0x6e, 0xbe, 0x07, 0xf5, 0x54, 0xfa, 0x26, 0x60, 0xc5, 0x9b, 0xdd, 0xf9,
	0xe9, 0xbb, 0x1a, 0x44, 0xd6, 0xa1, 0x4a, 0x79, 0x1e, 0xbe, 0x97, 0x61, 0x15, 0x64, 0xf0, 0x0f,
	0x0b, 0x1a, 0x5a, 0x43, 0xde, 0x81, 0xb6, 0x3a, 0xfe, 0x3c, 0xec, 0x9a, 0xe6, 0x0f, 0xea, 0x96,
	0x52, 0x3e, 0x50, 0xfd, 0xd3, 0xf9, 0x42, 0x5f, 0xf9, 0x9e, 0x42, 0x3f, 0x73, 0x00, 0x56, 0x2f,
	0x3a, 0x00, 0xdf, 0x81, 0xfa, 0x48, 0x39, 0x68, 0x9e, 0x67, 0x56, 0xe6, 0x3c, 0x77, 0xb5, 0x7e,
	0xba, 0x42, 0xea, 0x17, 0xad, 0x90, 0xcf, 0xa1, 0x8b, 0x67, 0x3c, 0xe3, 0x63, 0x35, 0x05, 0xf2,
	0x3e, 0x2c, 0x8f, 0xcd, 0x37, 0x36, 0x3c, 0x0b, 0x66, 0xd9, 0x1d, 0x97, 0x08, 0x83, 0x87, 0xd0,
	0xc9, 0x0d, 0x0c, 0xa9, 0x24, 0x9f, 0x40, 0x6f, 0x86, 0x9f, 0x2f, 0x76, 0x73, 0x95, 0x2a, 0x8f,
	0xe5, 0x2e, 0x97, 0x0d, 0xa5, 0xaa, 0x2f, 0x6b, 0xe8, 0x77, 0x32, 0xf2, 0xa3, 0x92, 0x17, 0x29,
	0x95, 0xb9, 0x91, 0x95, 0x59, 0x23, 0x43, 0x2a, 0xa7, 0xce, 0x0c, 0xa9, 0x4c, 0x5f, 0xf1, 0x14,
	0x76, 0xa0, 0xf9, 0x35, 0x4d, 0xf0, 0x5d, 0x49, 0x2f, 0xd6, 0xfc, 0x73, 0xe3, 0x4f, 0x15, 0xfd,
	0x68, 0x8e, 0xb7, 0xba, 0x15, 0x58, 0x56, 0xbf, 0xc5, 0x45, 0xde, 0x5e, 0xca, 0x45, 0x45, 0xbf,
	0x6e, 0x5b, 0xb9, 0xa8, 0x68, 0x73, 0xed, 0x0a, 0xb9, 0x04, 0x7d, 0x25, 0x2a, 0x35, 0x78, 0x76,
	0x95, 0x74, 0xa1, 0x85, 0xd6, 0x44, 0xbc, 0x67, 0xd7, 0xc8, 0x32, 0xb4, 0xd5, 0x17, 0xf6, 0x15,
	0x76, 0xbd, 0x30, 0x82, 0xfd, 0xd9, 0xfd, 0xf1, 0xd8, 0x6e, 0xe4, 0x78, 0x75, 0x47, 0xb0, 0x9b,
	0xf9, 0x97, 0xea, 0x05, 0xec, 0x16, 0xb9, 0x02, 0x44, 0x7d, 0xcd, 0xbe, 0x20, 0xda, 0x6d, 0xe2,
	0xc0, 0x6a, 0x59, 0x9e, 0x3f, 0x7c, 0xd9, 0x40, 0x08, 0xf4, 0x94, 0x66, 0xda, 0xf6, 0xda, 0x1d,
	0x72, 0x0d, 0xae, 0xa0, 0x6c, 0xee, 0xc5, 0xc2, 0xee, 0xe6, 0xe3, 0xa9, 0x52, 0x63, 0x2f, 0x93,
	0x1e, 0x80, 0xfa, 0xd2, 0x8b, 0xcc, 0xee, 0xe5, 0xdf, 0x3a, 0x59, 0x76, 0x7f, 0xe3, 0x63, 0xe8,
	0x96, 0x9f, 0xba, 0x48, 0x1f, 0x3a, 0xfb, 0x7e, 0x9a, 0x1e, 0x1c, 0xe1, 0x51, 0x61, 0x2f, 0xa9,
	0xe9, 0x6e, 0x26, 0xc2, 0x0f, 0x03, 0x3f, 0x95, 0xb6, 0x45, 0x5a, 0x50, 0x7b, 0xe8, 0xa7, 0x47,
	0x76, 0x65, 0xe3, 0x53, 0xe8, 0x9f, 0x7b, 0xcd, 0x53, 0xca, 0xbd, 0xa7, 0x7b, 0xdb, 0xf6, 0x92,
	0xfa, 0xb7, 0x73, 0x7f, 0x78, 0x60, 0x5b, 0x64, 0x15, 0xec, 0x87, 0xbb, 0x5f, 0x3e, 0xf4, 0xb6,
	0x9e, 0x3e, 0xd9, 0x77, 0xb7, 0x87, 0xc3, 0xdd, 0xa7, 0x7b, 0x76, 0x65, 0xe3, 0x36, 0xc0, 0xf4,
	0x31, 0x8a, 0xb4, 0xa1, 0x8e, 0x05, 0x5b, 0x13, 0x0f, 0xd8, 0xa3, 0x9f, 0xd9, 0x16, 0xe9, 0x40,
	0xd3, 0x9c, 0xe0, 0x76, 0x65, 0xe3, 0x8f, 0x16, 0xb4, 0xf2, 0x37, 0x80, 0x69, 0x2a, 0x39, 0x4d,
	0x30, 0xc8, 0x4b, 0xe4, 0x32, 0xac, 0x60, 0x52, 0xe8, 0x48, 0x3e, 0xcd, 0xa4, 0x11, 0x5b, 0x79,
	0xb4, 0x5d, 0x75, 0xdf, 0x9c, 0xca, 0x2b, 0xc4, 0x86, 0xae, 0xce, 0xbc, 0xbe, 0xc9, 0xd9, 0x55,
	0xe5, 0x26, 0x26, 0x9e, 0x4b, 0x56, 0x48, 0x6b, 0xe4, 0x2a, 0x5c, 0x9e, 0x31, 0x5b, 0xa8, 0xea,
	0xe4, 0x3a, 0x5c, 0xcd, 0x09, 0xf3, 0xea, 0xc6, 0xc6, 0x1a, 0x74, 0xcb, 0x6f, 0x0f, 0xf9, 0x88,
	0x2a, 0x76, 0xda, 0xe5, 0x8d, 0xcf, 0xa1, 0x7f, 0xae, 0x72, 0xab, 0x58, 0xef, 0x88, 0x28, 0x12,
	0x27, 0x8c, 0x8f, 0x75, 0xe8, 0xf7, 0x13, 0x1a, 0xd0, 0x50, 0x7d, 0x5a, 0x2a, 0x75, 0x5b, 0xd8,
	0x3b, 0x49, 0x57, 0x9c, 0xd8, 0x95, 0x8d, 0x7b, 0xb9, 0x81, 0xa2, 0xa6, 0xaa, 0xe8, 0xa9, 0x73,
	0xdf, 0x5e, 0x22, 0x00, 0x0d, 0x7c, 0xb2, 0x4b, 0x6d, 0x4b, 0xfd, 0xc7, 0x7d, 0x97, 0xda, 0x95,
	0xcd, 0x77, 0xbf, 0xf9, 0xee, 0x86, 0xf5, 0xb7, 0xef, 0x6e, 0x58, 0xff, 0xfa, 0xee, 0x86, 0xf5,
	0xdb, 0x7f, 0xdf, 0x58, 0x82, 0xcb, 0x81, 0x98, 0xdc, 0x56, 0xdb, 0x30, 0xf0, 0xe3, 0xdb, 0x92,
	0x85, 0x87, 0xb8, 0xf3, 0xf6, 0xad, 0xff, 0x06, 0x00, 0x00, 0xff, 0xff, 0xd7, 0x17, 0x60, 0x13,
	0xd3, 0x1a, 0x00, 0x00,
}
