// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: executor.proto

package tipb

import (
	encoding_binary "encoding/binary"
	"fmt"
	"io"
	"math"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"

	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ExecType int32

const (
	ExecType_TypeTableScan          ExecType = 0
	ExecType_TypeIndexScan          ExecType = 1
	ExecType_TypeSelection          ExecType = 2
	ExecType_TypeAggregation        ExecType = 3
	ExecType_TypeTopN               ExecType = 4
	ExecType_TypeLimit              ExecType = 5
	ExecType_TypeStreamAgg          ExecType = 6
	ExecType_TypeJoin               ExecType = 7
	ExecType_TypeKill               ExecType = 8
	ExecType_TypeExchangeSender     ExecType = 9
	ExecType_TypeExchangeReceiver   ExecType = 10
	ExecType_TypeProjection         ExecType = 11
	ExecType_TypePartitionTableScan ExecType = 12
	ExecType_TypeSort               ExecType = 13
	ExecType_TypeWindow             ExecType = 14
	ExecType_TypeExpand             ExecType = 15
	ExecType_TypeExpand2            ExecType = 16
)

var ExecType_name = map[int32]string{
	0:  "TypeTableScan",
	1:  "TypeIndexScan",
	2:  "TypeSelection",
	3:  "TypeAggregation",
	4:  "TypeTopN",
	5:  "TypeLimit",
	6:  "TypeStreamAgg",
	7:  "TypeJoin",
	8:  "TypeKill",
	9:  "TypeExchangeSender",
	10: "TypeExchangeReceiver",
	11: "TypeProjection",
	12: "TypePartitionTableScan",
	13: "TypeSort",
	14: "TypeWindow",
	15: "TypeExpand",
	16: "TypeExpand2",
}

var ExecType_value = map[string]int32{
	"TypeTableScan":          0,
	"TypeIndexScan":          1,
	"TypeSelection":          2,
	"TypeAggregation":        3,
	"TypeTopN":               4,
	"TypeLimit":              5,
	"TypeStreamAgg":          6,
	"TypeJoin":               7,
	"TypeKill":               8,
	"TypeExchangeSender":     9,
	"TypeExchangeReceiver":   10,
	"TypeProjection":         11,
	"TypePartitionTableScan": 12,
	"TypeSort":               13,
	"TypeWindow":             14,
	"TypeExpand":             15,
	"TypeExpand2":            16,
}

func (x ExecType) Enum() *ExecType {
	p := new(ExecType)
	*p = x
	return p
}

func (x ExecType) String() string {
	return proto.EnumName(ExecType_name, int32(x))
}

func (x *ExecType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ExecType_value, data, "ExecType")
	if err != nil {
		return err
	}
	*x = ExecType(value)
	return nil
}

func (ExecType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{0}
}

type ExchangeType int32

const (
	ExchangeType_PassThrough ExchangeType = 0
	ExchangeType_Broadcast   ExchangeType = 1
	ExchangeType_Hash        ExchangeType = 2
)

var ExchangeType_name = map[int32]string{
	0: "PassThrough",
	1: "Broadcast",
	2: "Hash",
}

var ExchangeType_value = map[string]int32{
	"PassThrough": 0,
	"Broadcast":   1,
	"Hash":        2,
}

func (x ExchangeType) Enum() *ExchangeType {
	p := new(ExchangeType)
	*p = x
	return p
}

func (x ExchangeType) String() string {
	return proto.EnumName(ExchangeType_name, int32(x))
}

func (x *ExchangeType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ExchangeType_value, data, "ExchangeType")
	if err != nil {
		return err
	}
	*x = ExchangeType(value)
	return nil
}

func (ExchangeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{1}
}

// Data compression mode
type CompressionMode int32

const (
	CompressionMode_NONE             CompressionMode = 0
	CompressionMode_FAST             CompressionMode = 1
	CompressionMode_HIGH_COMPRESSION CompressionMode = 2
)

var CompressionMode_name = map[int32]string{
	0: "NONE",
	1: "FAST",
	2: "HIGH_COMPRESSION",
}

var CompressionMode_value = map[string]int32{
	"NONE":             0,
	"FAST":             1,
	"HIGH_COMPRESSION": 2,
}

func (x CompressionMode) Enum() *CompressionMode {
	p := new(CompressionMode)
	*p = x
	return p
}

func (x CompressionMode) String() string {
	return proto.EnumName(CompressionMode_name, int32(x))
}

func (x *CompressionMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CompressionMode_value, data, "CompressionMode")
	if err != nil {
		return err
	}
	*x = CompressionMode(value)
	return nil
}

func (CompressionMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{2}
}

type EngineType int32

const (
	EngineType_Local   EngineType = 0
	EngineType_TiKV    EngineType = 1
	EngineType_TiFlash EngineType = 2
)

var EngineType_name = map[int32]string{
	0: "Local",
	1: "TiKV",
	2: "TiFlash",
}

var EngineType_value = map[string]int32{
	"Local":   0,
	"TiKV":    1,
	"TiFlash": 2,
}

func (x EngineType) Enum() *EngineType {
	p := new(EngineType)
	*p = x
	return p
}

func (x EngineType) String() string {
	return proto.EnumName(EngineType_name, int32(x))
}

func (x *EngineType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EngineType_value, data, "EngineType")
	if err != nil {
		return err
	}
	*x = EngineType(value)
	return nil
}

func (EngineType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{3}
}

// Note: The name of the enum is intentionally aligned with tidb/parser/index_vector.go.
type VectorIndexKind int32

const (
	VectorIndexKind_INVALID_INDEX_KIND VectorIndexKind = 0
	VectorIndexKind_HNSW               VectorIndexKind = 1
)

var VectorIndexKind_name = map[int32]string{
	0: "INVALID_INDEX_KIND",
	1: "HNSW",
}

var VectorIndexKind_value = map[string]int32{
	"INVALID_INDEX_KIND": 0,
	"HNSW":               1,
}

func (x VectorIndexKind) Enum() *VectorIndexKind {
	p := new(VectorIndexKind)
	*p = x
	return p
}

func (x VectorIndexKind) String() string {
	return proto.EnumName(VectorIndexKind_name, int32(x))
}

func (x *VectorIndexKind) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VectorIndexKind_value, data, "VectorIndexKind")
	if err != nil {
		return err
	}
	*x = VectorIndexKind(value)
	return nil
}

func (VectorIndexKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{4}
}

// Note: The name of the enum is intentionally aligned with tidb/parser/index_vector.go.
type VectorDistanceMetric int32

const (
	VectorDistanceMetric_INVALID_DISTANCE_METRIC VectorDistanceMetric = 0
	VectorDistanceMetric_L1                      VectorDistanceMetric = 1
	VectorDistanceMetric_L2                      VectorDistanceMetric = 2
	VectorDistanceMetric_COSINE                  VectorDistanceMetric = 3
	VectorDistanceMetric_INNER_PRODUCT           VectorDistanceMetric = 4
)

var VectorDistanceMetric_name = map[int32]string{
	0: "INVALID_DISTANCE_METRIC",
	1: "L1",
	2: "L2",
	3: "COSINE",
	4: "INNER_PRODUCT",
}

var VectorDistanceMetric_value = map[string]int32{
	"INVALID_DISTANCE_METRIC": 0,
	"L1":                      1,
	"L2":                      2,
	"COSINE":                  3,
	"INNER_PRODUCT":           4,
}

func (x VectorDistanceMetric) Enum() *VectorDistanceMetric {
	p := new(VectorDistanceMetric)
	*p = x
	return p
}

func (x VectorDistanceMetric) String() string {
	return proto.EnumName(VectorDistanceMetric_name, int32(x))
}

func (x *VectorDistanceMetric) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VectorDistanceMetric_value, data, "VectorDistanceMetric")
	if err != nil {
		return err
	}
	*x = VectorDistanceMetric(value)
	return nil
}

func (VectorDistanceMetric) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{5}
}

type ANNQueryType int32

const (
	ANNQueryType_InvalidQueryType ANNQueryType = 0
	ANNQueryType_OrderBy          ANNQueryType = 1
)

var ANNQueryType_name = map[int32]string{
	0: "InvalidQueryType",
	1: "OrderBy",
}

var ANNQueryType_value = map[string]int32{
	"InvalidQueryType": 0,
	"OrderBy":          1,
}

func (x ANNQueryType) Enum() *ANNQueryType {
	p := new(ANNQueryType)
	*p = x
	return p
}

func (x ANNQueryType) String() string {
	return proto.EnumName(ANNQueryType_name, int32(x))
}

func (x *ANNQueryType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ANNQueryType_value, data, "ANNQueryType")
	if err != nil {
		return err
	}
	*x = ANNQueryType(value)
	return nil
}

func (ANNQueryType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{6}
}

type ColumnarIndexType int32

const (
	ColumnarIndexType_TypeInvalid  ColumnarIndexType = 0
	ColumnarIndexType_TypeVector   ColumnarIndexType = 1
	ColumnarIndexType_TypeInverted ColumnarIndexType = 2
)

var ColumnarIndexType_name = map[int32]string{
	0: "TypeInvalid",
	1: "TypeVector",
	2: "TypeInverted",
}

var ColumnarIndexType_value = map[string]int32{
	"TypeInvalid":  0,
	"TypeVector":   1,
	"TypeInverted": 2,
}

func (x ColumnarIndexType) Enum() *ColumnarIndexType {
	p := new(ColumnarIndexType)
	*p = x
	return p
}

func (x ColumnarIndexType) String() string {
	return proto.EnumName(ColumnarIndexType_name, int32(x))
}

func (x *ColumnarIndexType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ColumnarIndexType_value, data, "ColumnarIndexType")
	if err != nil {
		return err
	}
	*x = ColumnarIndexType(value)
	return nil
}

func (ColumnarIndexType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{7}
}

type JoinType int32

const (
	JoinType_TypeInnerJoin             JoinType = 0
	JoinType_TypeLeftOuterJoin         JoinType = 1
	JoinType_TypeRightOuterJoin        JoinType = 2
	JoinType_TypeSemiJoin              JoinType = 3
	JoinType_TypeAntiSemiJoin          JoinType = 4
	JoinType_TypeLeftOuterSemiJoin     JoinType = 5
	JoinType_TypeAntiLeftOuterSemiJoin JoinType = 6
)

var JoinType_name = map[int32]string{
	0: "TypeInnerJoin",
	1: "TypeLeftOuterJoin",
	2: "TypeRightOuterJoin",
	3: "TypeSemiJoin",
	4: "TypeAntiSemiJoin",
	5: "TypeLeftOuterSemiJoin",
	6: "TypeAntiLeftOuterSemiJoin",
}

var JoinType_value = map[string]int32{
	"TypeInnerJoin":             0,
	"TypeLeftOuterJoin":         1,
	"TypeRightOuterJoin":        2,
	"TypeSemiJoin":              3,
	"TypeAntiSemiJoin":          4,
	"TypeLeftOuterSemiJoin":     5,
	"TypeAntiLeftOuterSemiJoin": 6,
}

func (x JoinType) Enum() *JoinType {
	p := new(JoinType)
	*p = x
	return p
}

func (x JoinType) String() string {
	return proto.EnumName(JoinType_name, int32(x))
}

func (x *JoinType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(JoinType_value, data, "JoinType")
	if err != nil {
		return err
	}
	*x = JoinType(value)
	return nil
}

func (JoinType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{8}
}

type JoinExecType int32

const (
	JoinExecType_TypeHashJoin JoinExecType = 0
)

var JoinExecType_name = map[int32]string{
	0: "TypeHashJoin",
}

var JoinExecType_value = map[string]int32{
	"TypeHashJoin": 0,
}

func (x JoinExecType) Enum() *JoinExecType {
	p := new(JoinExecType)
	*p = x
	return p
}

func (x JoinExecType) String() string {
	return proto.EnumName(JoinExecType_name, int32(x))
}

func (x *JoinExecType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(JoinExecType_value, data, "JoinExecType")
	if err != nil {
		return err
	}
	*x = JoinExecType(value)
	return nil
}

func (JoinExecType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{9}
}

type RuntimeFilterType int32

const (
	RuntimeFilterType_IN           RuntimeFilterType = 0
	RuntimeFilterType_MIN_MAX      RuntimeFilterType = 1
	RuntimeFilterType_BLOOM_FILTER RuntimeFilterType = 2
)

var RuntimeFilterType_name = map[int32]string{
	0: "IN",
	1: "MIN_MAX",
	2: "BLOOM_FILTER",
}

var RuntimeFilterType_value = map[string]int32{
	"IN":           0,
	"MIN_MAX":      1,
	"BLOOM_FILTER": 2,
}

func (x RuntimeFilterType) Enum() *RuntimeFilterType {
	p := new(RuntimeFilterType)
	*p = x
	return p
}

func (x RuntimeFilterType) String() string {
	return proto.EnumName(RuntimeFilterType_name, int32(x))
}

func (x *RuntimeFilterType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(RuntimeFilterType_value, data, "RuntimeFilterType")
	if err != nil {
		return err
	}
	*x = RuntimeFilterType(value)
	return nil
}

func (RuntimeFilterType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{10}
}

type RuntimeFilterMode int32

const (
	RuntimeFilterMode_LOCAL  RuntimeFilterMode = 0
	RuntimeFilterMode_GLOBAL RuntimeFilterMode = 1
)

var RuntimeFilterMode_name = map[int32]string{
	0: "LOCAL",
	1: "GLOBAL",
}

var RuntimeFilterMode_value = map[string]int32{
	"LOCAL":  0,
	"GLOBAL": 1,
}

func (x RuntimeFilterMode) Enum() *RuntimeFilterMode {
	p := new(RuntimeFilterMode)
	*p = x
	return p
}

func (x RuntimeFilterMode) String() string {
	return proto.EnumName(RuntimeFilterMode_name, int32(x))
}

func (x *RuntimeFilterMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(RuntimeFilterMode_value, data, "RuntimeFilterMode")
	if err != nil {
		return err
	}
	*x = RuntimeFilterMode(value)
	return nil
}

func (RuntimeFilterMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{11}
}

type TiFlashPreAggMode int32

const (
	TiFlashPreAggMode_ForcePreAgg    TiFlashPreAggMode = 0
	TiFlashPreAggMode_Auto           TiFlashPreAggMode = 1
	TiFlashPreAggMode_ForceStreaming TiFlashPreAggMode = 2
)

var TiFlashPreAggMode_name = map[int32]string{
	0: "ForcePreAgg",
	1: "Auto",
	2: "ForceStreaming",
}

var TiFlashPreAggMode_value = map[string]int32{
	"ForcePreAgg":    0,
	"Auto":           1,
	"ForceStreaming": 2,
}

func (x TiFlashPreAggMode) Enum() *TiFlashPreAggMode {
	p := new(TiFlashPreAggMode)
	*p = x
	return p
}

func (x TiFlashPreAggMode) String() string {
	return proto.EnumName(TiFlashPreAggMode_name, int32(x))
}

func (x *TiFlashPreAggMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TiFlashPreAggMode_value, data, "TiFlashPreAggMode")
	if err != nil {
		return err
	}
	*x = TiFlashPreAggMode(value)
	return nil
}

func (TiFlashPreAggMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{12}
}

type WindowBoundType int32

const (
	WindowBoundType_Following  WindowBoundType = 0
	WindowBoundType_Preceding  WindowBoundType = 1
	WindowBoundType_CurrentRow WindowBoundType = 2
)

var WindowBoundType_name = map[int32]string{
	0: "Following",
	1: "Preceding",
	2: "CurrentRow",
}

var WindowBoundType_value = map[string]int32{
	"Following":  0,
	"Preceding":  1,
	"CurrentRow": 2,
}

func (x WindowBoundType) Enum() *WindowBoundType {
	p := new(WindowBoundType)
	*p = x
	return p
}

func (x WindowBoundType) String() string {
	return proto.EnumName(WindowBoundType_name, int32(x))
}

func (x *WindowBoundType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(WindowBoundType_value, data, "WindowBoundType")
	if err != nil {
		return err
	}
	*x = WindowBoundType(value)
	return nil
}

func (WindowBoundType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{13}
}

// Used for range frame's comparison when finding frame's boundary
type RangeCmpDataType int32

const (
	RangeCmpDataType_Int      RangeCmpDataType = 0
	RangeCmpDataType_Float    RangeCmpDataType = 1
	RangeCmpDataType_Decimal  RangeCmpDataType = 2
	RangeCmpDataType_DateTime RangeCmpDataType = 3
	RangeCmpDataType_Duration RangeCmpDataType = 4
)

var RangeCmpDataType_name = map[int32]string{
	0: "Int",
	1: "Float",
	2: "Decimal",
	3: "DateTime",
	4: "Duration",
}

var RangeCmpDataType_value = map[string]int32{
	"Int":      0,
	"Float":    1,
	"Decimal":  2,
	"DateTime": 3,
	"Duration": 4,
}

func (x RangeCmpDataType) Enum() *RangeCmpDataType {
	p := new(RangeCmpDataType)
	*p = x
	return p
}

func (x RangeCmpDataType) String() string {
	return proto.EnumName(RangeCmpDataType_name, int32(x))
}

func (x *RangeCmpDataType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(RangeCmpDataType_value, data, "RangeCmpDataType")
	if err != nil {
		return err
	}
	*x = RangeCmpDataType(value)
	return nil
}

func (RangeCmpDataType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{14}
}

type WindowFrameType int32

const (
	WindowFrameType_Rows   WindowFrameType = 0
	WindowFrameType_Ranges WindowFrameType = 1
	WindowFrameType_Groups WindowFrameType = 2
)

var WindowFrameType_name = map[int32]string{
	0: "Rows",
	1: "Ranges",
	2: "Groups",
}

var WindowFrameType_value = map[string]int32{
	"Rows":   0,
	"Ranges": 1,
	"Groups": 2,
}

func (x WindowFrameType) Enum() *WindowFrameType {
	p := new(WindowFrameType)
	*p = x
	return p
}

func (x WindowFrameType) String() string {
	return proto.EnumName(WindowFrameType_name, int32(x))
}

func (x *WindowFrameType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(WindowFrameType_value, data, "WindowFrameType")
	if err != nil {
		return err
	}
	*x = WindowFrameType(value)
	return nil
}

func (WindowFrameType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{15}
}

// It represents a Executor.
type Executor struct {
	Tp                            ExecType            `protobuf:"varint,1,opt,name=tp,enum=tipb.ExecType" json:"tp"`
	TblScan                       *TableScan          `protobuf:"bytes,2,opt,name=tbl_scan,json=tblScan" json:"tbl_scan,omitempty"`
	IdxScan                       *IndexScan          `protobuf:"bytes,3,opt,name=idx_scan,json=idxScan" json:"idx_scan,omitempty"`
	Selection                     *Selection          `protobuf:"bytes,4,opt,name=selection" json:"selection,omitempty"`
	Aggregation                   *Aggregation        `protobuf:"bytes,5,opt,name=aggregation" json:"aggregation,omitempty"`
	TopN                          *TopN               `protobuf:"bytes,6,opt,name=topN" json:"topN,omitempty"`
	Limit                         *Limit              `protobuf:"bytes,7,opt,name=limit" json:"limit,omitempty"`
	ExchangeReceiver              *ExchangeReceiver   `protobuf:"bytes,8,opt,name=exchange_receiver,json=exchangeReceiver" json:"exchange_receiver,omitempty"`
	Join                          *Join               `protobuf:"bytes,9,opt,name=join" json:"join,omitempty"`
	ExecutorId                    *string             `protobuf:"bytes,10,opt,name=executor_id,json=executorId" json:"executor_id,omitempty"`
	Kill                          *Kill               `protobuf:"bytes,11,opt,name=kill" json:"kill,omitempty"`
	ExchangeSender                *ExchangeSender     `protobuf:"bytes,12,opt,name=exchange_sender,json=exchangeSender" json:"exchange_sender,omitempty"`
	Projection                    *Projection         `protobuf:"bytes,13,opt,name=Projection" json:"Projection,omitempty"`
	PartitionTableScan            *PartitionTableScan `protobuf:"bytes,14,opt,name=partition_table_scan,json=partitionTableScan" json:"partition_table_scan,omitempty"`
	Sort                          *Sort               `protobuf:"bytes,15,opt,name=sort" json:"sort,omitempty"`
	Window                        *Window             `protobuf:"bytes,16,opt,name=window" json:"window,omitempty"`
	FineGrainedShuffleStreamCount uint64              `protobuf:"varint,17,opt,name=fine_grained_shuffle_stream_count,json=fineGrainedShuffleStreamCount" json:"fine_grained_shuffle_stream_count"`
	FineGrainedShuffleBatchSize   uint64              `protobuf:"varint,18,opt,name=fine_grained_shuffle_batch_size,json=fineGrainedShuffleBatchSize" json:"fine_grained_shuffle_batch_size"`
	Expand                        *Expand             `protobuf:"bytes,19,opt,name=expand" json:"expand,omitempty"`
	Expand2                       *Expand2            `protobuf:"bytes,20,opt,name=expand2" json:"expand2,omitempty"`
}

func (m *Executor) Reset()         { *m = Executor{} }
func (m *Executor) String() string { return proto.CompactTextString(m) }
func (*Executor) ProtoMessage()    {}
func (*Executor) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{0}
}
func (m *Executor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Executor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Executor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Executor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Executor.Merge(m, src)
}
func (m *Executor) XXX_Size() int {
	return m.Size()
}
func (m *Executor) XXX_DiscardUnknown() {
	xxx_messageInfo_Executor.DiscardUnknown(m)
}

var xxx_messageInfo_Executor proto.InternalMessageInfo

func (m *Executor) GetTp() ExecType {
	if m != nil {
		return m.Tp
	}
	return ExecType_TypeTableScan
}

func (m *Executor) GetTblScan() *TableScan {
	if m != nil {
		return m.TblScan
	}
	return nil
}

func (m *Executor) GetIdxScan() *IndexScan {
	if m != nil {
		return m.IdxScan
	}
	return nil
}

func (m *Executor) GetSelection() *Selection {
	if m != nil {
		return m.Selection
	}
	return nil
}

func (m *Executor) GetAggregation() *Aggregation {
	if m != nil {
		return m.Aggregation
	}
	return nil
}

func (m *Executor) GetTopN() *TopN {
	if m != nil {
		return m.TopN
	}
	return nil
}

func (m *Executor) GetLimit() *Limit {
	if m != nil {
		return m.Limit
	}
	return nil
}

func (m *Executor) GetExchangeReceiver() *ExchangeReceiver {
	if m != nil {
		return m.ExchangeReceiver
	}
	return nil
}

func (m *Executor) GetJoin() *Join {
	if m != nil {
		return m.Join
	}
	return nil
}

func (m *Executor) GetExecutorId() string {
	if m != nil && m.ExecutorId != nil {
		return *m.ExecutorId
	}
	return ""
}

func (m *Executor) GetKill() *Kill {
	if m != nil {
		return m.Kill
	}
	return nil
}

func (m *Executor) GetExchangeSender() *ExchangeSender {
	if m != nil {
		return m.ExchangeSender
	}
	return nil
}

func (m *Executor) GetProjection() *Projection {
	if m != nil {
		return m.Projection
	}
	return nil
}

func (m *Executor) GetPartitionTableScan() *PartitionTableScan {
	if m != nil {
		return m.PartitionTableScan
	}
	return nil
}

func (m *Executor) GetSort() *Sort {
	if m != nil {
		return m.Sort
	}
	return nil
}

func (m *Executor) GetWindow() *Window {
	if m != nil {
		return m.Window
	}
	return nil
}

func (m *Executor) GetFineGrainedShuffleStreamCount() uint64 {
	if m != nil {
		return m.FineGrainedShuffleStreamCount
	}
	return 0
}

func (m *Executor) GetFineGrainedShuffleBatchSize() uint64 {
	if m != nil {
		return m.FineGrainedShuffleBatchSize
	}
	return 0
}

func (m *Executor) GetExpand() *Expand {
	if m != nil {
		return m.Expand
	}
	return nil
}

func (m *Executor) GetExpand2() *Expand2 {
	if m != nil {
		return m.Expand2
	}
	return nil
}

// ExchangeSender will build connection with ExchangeReceiver.
type ExchangeSender struct {
	Tp                  ExchangeType         `protobuf:"varint,1,opt,name=tp,enum=tipb.ExchangeType" json:"tp"`
	EncodedTaskMeta     [][]byte             `protobuf:"bytes,2,rep,name=encoded_task_meta,json=encodedTaskMeta" json:"encoded_task_meta,omitempty"`
	PartitionKeys       []*Expr              `protobuf:"bytes,3,rep,name=partition_keys,json=partitionKeys" json:"partition_keys,omitempty"`
	Child               *Executor            `protobuf:"bytes,4,opt,name=child" json:"child,omitempty"`
	Types               []*FieldType         `protobuf:"bytes,5,rep,name=types" json:"types,omitempty"`
	AllFieldTypes       []*FieldType         `protobuf:"bytes,6,rep,name=all_field_types,json=allFieldTypes" json:"all_field_types,omitempty"`
	Compression         CompressionMode      `protobuf:"varint,7,opt,name=compression,enum=tipb.CompressionMode" json:"compression"`
	UpstreamCteTaskMeta []*EncodedBytesSlice `protobuf:"bytes,8,rep,name=upstream_cte_task_meta,json=upstreamCteTaskMeta" json:"upstream_cte_task_meta,omitempty"`
	SameZoneFlag        []bool               `protobuf:"varint,9,rep,name=same_zone_flag,json=sameZoneFlag" json:"same_zone_flag,omitempty"`
}

func (m *ExchangeSender) Reset()         { *m = ExchangeSender{} }
func (m *ExchangeSender) String() string { return proto.CompactTextString(m) }
func (*ExchangeSender) ProtoMessage()    {}
func (*ExchangeSender) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{1}
}
func (m *ExchangeSender) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExchangeSender) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExchangeSender.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExchangeSender) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExchangeSender.Merge(m, src)
}
func (m *ExchangeSender) XXX_Size() int {
	return m.Size()
}
func (m *ExchangeSender) XXX_DiscardUnknown() {
	xxx_messageInfo_ExchangeSender.DiscardUnknown(m)
}

var xxx_messageInfo_ExchangeSender proto.InternalMessageInfo

func (m *ExchangeSender) GetTp() ExchangeType {
	if m != nil {
		return m.Tp
	}
	return ExchangeType_PassThrough
}

func (m *ExchangeSender) GetEncodedTaskMeta() [][]byte {
	if m != nil {
		return m.EncodedTaskMeta
	}
	return nil
}

func (m *ExchangeSender) GetPartitionKeys() []*Expr {
	if m != nil {
		return m.PartitionKeys
	}
	return nil
}

func (m *ExchangeSender) GetChild() *Executor {
	if m != nil {
		return m.Child
	}
	return nil
}

func (m *ExchangeSender) GetTypes() []*FieldType {
	if m != nil {
		return m.Types
	}
	return nil
}

func (m *ExchangeSender) GetAllFieldTypes() []*FieldType {
	if m != nil {
		return m.AllFieldTypes
	}
	return nil
}

func (m *ExchangeSender) GetCompression() CompressionMode {
	if m != nil {
		return m.Compression
	}
	return CompressionMode_NONE
}

func (m *ExchangeSender) GetUpstreamCteTaskMeta() []*EncodedBytesSlice {
	if m != nil {
		return m.UpstreamCteTaskMeta
	}
	return nil
}

func (m *ExchangeSender) GetSameZoneFlag() []bool {
	if m != nil {
		return m.SameZoneFlag
	}
	return nil
}

type EncodedBytesSlice struct {
	EncodedTasks [][]byte `protobuf:"bytes,1,rep,name=encoded_tasks,json=encodedTasks" json:"encoded_tasks,omitempty"`
}

func (m *EncodedBytesSlice) Reset()         { *m = EncodedBytesSlice{} }
func (m *EncodedBytesSlice) String() string { return proto.CompactTextString(m) }
func (*EncodedBytesSlice) ProtoMessage()    {}
func (*EncodedBytesSlice) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{2}
}
func (m *EncodedBytesSlice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncodedBytesSlice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncodedBytesSlice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncodedBytesSlice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncodedBytesSlice.Merge(m, src)
}
func (m *EncodedBytesSlice) XXX_Size() int {
	return m.Size()
}
func (m *EncodedBytesSlice) XXX_DiscardUnknown() {
	xxx_messageInfo_EncodedBytesSlice.DiscardUnknown(m)
}

var xxx_messageInfo_EncodedBytesSlice proto.InternalMessageInfo

func (m *EncodedBytesSlice) GetEncodedTasks() [][]byte {
	if m != nil {
		return m.EncodedTasks
	}
	return nil
}

// ExchangeReceiver accept connection and receiver data from ExchangeSender.
type ExchangeReceiver struct {
	EncodedTaskMeta             [][]byte      `protobuf:"bytes,1,rep,name=encoded_task_meta,json=encodedTaskMeta" json:"encoded_task_meta,omitempty"`
	FieldTypes                  []*FieldType  `protobuf:"bytes,2,rep,name=field_types,json=fieldTypes" json:"field_types,omitempty"`
	Tp                          *ExchangeType `protobuf:"varint,3,opt,name=tp,enum=tipb.ExchangeType" json:"tp,omitempty"`
	OriginalCtePrdocuerTaskMeta [][]byte      `protobuf:"bytes,4,rep,name=original_cte_prdocuer_task_meta,json=originalCtePrdocuerTaskMeta" json:"original_cte_prdocuer_task_meta,omitempty"`
	SameZoneFlag                []bool        `protobuf:"varint,5,rep,name=same_zone_flag,json=sameZoneFlag" json:"same_zone_flag,omitempty"`
}

func (m *ExchangeReceiver) Reset()         { *m = ExchangeReceiver{} }
func (m *ExchangeReceiver) String() string { return proto.CompactTextString(m) }
func (*ExchangeReceiver) ProtoMessage()    {}
func (*ExchangeReceiver) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{3}
}
func (m *ExchangeReceiver) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExchangeReceiver) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExchangeReceiver.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExchangeReceiver) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExchangeReceiver.Merge(m, src)
}
func (m *ExchangeReceiver) XXX_Size() int {
	return m.Size()
}
func (m *ExchangeReceiver) XXX_DiscardUnknown() {
	xxx_messageInfo_ExchangeReceiver.DiscardUnknown(m)
}

var xxx_messageInfo_ExchangeReceiver proto.InternalMessageInfo

func (m *ExchangeReceiver) GetEncodedTaskMeta() [][]byte {
	if m != nil {
		return m.EncodedTaskMeta
	}
	return nil
}

func (m *ExchangeReceiver) GetFieldTypes() []*FieldType {
	if m != nil {
		return m.FieldTypes
	}
	return nil
}

func (m *ExchangeReceiver) GetTp() ExchangeType {
	if m != nil && m.Tp != nil {
		return *m.Tp
	}
	return ExchangeType_PassThrough
}

func (m *ExchangeReceiver) GetOriginalCtePrdocuerTaskMeta() [][]byte {
	if m != nil {
		return m.OriginalCtePrdocuerTaskMeta
	}
	return nil
}

func (m *ExchangeReceiver) GetSameZoneFlag() []bool {
	if m != nil {
		return m.SameZoneFlag
	}
	return nil
}

// ANN = Approximate Nearest Neighbor. For some queries, ANN index can be used.
type ANNQueryInfo struct {
	QueryType      ANNQueryType         `protobuf:"varint,1,opt,name=query_type,json=queryType,enum=tipb.ANNQueryType" json:"query_type"`
	DistanceMetric VectorDistanceMetric `protobuf:"varint,2,opt,name=distance_metric,json=distanceMetric,enum=tipb.VectorDistanceMetric" json:"distance_metric"`
	TopK           uint32               `protobuf:"varint,3,opt,name=top_k,json=topK" json:"top_k"`
	ColumnName     string               `protobuf:"bytes,4,opt,name=column_name,json=columnName" json:"column_name"`
	// deprecated field, we use column to get the id first, and this field will not be set again.
	// Retain this field to be compatible with older versions of TiDB
	DeprecatedColumnId *int64  `protobuf:"varint,5,opt,name=deprecated_column_id,json=deprecatedColumnId" json:"deprecated_column_id,omitempty"`
	RefVecF32          []byte  `protobuf:"bytes,6,opt,name=ref_vec_f32,json=refVecF32" json:"ref_vec_f32,omitempty"`
	IndexId            int64   `protobuf:"varint,8,opt,name=index_id,json=indexId" json:"index_id"`
	MaxDistance        float64 `protobuf:"fixed64,10,opt,name=max_distance,json=maxDistance" json:"max_distance"`
	HnswEfSearch       uint32  `protobuf:"varint,20,opt,name=hnsw_ef_search,json=hnswEfSearch" json:"hnsw_ef_search"`
	// Persists the original vector column's type information (including nullability)
	// to ensure correct data handling. This field is always populated with the column's
	// schema metadata, regardless of whether enable_distance_proj is enabled.
	Column ColumnInfo `protobuf:"bytes,21,opt,name=column" json:"column"`
	// If enabled, the content of TableScan's vector output column (whose ID is column.id) will be removed and
	// TableScan will read a distance column (whose id must be -2000) as replacement, TiFlash persistent layer
	// does not need to really read the Vector data column when index has been built.
	EnableDistanceProj bool `protobuf:"varint,22,opt,name=enable_distance_proj,json=enableDistanceProj" json:"enable_distance_proj"`
}

func (m *ANNQueryInfo) Reset()         { *m = ANNQueryInfo{} }
func (m *ANNQueryInfo) String() string { return proto.CompactTextString(m) }
func (*ANNQueryInfo) ProtoMessage()    {}
func (*ANNQueryInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{4}
}
func (m *ANNQueryInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ANNQueryInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ANNQueryInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ANNQueryInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ANNQueryInfo.Merge(m, src)
}
func (m *ANNQueryInfo) XXX_Size() int {
	return m.Size()
}
func (m *ANNQueryInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ANNQueryInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ANNQueryInfo proto.InternalMessageInfo

func (m *ANNQueryInfo) GetQueryType() ANNQueryType {
	if m != nil {
		return m.QueryType
	}
	return ANNQueryType_InvalidQueryType
}

func (m *ANNQueryInfo) GetDistanceMetric() VectorDistanceMetric {
	if m != nil {
		return m.DistanceMetric
	}
	return VectorDistanceMetric_INVALID_DISTANCE_METRIC
}

func (m *ANNQueryInfo) GetTopK() uint32 {
	if m != nil {
		return m.TopK
	}
	return 0
}

func (m *ANNQueryInfo) GetColumnName() string {
	if m != nil {
		return m.ColumnName
	}
	return ""
}

func (m *ANNQueryInfo) GetDeprecatedColumnId() int64 {
	if m != nil && m.DeprecatedColumnId != nil {
		return *m.DeprecatedColumnId
	}
	return 0
}

func (m *ANNQueryInfo) GetRefVecF32() []byte {
	if m != nil {
		return m.RefVecF32
	}
	return nil
}

func (m *ANNQueryInfo) GetIndexId() int64 {
	if m != nil {
		return m.IndexId
	}
	return 0
}

func (m *ANNQueryInfo) GetMaxDistance() float64 {
	if m != nil {
		return m.MaxDistance
	}
	return 0
}

func (m *ANNQueryInfo) GetHnswEfSearch() uint32 {
	if m != nil {
		return m.HnswEfSearch
	}
	return 0
}

func (m *ANNQueryInfo) GetColumn() ColumnInfo {
	if m != nil {
		return m.Column
	}
	return ColumnInfo{}
}

func (m *ANNQueryInfo) GetEnableDistanceProj() bool {
	if m != nil {
		return m.EnableDistanceProj
	}
	return false
}

type InvertedQueryInfo struct {
	IndexId  int64 `protobuf:"varint,1,opt,name=index_id,json=indexId" json:"index_id"`
	ColumnId int64 `protobuf:"varint,2,opt,name=column_id,json=columnId" json:"column_id"`
}

func (m *InvertedQueryInfo) Reset()         { *m = InvertedQueryInfo{} }
func (m *InvertedQueryInfo) String() string { return proto.CompactTextString(m) }
func (*InvertedQueryInfo) ProtoMessage()    {}
func (*InvertedQueryInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{5}
}
func (m *InvertedQueryInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InvertedQueryInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InvertedQueryInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InvertedQueryInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InvertedQueryInfo.Merge(m, src)
}
func (m *InvertedQueryInfo) XXX_Size() int {
	return m.Size()
}
func (m *InvertedQueryInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_InvertedQueryInfo.DiscardUnknown(m)
}

var xxx_messageInfo_InvertedQueryInfo proto.InternalMessageInfo

func (m *InvertedQueryInfo) GetIndexId() int64 {
	if m != nil {
		return m.IndexId
	}
	return 0
}

func (m *InvertedQueryInfo) GetColumnId() int64 {
	if m != nil {
		return m.ColumnId
	}
	return 0
}

type ColumnarIndexInfo struct {
	IndexType ColumnarIndexType `protobuf:"varint,1,opt,name=index_type,json=indexType,enum=tipb.ColumnarIndexType" json:"index_type"`
	// Types that are valid to be assigned to Index:
	//	*ColumnarIndexInfo_AnnQueryInfo
	//	*ColumnarIndexInfo_InvertQueryInfo
	Index isColumnarIndexInfo_Index `protobuf_oneof:"index"`
}

func (m *ColumnarIndexInfo) Reset()         { *m = ColumnarIndexInfo{} }
func (m *ColumnarIndexInfo) String() string { return proto.CompactTextString(m) }
func (*ColumnarIndexInfo) ProtoMessage()    {}
func (*ColumnarIndexInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{6}
}
func (m *ColumnarIndexInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnarIndexInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColumnarIndexInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ColumnarIndexInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnarIndexInfo.Merge(m, src)
}
func (m *ColumnarIndexInfo) XXX_Size() int {
	return m.Size()
}
func (m *ColumnarIndexInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnarIndexInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnarIndexInfo proto.InternalMessageInfo

type isColumnarIndexInfo_Index interface {
	isColumnarIndexInfo_Index()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ColumnarIndexInfo_AnnQueryInfo struct {
	AnnQueryInfo *ANNQueryInfo `protobuf:"bytes,2,opt,name=ann_query_info,json=annQueryInfo,oneof" json:"ann_query_info,omitempty"`
}
type ColumnarIndexInfo_InvertQueryInfo struct {
	InvertQueryInfo *InvertedQueryInfo `protobuf:"bytes,3,opt,name=invert_query_info,json=invertQueryInfo,oneof" json:"invert_query_info,omitempty"`
}

func (*ColumnarIndexInfo_AnnQueryInfo) isColumnarIndexInfo_Index()    {}
func (*ColumnarIndexInfo_InvertQueryInfo) isColumnarIndexInfo_Index() {}

func (m *ColumnarIndexInfo) GetIndex() isColumnarIndexInfo_Index {
	if m != nil {
		return m.Index
	}
	return nil
}

func (m *ColumnarIndexInfo) GetIndexType() ColumnarIndexType {
	if m != nil {
		return m.IndexType
	}
	return ColumnarIndexType_TypeInvalid
}

func (m *ColumnarIndexInfo) GetAnnQueryInfo() *ANNQueryInfo {
	if x, ok := m.GetIndex().(*ColumnarIndexInfo_AnnQueryInfo); ok {
		return x.AnnQueryInfo
	}
	return nil
}

func (m *ColumnarIndexInfo) GetInvertQueryInfo() *InvertedQueryInfo {
	if x, ok := m.GetIndex().(*ColumnarIndexInfo_InvertQueryInfo); ok {
		return x.InvertQueryInfo
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ColumnarIndexInfo) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ColumnarIndexInfo_AnnQueryInfo)(nil),
		(*ColumnarIndexInfo_InvertQueryInfo)(nil),
	}
}

type TableScan struct {
	TableId                    int64                `protobuf:"varint,1,opt,name=table_id,json=tableId" json:"table_id"`
	Columns                    []*ColumnInfo        `protobuf:"bytes,2,rep,name=columns" json:"columns,omitempty"`
	Desc                       bool                 `protobuf:"varint,3,opt,name=desc" json:"desc"`
	PrimaryColumnIds           []int64              `protobuf:"varint,4,rep,name=primary_column_ids,json=primaryColumnIds" json:"primary_column_ids,omitempty"`
	NextReadEngine             EngineType           `protobuf:"varint,5,opt,name=next_read_engine,json=nextReadEngine,enum=tipb.EngineType" json:"next_read_engine"`
	Ranges                     []KeyRange           `protobuf:"bytes,6,rep,name=ranges" json:"ranges"`
	PrimaryPrefixColumnIds     []int64              `protobuf:"varint,7,rep,name=primary_prefix_column_ids,json=primaryPrefixColumnIds" json:"primary_prefix_column_ids,omitempty"`
	KeepOrder                  *bool                `protobuf:"varint,8,opt,name=keep_order,json=keepOrder" json:"keep_order,omitempty"`
	IsFastScan                 *bool                `protobuf:"varint,9,opt,name=is_fast_scan,json=isFastScan" json:"is_fast_scan,omitempty"`
	PushedDownFilterConditions []*Expr              `protobuf:"bytes,10,rep,name=pushed_down_filter_conditions,json=pushedDownFilterConditions" json:"pushed_down_filter_conditions,omitempty"`
	RuntimeFilterList          []*RuntimeFilter     `protobuf:"bytes,11,rep,name=runtime_filter_list,json=runtimeFilterList" json:"runtime_filter_list,omitempty"`
	MaxWaitTimeMs              int32                `protobuf:"varint,12,opt,name=max_wait_time_ms,json=maxWaitTimeMs" json:"max_wait_time_ms"`
	DeprecatedAnnQuery         *ANNQueryInfo        `protobuf:"bytes,13,opt,name=deprecated_ann_query,json=deprecatedAnnQuery" json:"deprecated_ann_query,omitempty"`
	UsedColumnarIndexes        []*ColumnarIndexInfo `protobuf:"bytes,14,rep,name=used_columnar_indexes,json=usedColumnarIndexes" json:"used_columnar_indexes,omitempty"`
}

func (m *TableScan) Reset()         { *m = TableScan{} }
func (m *TableScan) String() string { return proto.CompactTextString(m) }
func (*TableScan) ProtoMessage()    {}
func (*TableScan) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{7}
}
func (m *TableScan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableScan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableScan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableScan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableScan.Merge(m, src)
}
func (m *TableScan) XXX_Size() int {
	return m.Size()
}
func (m *TableScan) XXX_DiscardUnknown() {
	xxx_messageInfo_TableScan.DiscardUnknown(m)
}

var xxx_messageInfo_TableScan proto.InternalMessageInfo

func (m *TableScan) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *TableScan) GetColumns() []*ColumnInfo {
	if m != nil {
		return m.Columns
	}
	return nil
}

func (m *TableScan) GetDesc() bool {
	if m != nil {
		return m.Desc
	}
	return false
}

func (m *TableScan) GetPrimaryColumnIds() []int64 {
	if m != nil {
		return m.PrimaryColumnIds
	}
	return nil
}

func (m *TableScan) GetNextReadEngine() EngineType {
	if m != nil {
		return m.NextReadEngine
	}
	return EngineType_Local
}

func (m *TableScan) GetRanges() []KeyRange {
	if m != nil {
		return m.Ranges
	}
	return nil
}

func (m *TableScan) GetPrimaryPrefixColumnIds() []int64 {
	if m != nil {
		return m.PrimaryPrefixColumnIds
	}
	return nil
}

func (m *TableScan) GetKeepOrder() bool {
	if m != nil && m.KeepOrder != nil {
		return *m.KeepOrder
	}
	return false
}

func (m *TableScan) GetIsFastScan() bool {
	if m != nil && m.IsFastScan != nil {
		return *m.IsFastScan
	}
	return false
}

func (m *TableScan) GetPushedDownFilterConditions() []*Expr {
	if m != nil {
		return m.PushedDownFilterConditions
	}
	return nil
}

func (m *TableScan) GetRuntimeFilterList() []*RuntimeFilter {
	if m != nil {
		return m.RuntimeFilterList
	}
	return nil
}

func (m *TableScan) GetMaxWaitTimeMs() int32 {
	if m != nil {
		return m.MaxWaitTimeMs
	}
	return 0
}

func (m *TableScan) GetDeprecatedAnnQuery() *ANNQueryInfo {
	if m != nil {
		return m.DeprecatedAnnQuery
	}
	return nil
}

func (m *TableScan) GetUsedColumnarIndexes() []*ColumnarIndexInfo {
	if m != nil {
		return m.UsedColumnarIndexes
	}
	return nil
}

type PartitionTableScan struct {
	TableId                    int64                `protobuf:"varint,1,opt,name=table_id,json=tableId" json:"table_id"`
	Columns                    []*ColumnInfo        `protobuf:"bytes,2,rep,name=columns" json:"columns,omitempty"`
	Desc                       bool                 `protobuf:"varint,3,opt,name=desc" json:"desc"`
	PrimaryColumnIds           []int64              `protobuf:"varint,4,rep,name=primary_column_ids,json=primaryColumnIds" json:"primary_column_ids,omitempty"`
	PrimaryPrefixColumnIds     []int64              `protobuf:"varint,5,rep,name=primary_prefix_column_ids,json=primaryPrefixColumnIds" json:"primary_prefix_column_ids,omitempty"`
	PartitionIds               []int64              `protobuf:"varint,6,rep,name=partition_ids,json=partitionIds" json:"partition_ids,omitempty"`
	IsFastScan                 *bool                `protobuf:"varint,7,opt,name=is_fast_scan,json=isFastScan" json:"is_fast_scan,omitempty"`
	PushedDownFilterConditions []*Expr              `protobuf:"bytes,8,rep,name=pushed_down_filter_conditions,json=pushedDownFilterConditions" json:"pushed_down_filter_conditions,omitempty"`
	RuntimeFilterList          []*RuntimeFilter     `protobuf:"bytes,9,rep,name=runtime_filter_list,json=runtimeFilterList" json:"runtime_filter_list,omitempty"`
	MaxWaitTimeMs              int32                `protobuf:"varint,10,opt,name=max_wait_time_ms,json=maxWaitTimeMs" json:"max_wait_time_ms"`
	DeprecatedAnnQuery         *ANNQueryInfo        `protobuf:"bytes,11,opt,name=deprecated_ann_query,json=deprecatedAnnQuery" json:"deprecated_ann_query,omitempty"`
	UsedColumnarIndexes        []*ColumnarIndexInfo `protobuf:"bytes,12,rep,name=used_columnar_indexes,json=usedColumnarIndexes" json:"used_columnar_indexes,omitempty"`
}

func (m *PartitionTableScan) Reset()         { *m = PartitionTableScan{} }
func (m *PartitionTableScan) String() string { return proto.CompactTextString(m) }
func (*PartitionTableScan) ProtoMessage()    {}
func (*PartitionTableScan) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{8}
}
func (m *PartitionTableScan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionTableScan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionTableScan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionTableScan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionTableScan.Merge(m, src)
}
func (m *PartitionTableScan) XXX_Size() int {
	return m.Size()
}
func (m *PartitionTableScan) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionTableScan.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionTableScan proto.InternalMessageInfo

func (m *PartitionTableScan) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *PartitionTableScan) GetColumns() []*ColumnInfo {
	if m != nil {
		return m.Columns
	}
	return nil
}

func (m *PartitionTableScan) GetDesc() bool {
	if m != nil {
		return m.Desc
	}
	return false
}

func (m *PartitionTableScan) GetPrimaryColumnIds() []int64 {
	if m != nil {
		return m.PrimaryColumnIds
	}
	return nil
}

func (m *PartitionTableScan) GetPrimaryPrefixColumnIds() []int64 {
	if m != nil {
		return m.PrimaryPrefixColumnIds
	}
	return nil
}

func (m *PartitionTableScan) GetPartitionIds() []int64 {
	if m != nil {
		return m.PartitionIds
	}
	return nil
}

func (m *PartitionTableScan) GetIsFastScan() bool {
	if m != nil && m.IsFastScan != nil {
		return *m.IsFastScan
	}
	return false
}

func (m *PartitionTableScan) GetPushedDownFilterConditions() []*Expr {
	if m != nil {
		return m.PushedDownFilterConditions
	}
	return nil
}

func (m *PartitionTableScan) GetRuntimeFilterList() []*RuntimeFilter {
	if m != nil {
		return m.RuntimeFilterList
	}
	return nil
}

func (m *PartitionTableScan) GetMaxWaitTimeMs() int32 {
	if m != nil {
		return m.MaxWaitTimeMs
	}
	return 0
}

func (m *PartitionTableScan) GetDeprecatedAnnQuery() *ANNQueryInfo {
	if m != nil {
		return m.DeprecatedAnnQuery
	}
	return nil
}

func (m *PartitionTableScan) GetUsedColumnarIndexes() []*ColumnarIndexInfo {
	if m != nil {
		return m.UsedColumnarIndexes
	}
	return nil
}

type Join struct {
	JoinType      JoinType     `protobuf:"varint,1,opt,name=join_type,json=joinType,enum=tipb.JoinType" json:"join_type"`
	JoinExecType  JoinExecType `protobuf:"varint,2,opt,name=join_exec_type,json=joinExecType,enum=tipb.JoinExecType" json:"join_exec_type"`
	Children      []*Executor  `protobuf:"bytes,3,rep,name=children" json:"children,omitempty"`
	InnerIdx      int64        `protobuf:"varint,4,opt,name=inner_idx,json=innerIdx" json:"inner_idx"`
	LeftJoinKeys  []*Expr      `protobuf:"bytes,5,rep,name=left_join_keys,json=leftJoinKeys" json:"left_join_keys,omitempty"`
	RightJoinKeys []*Expr      `protobuf:"bytes,6,rep,name=right_join_keys,json=rightJoinKeys" json:"right_join_keys,omitempty"`
	// used by TiFlash join when new collation is enabled.
	ProbeTypes              []*FieldType     `protobuf:"bytes,7,rep,name=probe_types,json=probeTypes" json:"probe_types,omitempty"`
	BuildTypes              []*FieldType     `protobuf:"bytes,8,rep,name=build_types,json=buildTypes" json:"build_types,omitempty"`
	LeftConditions          []*Expr          `protobuf:"bytes,9,rep,name=left_conditions,json=leftConditions" json:"left_conditions,omitempty"`
	RightConditions         []*Expr          `protobuf:"bytes,10,rep,name=right_conditions,json=rightConditions" json:"right_conditions,omitempty"`
	OtherConditions         []*Expr          `protobuf:"bytes,11,rep,name=other_conditions,json=otherConditions" json:"other_conditions,omitempty"`
	OtherEqConditionsFromIn []*Expr          `protobuf:"bytes,12,rep,name=other_eq_conditions_from_in,json=otherEqConditionsFromIn" json:"other_eq_conditions_from_in,omitempty"`
	IsNullAwareSemiJoin     *bool            `protobuf:"varint,13,opt,name=is_null_aware_semi_join,json=isNullAwareSemiJoin" json:"is_null_aware_semi_join,omitempty"`
	RuntimeFilterList       []*RuntimeFilter `protobuf:"bytes,14,rep,name=runtime_filter_list,json=runtimeFilterList" json:"runtime_filter_list,omitempty"`
}

func (m *Join) Reset()         { *m = Join{} }
func (m *Join) String() string { return proto.CompactTextString(m) }
func (*Join) ProtoMessage()    {}
func (*Join) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{9}
}
func (m *Join) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Join) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Join.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Join) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Join.Merge(m, src)
}
func (m *Join) XXX_Size() int {
	return m.Size()
}
func (m *Join) XXX_DiscardUnknown() {
	xxx_messageInfo_Join.DiscardUnknown(m)
}

var xxx_messageInfo_Join proto.InternalMessageInfo

func (m *Join) GetJoinType() JoinType {
	if m != nil {
		return m.JoinType
	}
	return JoinType_TypeInnerJoin
}

func (m *Join) GetJoinExecType() JoinExecType {
	if m != nil {
		return m.JoinExecType
	}
	return JoinExecType_TypeHashJoin
}

func (m *Join) GetChildren() []*Executor {
	if m != nil {
		return m.Children
	}
	return nil
}

func (m *Join) GetInnerIdx() int64 {
	if m != nil {
		return m.InnerIdx
	}
	return 0
}

func (m *Join) GetLeftJoinKeys() []*Expr {
	if m != nil {
		return m.LeftJoinKeys
	}
	return nil
}

func (m *Join) GetRightJoinKeys() []*Expr {
	if m != nil {
		return m.RightJoinKeys
	}
	return nil
}

func (m *Join) GetProbeTypes() []*FieldType {
	if m != nil {
		return m.ProbeTypes
	}
	return nil
}

func (m *Join) GetBuildTypes() []*FieldType {
	if m != nil {
		return m.BuildTypes
	}
	return nil
}

func (m *Join) GetLeftConditions() []*Expr {
	if m != nil {
		return m.LeftConditions
	}
	return nil
}

func (m *Join) GetRightConditions() []*Expr {
	if m != nil {
		return m.RightConditions
	}
	return nil
}

func (m *Join) GetOtherConditions() []*Expr {
	if m != nil {
		return m.OtherConditions
	}
	return nil
}

func (m *Join) GetOtherEqConditionsFromIn() []*Expr {
	if m != nil {
		return m.OtherEqConditionsFromIn
	}
	return nil
}

func (m *Join) GetIsNullAwareSemiJoin() bool {
	if m != nil && m.IsNullAwareSemiJoin != nil {
		return *m.IsNullAwareSemiJoin
	}
	return false
}

func (m *Join) GetRuntimeFilterList() []*RuntimeFilter {
	if m != nil {
		return m.RuntimeFilterList
	}
	return nil
}

type RuntimeFilter struct {
	Id               int32             `protobuf:"varint,1,opt,name=id" json:"id"`
	SourceExprList   []*Expr           `protobuf:"bytes,2,rep,name=source_expr_list,json=sourceExprList" json:"source_expr_list,omitempty"`
	TargetExprList   []*Expr           `protobuf:"bytes,3,rep,name=target_expr_list,json=targetExprList" json:"target_expr_list,omitempty"`
	SourceExecutorId string            `protobuf:"bytes,4,opt,name=source_executor_id,json=sourceExecutorId" json:"source_executor_id"`
	TargetExecutorId string            `protobuf:"bytes,5,opt,name=target_executor_id,json=targetExecutorId" json:"target_executor_id"`
	RfType           RuntimeFilterType `protobuf:"varint,6,opt,name=rf_type,json=rfType,enum=tipb.RuntimeFilterType" json:"rf_type"`
	RfMode           RuntimeFilterMode `protobuf:"varint,7,opt,name=rf_mode,json=rfMode,enum=tipb.RuntimeFilterMode" json:"rf_mode"`
}

func (m *RuntimeFilter) Reset()         { *m = RuntimeFilter{} }
func (m *RuntimeFilter) String() string { return proto.CompactTextString(m) }
func (*RuntimeFilter) ProtoMessage()    {}
func (*RuntimeFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{10}
}
func (m *RuntimeFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RuntimeFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RuntimeFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RuntimeFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RuntimeFilter.Merge(m, src)
}
func (m *RuntimeFilter) XXX_Size() int {
	return m.Size()
}
func (m *RuntimeFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_RuntimeFilter.DiscardUnknown(m)
}

var xxx_messageInfo_RuntimeFilter proto.InternalMessageInfo

func (m *RuntimeFilter) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RuntimeFilter) GetSourceExprList() []*Expr {
	if m != nil {
		return m.SourceExprList
	}
	return nil
}

func (m *RuntimeFilter) GetTargetExprList() []*Expr {
	if m != nil {
		return m.TargetExprList
	}
	return nil
}

func (m *RuntimeFilter) GetSourceExecutorId() string {
	if m != nil {
		return m.SourceExecutorId
	}
	return ""
}

func (m *RuntimeFilter) GetTargetExecutorId() string {
	if m != nil {
		return m.TargetExecutorId
	}
	return ""
}

func (m *RuntimeFilter) GetRfType() RuntimeFilterType {
	if m != nil {
		return m.RfType
	}
	return RuntimeFilterType_IN
}

func (m *RuntimeFilter) GetRfMode() RuntimeFilterMode {
	if m != nil {
		return m.RfMode
	}
	return RuntimeFilterMode_LOCAL
}

type IndexScan struct {
	TableId          int64         `protobuf:"varint,1,opt,name=table_id,json=tableId" json:"table_id"`
	IndexId          int64         `protobuf:"varint,2,opt,name=index_id,json=indexId" json:"index_id"`
	Columns          []*ColumnInfo `protobuf:"bytes,3,rep,name=columns" json:"columns,omitempty"`
	Desc             bool          `protobuf:"varint,4,opt,name=desc" json:"desc"`
	Unique           *bool         `protobuf:"varint,5,opt,name=unique" json:"unique,omitempty"`
	PrimaryColumnIds []int64       `protobuf:"varint,6,rep,name=primary_column_ids,json=primaryColumnIds" json:"primary_column_ids,omitempty"`
}

func (m *IndexScan) Reset()         { *m = IndexScan{} }
func (m *IndexScan) String() string { return proto.CompactTextString(m) }
func (*IndexScan) ProtoMessage()    {}
func (*IndexScan) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{11}
}
func (m *IndexScan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexScan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IndexScan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IndexScan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexScan.Merge(m, src)
}
func (m *IndexScan) XXX_Size() int {
	return m.Size()
}
func (m *IndexScan) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexScan.DiscardUnknown(m)
}

var xxx_messageInfo_IndexScan proto.InternalMessageInfo

func (m *IndexScan) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *IndexScan) GetIndexId() int64 {
	if m != nil {
		return m.IndexId
	}
	return 0
}

func (m *IndexScan) GetColumns() []*ColumnInfo {
	if m != nil {
		return m.Columns
	}
	return nil
}

func (m *IndexScan) GetDesc() bool {
	if m != nil {
		return m.Desc
	}
	return false
}

func (m *IndexScan) GetUnique() bool {
	if m != nil && m.Unique != nil {
		return *m.Unique
	}
	return false
}

func (m *IndexScan) GetPrimaryColumnIds() []int64 {
	if m != nil {
		return m.PrimaryColumnIds
	}
	return nil
}

type Selection struct {
	// Where conditions.
	Conditions    []*Expr    `protobuf:"bytes,1,rep,name=conditions" json:"conditions,omitempty"`
	RpnConditions []*RpnExpr `protobuf:"bytes,2,rep,name=rpn_conditions,json=rpnConditions" json:"rpn_conditions,omitempty"`
	Child         *Executor  `protobuf:"bytes,3,opt,name=child" json:"child,omitempty"`
}

func (m *Selection) Reset()         { *m = Selection{} }
func (m *Selection) String() string { return proto.CompactTextString(m) }
func (*Selection) ProtoMessage()    {}
func (*Selection) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{12}
}
func (m *Selection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Selection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Selection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Selection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Selection.Merge(m, src)
}
func (m *Selection) XXX_Size() int {
	return m.Size()
}
func (m *Selection) XXX_DiscardUnknown() {
	xxx_messageInfo_Selection.DiscardUnknown(m)
}

var xxx_messageInfo_Selection proto.InternalMessageInfo

func (m *Selection) GetConditions() []*Expr {
	if m != nil {
		return m.Conditions
	}
	return nil
}

func (m *Selection) GetRpnConditions() []*RpnExpr {
	if m != nil {
		return m.RpnConditions
	}
	return nil
}

func (m *Selection) GetChild() *Executor {
	if m != nil {
		return m.Child
	}
	return nil
}

type Projection struct {
	// Projection expressions.
	Exprs    []*Expr    `protobuf:"bytes,1,rep,name=exprs" json:"exprs,omitempty"`
	RpnExprs []*RpnExpr `protobuf:"bytes,2,rep,name=rpn_exprs,json=rpnExprs" json:"rpn_exprs,omitempty"`
	Child    *Executor  `protobuf:"bytes,3,opt,name=child" json:"child,omitempty"`
}

func (m *Projection) Reset()         { *m = Projection{} }
func (m *Projection) String() string { return proto.CompactTextString(m) }
func (*Projection) ProtoMessage()    {}
func (*Projection) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{13}
}
func (m *Projection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Projection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Projection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Projection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Projection.Merge(m, src)
}
func (m *Projection) XXX_Size() int {
	return m.Size()
}
func (m *Projection) XXX_DiscardUnknown() {
	xxx_messageInfo_Projection.DiscardUnknown(m)
}

var xxx_messageInfo_Projection proto.InternalMessageInfo

func (m *Projection) GetExprs() []*Expr {
	if m != nil {
		return m.Exprs
	}
	return nil
}

func (m *Projection) GetRpnExprs() []*RpnExpr {
	if m != nil {
		return m.RpnExprs
	}
	return nil
}

func (m *Projection) GetChild() *Executor {
	if m != nil {
		return m.Child
	}
	return nil
}

type Aggregation struct {
	// Group by clause.
	GroupBy    []*Expr    `protobuf:"bytes,1,rep,name=group_by,json=groupBy" json:"group_by,omitempty"`
	RpnGroupBy []*RpnExpr `protobuf:"bytes,4,rep,name=rpn_group_by,json=rpnGroupBy" json:"rpn_group_by,omitempty"`
	// Aggregate functions.
	AggFunc    []*Expr    `protobuf:"bytes,2,rep,name=agg_func,json=aggFunc" json:"agg_func,omitempty"`
	RpnAggFunc []*RpnExpr `protobuf:"bytes,5,rep,name=rpn_agg_func,json=rpnAggFunc" json:"rpn_agg_func,omitempty"`
	// If it is a stream aggregation.
	Streamed   bool               `protobuf:"varint,3,opt,name=streamed" json:"streamed"`
	Child      *Executor          `protobuf:"bytes,6,opt,name=child" json:"child,omitempty"`
	PreAggMode *TiFlashPreAggMode `protobuf:"varint,7,opt,name=pre_agg_mode,json=preAggMode,enum=tipb.TiFlashPreAggMode" json:"pre_agg_mode,omitempty"`
}

func (m *Aggregation) Reset()         { *m = Aggregation{} }
func (m *Aggregation) String() string { return proto.CompactTextString(m) }
func (*Aggregation) ProtoMessage()    {}
func (*Aggregation) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{14}
}
func (m *Aggregation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Aggregation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Aggregation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Aggregation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Aggregation.Merge(m, src)
}
func (m *Aggregation) XXX_Size() int {
	return m.Size()
}
func (m *Aggregation) XXX_DiscardUnknown() {
	xxx_messageInfo_Aggregation.DiscardUnknown(m)
}

var xxx_messageInfo_Aggregation proto.InternalMessageInfo

func (m *Aggregation) GetGroupBy() []*Expr {
	if m != nil {
		return m.GroupBy
	}
	return nil
}

func (m *Aggregation) GetRpnGroupBy() []*RpnExpr {
	if m != nil {
		return m.RpnGroupBy
	}
	return nil
}

func (m *Aggregation) GetAggFunc() []*Expr {
	if m != nil {
		return m.AggFunc
	}
	return nil
}

func (m *Aggregation) GetRpnAggFunc() []*RpnExpr {
	if m != nil {
		return m.RpnAggFunc
	}
	return nil
}

func (m *Aggregation) GetStreamed() bool {
	if m != nil {
		return m.Streamed
	}
	return false
}

func (m *Aggregation) GetChild() *Executor {
	if m != nil {
		return m.Child
	}
	return nil
}

func (m *Aggregation) GetPreAggMode() TiFlashPreAggMode {
	if m != nil && m.PreAggMode != nil {
		return *m.PreAggMode
	}
	return TiFlashPreAggMode_ForcePreAgg
}

type TopN struct {
	// Order by clause.
	OrderBy []*ByItem `protobuf:"bytes,1,rep,name=order_by,json=orderBy" json:"order_by,omitempty"`
	Limit   uint64    `protobuf:"varint,2,opt,name=limit" json:"limit"`
	Child   *Executor `protobuf:"bytes,3,opt,name=child" json:"child,omitempty"`
	// If partition_by is not empty, it means need to return topN of each partition.
	// Generally used in sqls like `where row_number() over (partition by ... order by ...) < X`
	PartitionBy []*ByItem `protobuf:"bytes,4,rep,name=partition_by,json=partitionBy" json:"partition_by,omitempty"`
}

func (m *TopN) Reset()         { *m = TopN{} }
func (m *TopN) String() string { return proto.CompactTextString(m) }
func (*TopN) ProtoMessage()    {}
func (*TopN) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{15}
}
func (m *TopN) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopN) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopN.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopN) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopN.Merge(m, src)
}
func (m *TopN) XXX_Size() int {
	return m.Size()
}
func (m *TopN) XXX_DiscardUnknown() {
	xxx_messageInfo_TopN.DiscardUnknown(m)
}

var xxx_messageInfo_TopN proto.InternalMessageInfo

func (m *TopN) GetOrderBy() []*ByItem {
	if m != nil {
		return m.OrderBy
	}
	return nil
}

func (m *TopN) GetLimit() uint64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *TopN) GetChild() *Executor {
	if m != nil {
		return m.Child
	}
	return nil
}

func (m *TopN) GetPartitionBy() []*ByItem {
	if m != nil {
		return m.PartitionBy
	}
	return nil
}

type Limit struct {
	// Limit the result to be returned.
	Limit uint64    `protobuf:"varint,1,opt,name=limit" json:"limit"`
	Child *Executor `protobuf:"bytes,2,opt,name=child" json:"child,omitempty"`
	// If partition_by is not empty, it means need to return limitN of each partition.
	// Generally used in sqls like `where row_number() over (partition by ...) < X`
	PartitionBy []*ByItem `protobuf:"bytes,3,rep,name=partition_by,json=partitionBy" json:"partition_by,omitempty"`
}

func (m *Limit) Reset()         { *m = Limit{} }
func (m *Limit) String() string { return proto.CompactTextString(m) }
func (*Limit) ProtoMessage()    {}
func (*Limit) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{16}
}
func (m *Limit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Limit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Limit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Limit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Limit.Merge(m, src)
}
func (m *Limit) XXX_Size() int {
	return m.Size()
}
func (m *Limit) XXX_DiscardUnknown() {
	xxx_messageInfo_Limit.DiscardUnknown(m)
}

var xxx_messageInfo_Limit proto.InternalMessageInfo

func (m *Limit) GetLimit() uint64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *Limit) GetChild() *Executor {
	if m != nil {
		return m.Child
	}
	return nil
}

func (m *Limit) GetPartitionBy() []*ByItem {
	if m != nil {
		return m.PartitionBy
	}
	return nil
}

type Kill struct {
	ConnID uint64 `protobuf:"varint,1,opt,name=connID" json:"connID"`
	// Query indicates whether terminate a single query on this connection or the whole connection.
	//
	//	If Query is true, terminates the statement the connection is currently executing, but leaves the connection itself intact.
	//	If Query is false, terminates the connection associated with the given ConnectionID, after terminating any statement the connection is executing.
	//	See https://dev.mysql.com/doc/refman/8.0/en/kill.html.
	Query bool `protobuf:"varint,2,opt,name=query" json:"query"`
}

func (m *Kill) Reset()         { *m = Kill{} }
func (m *Kill) String() string { return proto.CompactTextString(m) }
func (*Kill) ProtoMessage()    {}
func (*Kill) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{17}
}
func (m *Kill) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Kill) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Kill.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Kill) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Kill.Merge(m, src)
}
func (m *Kill) XXX_Size() int {
	return m.Size()
}
func (m *Kill) XXX_DiscardUnknown() {
	xxx_messageInfo_Kill.DiscardUnknown(m)
}

var xxx_messageInfo_Kill proto.InternalMessageInfo

func (m *Kill) GetConnID() uint64 {
	if m != nil {
		return m.ConnID
	}
	return 0
}

func (m *Kill) GetQuery() bool {
	if m != nil {
		return m.Query
	}
	return false
}

type ExecutorExecutionSummary struct {
	// Total time cost in this executor. Includes self time cost and children time cost.
	TimeProcessedNs *uint64 `protobuf:"varint,1,opt,name=time_processed_ns,json=timeProcessedNs" json:"time_processed_ns,omitempty"`
	// How many rows this executor produced totally.
	NumProducedRows *uint64 `protobuf:"varint,2,opt,name=num_produced_rows,json=numProducedRows" json:"num_produced_rows,omitempty"`
	// How many times executor's `next()` is called.
	NumIterations *uint64 `protobuf:"varint,3,opt,name=num_iterations,json=numIterations" json:"num_iterations,omitempty"`
	// Coresponding executor id
	ExecutorId *string `protobuf:"bytes,4,opt,name=executor_id,json=executorId" json:"executor_id,omitempty"`
	// The execution concurrency for this executor
	Concurrency *uint64 `protobuf:"varint,5,opt,name=concurrency" json:"concurrency,omitempty"`
	// Types that are valid to be assigned to DetailInfo:
	//
	//	*ExecutorExecutionSummary_TiflashScanContext
	DetailInfo isExecutorExecutionSummary_DetailInfo `protobuf_oneof:"DetailInfo"`
	// Serialize kvproto resource_manager.Consumption to tell tidb the consumption info. For now it's only for tiflash.
	// And it's the ru consumption of one MPPTask/cop/batchCop instead of one executor.
	RuConsumption []byte `protobuf:"bytes,7,opt,name=ru_consumption,json=ruConsumption" json:"ru_consumption,omitempty"`
	// Only for tiflash, records the wait info.
	TiflashWaitSummary *TiFlashWaitSummary `protobuf:"bytes,8,opt,name=tiflash_wait_summary,json=tiflashWaitSummary" json:"tiflash_wait_summary,omitempty"`
	// Only for tiflash, records network info.
	TiflashNetworkSummary *TiFlashNetWorkSummary `protobuf:"bytes,9,opt,name=tiflash_network_summary,json=tiflashNetworkSummary" json:"tiflash_network_summary,omitempty"`
}

func (m *ExecutorExecutionSummary) Reset()         { *m = ExecutorExecutionSummary{} }
func (m *ExecutorExecutionSummary) String() string { return proto.CompactTextString(m) }
func (*ExecutorExecutionSummary) ProtoMessage()    {}
func (*ExecutorExecutionSummary) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{18}
}
func (m *ExecutorExecutionSummary) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecutorExecutionSummary) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecutorExecutionSummary.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecutorExecutionSummary) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecutorExecutionSummary.Merge(m, src)
}
func (m *ExecutorExecutionSummary) XXX_Size() int {
	return m.Size()
}
func (m *ExecutorExecutionSummary) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecutorExecutionSummary.DiscardUnknown(m)
}

var xxx_messageInfo_ExecutorExecutionSummary proto.InternalMessageInfo

type isExecutorExecutionSummary_DetailInfo interface {
	isExecutorExecutionSummary_DetailInfo()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ExecutorExecutionSummary_TiflashScanContext struct {
	TiflashScanContext *TiFlashScanContext `protobuf:"bytes,6,opt,name=tiflash_scan_context,json=tiflashScanContext,oneof" json:"tiflash_scan_context,omitempty"`
}

func (*ExecutorExecutionSummary_TiflashScanContext) isExecutorExecutionSummary_DetailInfo() {}

func (m *ExecutorExecutionSummary) GetDetailInfo() isExecutorExecutionSummary_DetailInfo {
	if m != nil {
		return m.DetailInfo
	}
	return nil
}

func (m *ExecutorExecutionSummary) GetTimeProcessedNs() uint64 {
	if m != nil && m.TimeProcessedNs != nil {
		return *m.TimeProcessedNs
	}
	return 0
}

func (m *ExecutorExecutionSummary) GetNumProducedRows() uint64 {
	if m != nil && m.NumProducedRows != nil {
		return *m.NumProducedRows
	}
	return 0
}

func (m *ExecutorExecutionSummary) GetNumIterations() uint64 {
	if m != nil && m.NumIterations != nil {
		return *m.NumIterations
	}
	return 0
}

func (m *ExecutorExecutionSummary) GetExecutorId() string {
	if m != nil && m.ExecutorId != nil {
		return *m.ExecutorId
	}
	return ""
}

func (m *ExecutorExecutionSummary) GetConcurrency() uint64 {
	if m != nil && m.Concurrency != nil {
		return *m.Concurrency
	}
	return 0
}

func (m *ExecutorExecutionSummary) GetTiflashScanContext() *TiFlashScanContext {
	if x, ok := m.GetDetailInfo().(*ExecutorExecutionSummary_TiflashScanContext); ok {
		return x.TiflashScanContext
	}
	return nil
}

func (m *ExecutorExecutionSummary) GetRuConsumption() []byte {
	if m != nil {
		return m.RuConsumption
	}
	return nil
}

func (m *ExecutorExecutionSummary) GetTiflashWaitSummary() *TiFlashWaitSummary {
	if m != nil {
		return m.TiflashWaitSummary
	}
	return nil
}

func (m *ExecutorExecutionSummary) GetTiflashNetworkSummary() *TiFlashNetWorkSummary {
	if m != nil {
		return m.TiflashNetworkSummary
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ExecutorExecutionSummary) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ExecutorExecutionSummary_TiflashScanContext)(nil),
	}
}

type TiFlashExecutionInfo struct {
	// The execution summary of each executor, no order limitation.
	ExecutionSummaries []*ExecutorExecutionSummary `protobuf:"bytes,1,rep,name=execution_summaries,json=executionSummaries" json:"execution_summaries,omitempty"`
}

func (m *TiFlashExecutionInfo) Reset()         { *m = TiFlashExecutionInfo{} }
func (m *TiFlashExecutionInfo) String() string { return proto.CompactTextString(m) }
func (*TiFlashExecutionInfo) ProtoMessage()    {}
func (*TiFlashExecutionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{19}
}
func (m *TiFlashExecutionInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TiFlashExecutionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TiFlashExecutionInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TiFlashExecutionInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TiFlashExecutionInfo.Merge(m, src)
}
func (m *TiFlashExecutionInfo) XXX_Size() int {
	return m.Size()
}
func (m *TiFlashExecutionInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TiFlashExecutionInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TiFlashExecutionInfo proto.InternalMessageInfo

func (m *TiFlashExecutionInfo) GetExecutionSummaries() []*ExecutorExecutionSummary {
	if m != nil {
		return m.ExecutionSummaries
	}
	return nil
}

type TiFlashRegionNumOfInstance struct {
	InstanceId *string `protobuf:"bytes,1,opt,name=instance_id,json=instanceId" json:"instance_id,omitempty"`
	RegionNum  *uint64 `protobuf:"varint,2,opt,name=region_num,json=regionNum" json:"region_num,omitempty"`
}

func (m *TiFlashRegionNumOfInstance) Reset()         { *m = TiFlashRegionNumOfInstance{} }
func (m *TiFlashRegionNumOfInstance) String() string { return proto.CompactTextString(m) }
func (*TiFlashRegionNumOfInstance) ProtoMessage()    {}
func (*TiFlashRegionNumOfInstance) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{20}
}
func (m *TiFlashRegionNumOfInstance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TiFlashRegionNumOfInstance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TiFlashRegionNumOfInstance.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TiFlashRegionNumOfInstance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TiFlashRegionNumOfInstance.Merge(m, src)
}
func (m *TiFlashRegionNumOfInstance) XXX_Size() int {
	return m.Size()
}
func (m *TiFlashRegionNumOfInstance) XXX_DiscardUnknown() {
	xxx_messageInfo_TiFlashRegionNumOfInstance.DiscardUnknown(m)
}

var xxx_messageInfo_TiFlashRegionNumOfInstance proto.InternalMessageInfo

func (m *TiFlashRegionNumOfInstance) GetInstanceId() string {
	if m != nil && m.InstanceId != nil {
		return *m.InstanceId
	}
	return ""
}

func (m *TiFlashRegionNumOfInstance) GetRegionNum() uint64 {
	if m != nil && m.RegionNum != nil {
		return *m.RegionNum
	}
	return 0
}

type TiFlashScanContext struct {
	DmfileScannedPacks                 *uint64                       `protobuf:"varint,1,opt,name=dmfile_scanned_packs,json=dmfileScannedPacks" json:"dmfile_scanned_packs,omitempty"` // Deprecated: Do not use.
	DmfileSkippedPacks                 *uint64                       `protobuf:"varint,2,opt,name=dmfile_skipped_packs,json=dmfileSkippedPacks" json:"dmfile_skipped_packs,omitempty"` // Deprecated: Do not use.
	DmfileDataScannedRows              *uint64                       `protobuf:"varint,3,opt,name=dmfile_data_scanned_rows,json=dmfileDataScannedRows" json:"dmfile_data_scanned_rows,omitempty"`
	DmfileDataSkippedRows              *uint64                       `protobuf:"varint,4,opt,name=dmfile_data_skipped_rows,json=dmfileDataSkippedRows" json:"dmfile_data_skipped_rows,omitempty"`
	TotalDmfileRsLoadMs                *uint64                       `protobuf:"varint,5,opt,name=total_dmfile_rs_load_ms,json=totalDmfileRsLoadMs" json:"total_dmfile_rs_load_ms,omitempty"` // Deprecated: Do not use.
	TotalDmfileReadMs                  *uint64                       `protobuf:"varint,6,opt,name=total_dmfile_read_ms,json=totalDmfileReadMs" json:"total_dmfile_read_ms,omitempty"`
	TotalBuildSnapshotMs               *uint64                       `protobuf:"varint,7,opt,name=total_build_snapshot_ms,json=totalBuildSnapshotMs" json:"total_build_snapshot_ms,omitempty"`
	LocalRegions                       *uint64                       `protobuf:"varint,8,opt,name=local_regions,json=localRegions" json:"local_regions,omitempty"`
	RemoteRegions                      *uint64                       `protobuf:"varint,9,opt,name=remote_regions,json=remoteRegions" json:"remote_regions,omitempty"`
	UserReadBytes                      *uint64                       `protobuf:"varint,10,opt,name=user_read_bytes,json=userReadBytes" json:"user_read_bytes,omitempty"`
	TotalLearnerReadMs                 *uint64                       `protobuf:"varint,11,opt,name=total_learner_read_ms,json=totalLearnerReadMs" json:"total_learner_read_ms,omitempty"`
	DisaggReadCacheHitBytes            *uint64                       `protobuf:"varint,12,opt,name=disagg_read_cache_hit_bytes,json=disaggReadCacheHitBytes" json:"disagg_read_cache_hit_bytes,omitempty"`
	DisaggReadCacheMissBytes           *uint64                       `protobuf:"varint,13,opt,name=disagg_read_cache_miss_bytes,json=disaggReadCacheMissBytes" json:"disagg_read_cache_miss_bytes,omitempty"`
	TotalDmfileRsCheckMs               *uint64                       `protobuf:"varint,14,opt,name=total_dmfile_rs_check_ms,json=totalDmfileRsCheckMs" json:"total_dmfile_rs_check_ms,omitempty"`
	StaleReadRegions                   *uint64                       `protobuf:"varint,15,opt,name=stale_read_regions,json=staleReadRegions" json:"stale_read_regions,omitempty"`
	Segments                           *uint64                       `protobuf:"varint,16,opt,name=segments" json:"segments,omitempty"`
	ReadTasks                          *uint64                       `protobuf:"varint,17,opt,name=read_tasks,json=readTasks" json:"read_tasks,omitempty"`
	DeltaRows                          *uint64                       `protobuf:"varint,18,opt,name=delta_rows,json=deltaRows" json:"delta_rows,omitempty"`
	DeltaBytes                         *uint64                       `protobuf:"varint,19,opt,name=delta_bytes,json=deltaBytes" json:"delta_bytes,omitempty"`
	MvccInputRows                      *uint64                       `protobuf:"varint,20,opt,name=mvcc_input_rows,json=mvccInputRows" json:"mvcc_input_rows,omitempty"`
	MvccInputBytes                     *uint64                       `protobuf:"varint,21,opt,name=mvcc_input_bytes,json=mvccInputBytes" json:"mvcc_input_bytes,omitempty"`
	MvccOutputRows                     *uint64                       `protobuf:"varint,22,opt,name=mvcc_output_rows,json=mvccOutputRows" json:"mvcc_output_rows,omitempty"`
	LmSkipRows                         *uint64                       `protobuf:"varint,23,opt,name=lm_skip_rows,json=lmSkipRows" json:"lm_skip_rows,omitempty"`
	TotalBuildInputstreamMs            *uint64                       `protobuf:"varint,24,opt,name=total_build_inputstream_ms,json=totalBuildInputstreamMs" json:"total_build_inputstream_ms,omitempty"`
	TotalBuildBitmapMs                 *uint64                       `protobuf:"varint,25,opt,name=total_build_bitmap_ms,json=totalBuildBitmapMs" json:"total_build_bitmap_ms,omitempty"`
	MinLocalStreamMs                   *uint64                       `protobuf:"varint,26,opt,name=min_local_stream_ms,json=minLocalStreamMs" json:"min_local_stream_ms,omitempty"`
	MaxLocalStreamMs                   *uint64                       `protobuf:"varint,27,opt,name=max_local_stream_ms,json=maxLocalStreamMs" json:"max_local_stream_ms,omitempty"`
	MinRemoteStreamMs                  *uint64                       `protobuf:"varint,28,opt,name=min_remote_stream_ms,json=minRemoteStreamMs" json:"min_remote_stream_ms,omitempty"`
	MaxRemoteStreamMs                  *uint64                       `protobuf:"varint,29,opt,name=max_remote_stream_ms,json=maxRemoteStreamMs" json:"max_remote_stream_ms,omitempty"`
	RegionsOfInstance                  []*TiFlashRegionNumOfInstance `protobuf:"bytes,30,rep,name=regions_of_instance,json=regionsOfInstance" json:"regions_of_instance,omitempty"`
	DmfileMvccScannedRows              *uint64                       `protobuf:"varint,31,opt,name=dmfile_mvcc_scanned_rows,json=dmfileMvccScannedRows" json:"dmfile_mvcc_scanned_rows,omitempty"`
	DmfileMvccSkippedRows              *uint64                       `protobuf:"varint,32,opt,name=dmfile_mvcc_skipped_rows,json=dmfileMvccSkippedRows" json:"dmfile_mvcc_skipped_rows,omitempty"`
	DmfileLmFilterScannedRows          *uint64                       `protobuf:"varint,33,opt,name=dmfile_lm_filter_scanned_rows,json=dmfileLmFilterScannedRows" json:"dmfile_lm_filter_scanned_rows,omitempty"`
	DmfileLmFilterSkippedRows          *uint64                       `protobuf:"varint,34,opt,name=dmfile_lm_filter_skipped_rows,json=dmfileLmFilterSkippedRows" json:"dmfile_lm_filter_skipped_rows,omitempty"`
	TotalVectorIdxLoadFromS3           *uint64                       `protobuf:"varint,100,opt,name=total_vector_idx_load_from_s3,json=totalVectorIdxLoadFromS3" json:"total_vector_idx_load_from_s3,omitempty"`
	TotalVectorIdxLoadFromDisk         *uint64                       `protobuf:"varint,101,opt,name=total_vector_idx_load_from_disk,json=totalVectorIdxLoadFromDisk" json:"total_vector_idx_load_from_disk,omitempty"`
	TotalVectorIdxLoadFromCache        *uint64                       `protobuf:"varint,102,opt,name=total_vector_idx_load_from_cache,json=totalVectorIdxLoadFromCache" json:"total_vector_idx_load_from_cache,omitempty"`
	TotalVectorIdxLoadTimeMs           *uint64                       `protobuf:"varint,103,opt,name=total_vector_idx_load_time_ms,json=totalVectorIdxLoadTimeMs" json:"total_vector_idx_load_time_ms,omitempty"`
	TotalVectorIdxSearchTimeMs         *uint64                       `protobuf:"varint,104,opt,name=total_vector_idx_search_time_ms,json=totalVectorIdxSearchTimeMs" json:"total_vector_idx_search_time_ms,omitempty"`
	TotalVectorIdxSearchVisitedNodes   *uint64                       `protobuf:"varint,105,opt,name=total_vector_idx_search_visited_nodes,json=totalVectorIdxSearchVisitedNodes" json:"total_vector_idx_search_visited_nodes,omitempty"`
	TotalVectorIdxSearchDiscardedNodes *uint64                       `protobuf:"varint,106,opt,name=total_vector_idx_search_discarded_nodes,json=totalVectorIdxSearchDiscardedNodes" json:"total_vector_idx_search_discarded_nodes,omitempty"`
	TotalVectorIdxReadVecTimeMs        *uint64                       `protobuf:"varint,107,opt,name=total_vector_idx_read_vec_time_ms,json=totalVectorIdxReadVecTimeMs" json:"total_vector_idx_read_vec_time_ms,omitempty"`
	TotalVectorIdxReadOthersTimeMs     *uint64                       `protobuf:"varint,108,opt,name=total_vector_idx_read_others_time_ms,json=totalVectorIdxReadOthersTimeMs" json:"total_vector_idx_read_others_time_ms,omitempty"`
}

func (m *TiFlashScanContext) Reset()         { *m = TiFlashScanContext{} }
func (m *TiFlashScanContext) String() string { return proto.CompactTextString(m) }
func (*TiFlashScanContext) ProtoMessage()    {}
func (*TiFlashScanContext) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{21}
}
func (m *TiFlashScanContext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TiFlashScanContext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TiFlashScanContext.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TiFlashScanContext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TiFlashScanContext.Merge(m, src)
}
func (m *TiFlashScanContext) XXX_Size() int {
	return m.Size()
}
func (m *TiFlashScanContext) XXX_DiscardUnknown() {
	xxx_messageInfo_TiFlashScanContext.DiscardUnknown(m)
}

var xxx_messageInfo_TiFlashScanContext proto.InternalMessageInfo

// Deprecated: Do not use.
func (m *TiFlashScanContext) GetDmfileScannedPacks() uint64 {
	if m != nil && m.DmfileScannedPacks != nil {
		return *m.DmfileScannedPacks
	}
	return 0
}

// Deprecated: Do not use.
func (m *TiFlashScanContext) GetDmfileSkippedPacks() uint64 {
	if m != nil && m.DmfileSkippedPacks != nil {
		return *m.DmfileSkippedPacks
	}
	return 0
}

func (m *TiFlashScanContext) GetDmfileDataScannedRows() uint64 {
	if m != nil && m.DmfileDataScannedRows != nil {
		return *m.DmfileDataScannedRows
	}
	return 0
}

func (m *TiFlashScanContext) GetDmfileDataSkippedRows() uint64 {
	if m != nil && m.DmfileDataSkippedRows != nil {
		return *m.DmfileDataSkippedRows
	}
	return 0
}

// Deprecated: Do not use.
func (m *TiFlashScanContext) GetTotalDmfileRsLoadMs() uint64 {
	if m != nil && m.TotalDmfileRsLoadMs != nil {
		return *m.TotalDmfileRsLoadMs
	}
	return 0
}

func (m *TiFlashScanContext) GetTotalDmfileReadMs() uint64 {
	if m != nil && m.TotalDmfileReadMs != nil {
		return *m.TotalDmfileReadMs
	}
	return 0
}

func (m *TiFlashScanContext) GetTotalBuildSnapshotMs() uint64 {
	if m != nil && m.TotalBuildSnapshotMs != nil {
		return *m.TotalBuildSnapshotMs
	}
	return 0
}

func (m *TiFlashScanContext) GetLocalRegions() uint64 {
	if m != nil && m.LocalRegions != nil {
		return *m.LocalRegions
	}
	return 0
}

func (m *TiFlashScanContext) GetRemoteRegions() uint64 {
	if m != nil && m.RemoteRegions != nil {
		return *m.RemoteRegions
	}
	return 0
}

func (m *TiFlashScanContext) GetUserReadBytes() uint64 {
	if m != nil && m.UserReadBytes != nil {
		return *m.UserReadBytes
	}
	return 0
}

func (m *TiFlashScanContext) GetTotalLearnerReadMs() uint64 {
	if m != nil && m.TotalLearnerReadMs != nil {
		return *m.TotalLearnerReadMs
	}
	return 0
}

func (m *TiFlashScanContext) GetDisaggReadCacheHitBytes() uint64 {
	if m != nil && m.DisaggReadCacheHitBytes != nil {
		return *m.DisaggReadCacheHitBytes
	}
	return 0
}

func (m *TiFlashScanContext) GetDisaggReadCacheMissBytes() uint64 {
	if m != nil && m.DisaggReadCacheMissBytes != nil {
		return *m.DisaggReadCacheMissBytes
	}
	return 0
}

func (m *TiFlashScanContext) GetTotalDmfileRsCheckMs() uint64 {
	if m != nil && m.TotalDmfileRsCheckMs != nil {
		return *m.TotalDmfileRsCheckMs
	}
	return 0
}

func (m *TiFlashScanContext) GetStaleReadRegions() uint64 {
	if m != nil && m.StaleReadRegions != nil {
		return *m.StaleReadRegions
	}
	return 0
}

func (m *TiFlashScanContext) GetSegments() uint64 {
	if m != nil && m.Segments != nil {
		return *m.Segments
	}
	return 0
}

func (m *TiFlashScanContext) GetReadTasks() uint64 {
	if m != nil && m.ReadTasks != nil {
		return *m.ReadTasks
	}
	return 0
}

func (m *TiFlashScanContext) GetDeltaRows() uint64 {
	if m != nil && m.DeltaRows != nil {
		return *m.DeltaRows
	}
	return 0
}

func (m *TiFlashScanContext) GetDeltaBytes() uint64 {
	if m != nil && m.DeltaBytes != nil {
		return *m.DeltaBytes
	}
	return 0
}

func (m *TiFlashScanContext) GetMvccInputRows() uint64 {
	if m != nil && m.MvccInputRows != nil {
		return *m.MvccInputRows
	}
	return 0
}

func (m *TiFlashScanContext) GetMvccInputBytes() uint64 {
	if m != nil && m.MvccInputBytes != nil {
		return *m.MvccInputBytes
	}
	return 0
}

func (m *TiFlashScanContext) GetMvccOutputRows() uint64 {
	if m != nil && m.MvccOutputRows != nil {
		return *m.MvccOutputRows
	}
	return 0
}

func (m *TiFlashScanContext) GetLmSkipRows() uint64 {
	if m != nil && m.LmSkipRows != nil {
		return *m.LmSkipRows
	}
	return 0
}

func (m *TiFlashScanContext) GetTotalBuildInputstreamMs() uint64 {
	if m != nil && m.TotalBuildInputstreamMs != nil {
		return *m.TotalBuildInputstreamMs
	}
	return 0
}

func (m *TiFlashScanContext) GetTotalBuildBitmapMs() uint64 {
	if m != nil && m.TotalBuildBitmapMs != nil {
		return *m.TotalBuildBitmapMs
	}
	return 0
}

func (m *TiFlashScanContext) GetMinLocalStreamMs() uint64 {
	if m != nil && m.MinLocalStreamMs != nil {
		return *m.MinLocalStreamMs
	}
	return 0
}

func (m *TiFlashScanContext) GetMaxLocalStreamMs() uint64 {
	if m != nil && m.MaxLocalStreamMs != nil {
		return *m.MaxLocalStreamMs
	}
	return 0
}

func (m *TiFlashScanContext) GetMinRemoteStreamMs() uint64 {
	if m != nil && m.MinRemoteStreamMs != nil {
		return *m.MinRemoteStreamMs
	}
	return 0
}

func (m *TiFlashScanContext) GetMaxRemoteStreamMs() uint64 {
	if m != nil && m.MaxRemoteStreamMs != nil {
		return *m.MaxRemoteStreamMs
	}
	return 0
}

func (m *TiFlashScanContext) GetRegionsOfInstance() []*TiFlashRegionNumOfInstance {
	if m != nil {
		return m.RegionsOfInstance
	}
	return nil
}

func (m *TiFlashScanContext) GetDmfileMvccScannedRows() uint64 {
	if m != nil && m.DmfileMvccScannedRows != nil {
		return *m.DmfileMvccScannedRows
	}
	return 0
}

func (m *TiFlashScanContext) GetDmfileMvccSkippedRows() uint64 {
	if m != nil && m.DmfileMvccSkippedRows != nil {
		return *m.DmfileMvccSkippedRows
	}
	return 0
}

func (m *TiFlashScanContext) GetDmfileLmFilterScannedRows() uint64 {
	if m != nil && m.DmfileLmFilterScannedRows != nil {
		return *m.DmfileLmFilterScannedRows
	}
	return 0
}

func (m *TiFlashScanContext) GetDmfileLmFilterSkippedRows() uint64 {
	if m != nil && m.DmfileLmFilterSkippedRows != nil {
		return *m.DmfileLmFilterSkippedRows
	}
	return 0
}

func (m *TiFlashScanContext) GetTotalVectorIdxLoadFromS3() uint64 {
	if m != nil && m.TotalVectorIdxLoadFromS3 != nil {
		return *m.TotalVectorIdxLoadFromS3
	}
	return 0
}

func (m *TiFlashScanContext) GetTotalVectorIdxLoadFromDisk() uint64 {
	if m != nil && m.TotalVectorIdxLoadFromDisk != nil {
		return *m.TotalVectorIdxLoadFromDisk
	}
	return 0
}

func (m *TiFlashScanContext) GetTotalVectorIdxLoadFromCache() uint64 {
	if m != nil && m.TotalVectorIdxLoadFromCache != nil {
		return *m.TotalVectorIdxLoadFromCache
	}
	return 0
}

func (m *TiFlashScanContext) GetTotalVectorIdxLoadTimeMs() uint64 {
	if m != nil && m.TotalVectorIdxLoadTimeMs != nil {
		return *m.TotalVectorIdxLoadTimeMs
	}
	return 0
}

func (m *TiFlashScanContext) GetTotalVectorIdxSearchTimeMs() uint64 {
	if m != nil && m.TotalVectorIdxSearchTimeMs != nil {
		return *m.TotalVectorIdxSearchTimeMs
	}
	return 0
}

func (m *TiFlashScanContext) GetTotalVectorIdxSearchVisitedNodes() uint64 {
	if m != nil && m.TotalVectorIdxSearchVisitedNodes != nil {
		return *m.TotalVectorIdxSearchVisitedNodes
	}
	return 0
}

func (m *TiFlashScanContext) GetTotalVectorIdxSearchDiscardedNodes() uint64 {
	if m != nil && m.TotalVectorIdxSearchDiscardedNodes != nil {
		return *m.TotalVectorIdxSearchDiscardedNodes
	}
	return 0
}

func (m *TiFlashScanContext) GetTotalVectorIdxReadVecTimeMs() uint64 {
	if m != nil && m.TotalVectorIdxReadVecTimeMs != nil {
		return *m.TotalVectorIdxReadVecTimeMs
	}
	return 0
}

func (m *TiFlashScanContext) GetTotalVectorIdxReadOthersTimeMs() uint64 {
	if m != nil && m.TotalVectorIdxReadOthersTimeMs != nil {
		return *m.TotalVectorIdxReadOthersTimeMs
	}
	return 0
}

type TiFlashWaitSummary struct {
	MinTSOWaitNs          *uint64 `protobuf:"varint,1,opt,name=minTSO_wait_ns,json=minTSOWaitNs" json:"minTSO_wait_ns,omitempty"`
	PipelineQueueWaitNs   *uint64 `protobuf:"varint,2,opt,name=pipeline_queue_wait_ns,json=pipelineQueueWaitNs" json:"pipeline_queue_wait_ns,omitempty"`
	PipelineBreakerWaitNs *uint64 `protobuf:"varint,3,opt,name=pipeline_breaker_wait_ns,json=pipelineBreakerWaitNs" json:"pipeline_breaker_wait_ns,omitempty"`
}

func (m *TiFlashWaitSummary) Reset()         { *m = TiFlashWaitSummary{} }
func (m *TiFlashWaitSummary) String() string { return proto.CompactTextString(m) }
func (*TiFlashWaitSummary) ProtoMessage()    {}
func (*TiFlashWaitSummary) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{22}
}
func (m *TiFlashWaitSummary) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TiFlashWaitSummary) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TiFlashWaitSummary.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TiFlashWaitSummary) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TiFlashWaitSummary.Merge(m, src)
}
func (m *TiFlashWaitSummary) XXX_Size() int {
	return m.Size()
}
func (m *TiFlashWaitSummary) XXX_DiscardUnknown() {
	xxx_messageInfo_TiFlashWaitSummary.DiscardUnknown(m)
}

var xxx_messageInfo_TiFlashWaitSummary proto.InternalMessageInfo

func (m *TiFlashWaitSummary) GetMinTSOWaitNs() uint64 {
	if m != nil && m.MinTSOWaitNs != nil {
		return *m.MinTSOWaitNs
	}
	return 0
}

func (m *TiFlashWaitSummary) GetPipelineQueueWaitNs() uint64 {
	if m != nil && m.PipelineQueueWaitNs != nil {
		return *m.PipelineQueueWaitNs
	}
	return 0
}

func (m *TiFlashWaitSummary) GetPipelineBreakerWaitNs() uint64 {
	if m != nil && m.PipelineBreakerWaitNs != nil {
		return *m.PipelineBreakerWaitNs
	}
	return 0
}

type TiFlashNetWorkSummary struct {
	InnerZoneSendBytes    *uint64 `protobuf:"varint,1,opt,name=inner_zone_send_bytes,json=innerZoneSendBytes" json:"inner_zone_send_bytes,omitempty"`
	InnerZoneReceiveBytes *uint64 `protobuf:"varint,2,opt,name=inner_zone_receive_bytes,json=innerZoneReceiveBytes" json:"inner_zone_receive_bytes,omitempty"`
	InterZoneSendBytes    *uint64 `protobuf:"varint,3,opt,name=inter_zone_send_bytes,json=interZoneSendBytes" json:"inter_zone_send_bytes,omitempty"`
	InterZoneReceiveBytes *uint64 `protobuf:"varint,4,opt,name=inter_zone_receive_bytes,json=interZoneReceiveBytes" json:"inter_zone_receive_bytes,omitempty"`
}

func (m *TiFlashNetWorkSummary) Reset()         { *m = TiFlashNetWorkSummary{} }
func (m *TiFlashNetWorkSummary) String() string { return proto.CompactTextString(m) }
func (*TiFlashNetWorkSummary) ProtoMessage()    {}
func (*TiFlashNetWorkSummary) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{23}
}
func (m *TiFlashNetWorkSummary) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TiFlashNetWorkSummary) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TiFlashNetWorkSummary.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TiFlashNetWorkSummary) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TiFlashNetWorkSummary.Merge(m, src)
}
func (m *TiFlashNetWorkSummary) XXX_Size() int {
	return m.Size()
}
func (m *TiFlashNetWorkSummary) XXX_DiscardUnknown() {
	xxx_messageInfo_TiFlashNetWorkSummary.DiscardUnknown(m)
}

var xxx_messageInfo_TiFlashNetWorkSummary proto.InternalMessageInfo

func (m *TiFlashNetWorkSummary) GetInnerZoneSendBytes() uint64 {
	if m != nil && m.InnerZoneSendBytes != nil {
		return *m.InnerZoneSendBytes
	}
	return 0
}

func (m *TiFlashNetWorkSummary) GetInnerZoneReceiveBytes() uint64 {
	if m != nil && m.InnerZoneReceiveBytes != nil {
		return *m.InnerZoneReceiveBytes
	}
	return 0
}

func (m *TiFlashNetWorkSummary) GetInterZoneSendBytes() uint64 {
	if m != nil && m.InterZoneSendBytes != nil {
		return *m.InterZoneSendBytes
	}
	return 0
}

func (m *TiFlashNetWorkSummary) GetInterZoneReceiveBytes() uint64 {
	if m != nil && m.InterZoneReceiveBytes != nil {
		return *m.InterZoneReceiveBytes
	}
	return 0
}

type Sort struct {
	ByItems       []*ByItem `protobuf:"bytes,1,rep,name=byItems" json:"byItems,omitempty"`
	IsPartialSort *bool     `protobuf:"varint,2,opt,name=isPartialSort" json:"isPartialSort,omitempty"`
	Child         *Executor `protobuf:"bytes,3,opt,name=child" json:"child,omitempty"`
}

func (m *Sort) Reset()         { *m = Sort{} }
func (m *Sort) String() string { return proto.CompactTextString(m) }
func (*Sort) ProtoMessage()    {}
func (*Sort) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{24}
}
func (m *Sort) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Sort) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Sort.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Sort) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Sort.Merge(m, src)
}
func (m *Sort) XXX_Size() int {
	return m.Size()
}
func (m *Sort) XXX_DiscardUnknown() {
	xxx_messageInfo_Sort.DiscardUnknown(m)
}

var xxx_messageInfo_Sort proto.InternalMessageInfo

func (m *Sort) GetByItems() []*ByItem {
	if m != nil {
		return m.ByItems
	}
	return nil
}

func (m *Sort) GetIsPartialSort() bool {
	if m != nil && m.IsPartialSort != nil {
		return *m.IsPartialSort
	}
	return false
}

func (m *Sort) GetChild() *Executor {
	if m != nil {
		return m.Child
	}
	return nil
}

type WindowFrameBound struct {
	Type        WindowBoundType   `protobuf:"varint,1,opt,name=type,enum=tipb.WindowBoundType" json:"type"`
	Unbounded   bool              `protobuf:"varint,2,opt,name=unbounded" json:"unbounded"`
	Offset      *uint64           `protobuf:"varint,3,opt,name=offset" json:"offset,omitempty"`
	CalcFuncs   []*Expr           `protobuf:"bytes,4,rep,name=calcFuncs" json:"calcFuncs,omitempty"`
	FrameRange  *Expr             `protobuf:"bytes,5,opt,name=frame_range,json=frameRange" json:"frame_range,omitempty"`
	CmpDataType *RangeCmpDataType `protobuf:"varint,6,opt,name=cmp_data_type,json=cmpDataType,enum=tipb.RangeCmpDataType" json:"cmp_data_type,omitempty"`
}

func (m *WindowFrameBound) Reset()         { *m = WindowFrameBound{} }
func (m *WindowFrameBound) String() string { return proto.CompactTextString(m) }
func (*WindowFrameBound) ProtoMessage()    {}
func (*WindowFrameBound) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{25}
}
func (m *WindowFrameBound) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WindowFrameBound) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WindowFrameBound.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WindowFrameBound) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WindowFrameBound.Merge(m, src)
}
func (m *WindowFrameBound) XXX_Size() int {
	return m.Size()
}
func (m *WindowFrameBound) XXX_DiscardUnknown() {
	xxx_messageInfo_WindowFrameBound.DiscardUnknown(m)
}

var xxx_messageInfo_WindowFrameBound proto.InternalMessageInfo

func (m *WindowFrameBound) GetType() WindowBoundType {
	if m != nil {
		return m.Type
	}
	return WindowBoundType_Following
}

func (m *WindowFrameBound) GetUnbounded() bool {
	if m != nil {
		return m.Unbounded
	}
	return false
}

func (m *WindowFrameBound) GetOffset() uint64 {
	if m != nil && m.Offset != nil {
		return *m.Offset
	}
	return 0
}

func (m *WindowFrameBound) GetCalcFuncs() []*Expr {
	if m != nil {
		return m.CalcFuncs
	}
	return nil
}

func (m *WindowFrameBound) GetFrameRange() *Expr {
	if m != nil {
		return m.FrameRange
	}
	return nil
}

func (m *WindowFrameBound) GetCmpDataType() RangeCmpDataType {
	if m != nil && m.CmpDataType != nil {
		return *m.CmpDataType
	}
	return RangeCmpDataType_Int
}

type WindowFrame struct {
	Type  WindowFrameType   `protobuf:"varint,1,opt,name=type,enum=tipb.WindowFrameType" json:"type"`
	Start *WindowFrameBound `protobuf:"bytes,2,opt,name=start" json:"start,omitempty"`
	End   *WindowFrameBound `protobuf:"bytes,3,opt,name=end" json:"end,omitempty"`
}

func (m *WindowFrame) Reset()         { *m = WindowFrame{} }
func (m *WindowFrame) String() string { return proto.CompactTextString(m) }
func (*WindowFrame) ProtoMessage()    {}
func (*WindowFrame) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{26}
}
func (m *WindowFrame) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WindowFrame) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WindowFrame.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WindowFrame) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WindowFrame.Merge(m, src)
}
func (m *WindowFrame) XXX_Size() int {
	return m.Size()
}
func (m *WindowFrame) XXX_DiscardUnknown() {
	xxx_messageInfo_WindowFrame.DiscardUnknown(m)
}

var xxx_messageInfo_WindowFrame proto.InternalMessageInfo

func (m *WindowFrame) GetType() WindowFrameType {
	if m != nil {
		return m.Type
	}
	return WindowFrameType_Rows
}

func (m *WindowFrame) GetStart() *WindowFrameBound {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *WindowFrame) GetEnd() *WindowFrameBound {
	if m != nil {
		return m.End
	}
	return nil
}

type Window struct {
	FuncDesc    []*Expr      `protobuf:"bytes,1,rep,name=func_desc,json=funcDesc" json:"func_desc,omitempty"`
	PartitionBy []*ByItem    `protobuf:"bytes,2,rep,name=partition_by,json=partitionBy" json:"partition_by,omitempty"`
	OrderBy     []*ByItem    `protobuf:"bytes,3,rep,name=order_by,json=orderBy" json:"order_by,omitempty"`
	Frame       *WindowFrame `protobuf:"bytes,4,opt,name=frame" json:"frame,omitempty"`
	Child       *Executor    `protobuf:"bytes,5,opt,name=child" json:"child,omitempty"`
}

func (m *Window) Reset()         { *m = Window{} }
func (m *Window) String() string { return proto.CompactTextString(m) }
func (*Window) ProtoMessage()    {}
func (*Window) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{27}
}
func (m *Window) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Window) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Window.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Window) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Window.Merge(m, src)
}
func (m *Window) XXX_Size() int {
	return m.Size()
}
func (m *Window) XXX_DiscardUnknown() {
	xxx_messageInfo_Window.DiscardUnknown(m)
}

var xxx_messageInfo_Window proto.InternalMessageInfo

func (m *Window) GetFuncDesc() []*Expr {
	if m != nil {
		return m.FuncDesc
	}
	return nil
}

func (m *Window) GetPartitionBy() []*ByItem {
	if m != nil {
		return m.PartitionBy
	}
	return nil
}

func (m *Window) GetOrderBy() []*ByItem {
	if m != nil {
		return m.OrderBy
	}
	return nil
}

func (m *Window) GetFrame() *WindowFrame {
	if m != nil {
		return m.Frame
	}
	return nil
}

func (m *Window) GetChild() *Executor {
	if m != nil {
		return m.Child
	}
	return nil
}

type GroupingExpr struct {
	GroupingExpr []*Expr `protobuf:"bytes,1,rep,name=grouping_expr,json=groupingExpr" json:"grouping_expr,omitempty"`
}

func (m *GroupingExpr) Reset()         { *m = GroupingExpr{} }
func (m *GroupingExpr) String() string { return proto.CompactTextString(m) }
func (*GroupingExpr) ProtoMessage()    {}
func (*GroupingExpr) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{28}
}
func (m *GroupingExpr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupingExpr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupingExpr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupingExpr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupingExpr.Merge(m, src)
}
func (m *GroupingExpr) XXX_Size() int {
	return m.Size()
}
func (m *GroupingExpr) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupingExpr.DiscardUnknown(m)
}

var xxx_messageInfo_GroupingExpr proto.InternalMessageInfo

func (m *GroupingExpr) GetGroupingExpr() []*Expr {
	if m != nil {
		return m.GroupingExpr
	}
	return nil
}

type GroupingSet struct {
	GroupingExprs []*GroupingExpr `protobuf:"bytes,1,rep,name=grouping_exprs,json=groupingExprs" json:"grouping_exprs,omitempty"`
}

func (m *GroupingSet) Reset()         { *m = GroupingSet{} }
func (m *GroupingSet) String() string { return proto.CompactTextString(m) }
func (*GroupingSet) ProtoMessage()    {}
func (*GroupingSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{29}
}
func (m *GroupingSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupingSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupingSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupingSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupingSet.Merge(m, src)
}
func (m *GroupingSet) XXX_Size() int {
	return m.Size()
}
func (m *GroupingSet) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupingSet.DiscardUnknown(m)
}

var xxx_messageInfo_GroupingSet proto.InternalMessageInfo

func (m *GroupingSet) GetGroupingExprs() []*GroupingExpr {
	if m != nil {
		return m.GroupingExprs
	}
	return nil
}

// Deprecated in the nearly feature usage
type Expand struct {
	GroupingSets []*GroupingSet `protobuf:"bytes,1,rep,name=grouping_sets,json=groupingSets" json:"grouping_sets,omitempty"`
	Child        *Executor      `protobuf:"bytes,2,opt,name=child" json:"child,omitempty"`
	Version      *uint64        `protobuf:"varint,3,opt,name=version" json:"version,omitempty"`
}

func (m *Expand) Reset()         { *m = Expand{} }
func (m *Expand) String() string { return proto.CompactTextString(m) }
func (*Expand) ProtoMessage()    {}
func (*Expand) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{30}
}
func (m *Expand) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Expand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Expand.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Expand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Expand.Merge(m, src)
}
func (m *Expand) XXX_Size() int {
	return m.Size()
}
func (m *Expand) XXX_DiscardUnknown() {
	xxx_messageInfo_Expand.DiscardUnknown(m)
}

var xxx_messageInfo_Expand proto.InternalMessageInfo

func (m *Expand) GetGroupingSets() []*GroupingSet {
	if m != nil {
		return m.GroupingSets
	}
	return nil
}

func (m *Expand) GetChild() *Executor {
	if m != nil {
		return m.Child
	}
	return nil
}

func (m *Expand) GetVersion() uint64 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return 0
}

type ExprSlice struct {
	Exprs []*Expr `protobuf:"bytes,1,rep,name=exprs" json:"exprs,omitempty"`
}

func (m *ExprSlice) Reset()         { *m = ExprSlice{} }
func (m *ExprSlice) String() string { return proto.CompactTextString(m) }
func (*ExprSlice) ProtoMessage()    {}
func (*ExprSlice) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{31}
}
func (m *ExprSlice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExprSlice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExprSlice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExprSlice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExprSlice.Merge(m, src)
}
func (m *ExprSlice) XXX_Size() int {
	return m.Size()
}
func (m *ExprSlice) XXX_DiscardUnknown() {
	xxx_messageInfo_ExprSlice.DiscardUnknown(m)
}

var xxx_messageInfo_ExprSlice proto.InternalMessageInfo

func (m *ExprSlice) GetExprs() []*Expr {
	if m != nil {
		return m.Exprs
	}
	return nil
}

type Expand2 struct {
	ProjExprs            []*ExprSlice `protobuf:"bytes,1,rep,name=proj_exprs,json=projExprs" json:"proj_exprs,omitempty"`
	GeneratedOutputNames []string     `protobuf:"bytes,2,rep,name=generated_output_names,json=generatedOutputNames" json:"generated_output_names,omitempty"`
	Child                *Executor    `protobuf:"bytes,3,opt,name=child" json:"child,omitempty"`
}

func (m *Expand2) Reset()         { *m = Expand2{} }
func (m *Expand2) String() string { return proto.CompactTextString(m) }
func (*Expand2) ProtoMessage()    {}
func (*Expand2) Descriptor() ([]byte, []int) {
	return fileDescriptor_12d1cdcda51e000f, []int{32}
}
func (m *Expand2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Expand2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Expand2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Expand2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Expand2.Merge(m, src)
}
func (m *Expand2) XXX_Size() int {
	return m.Size()
}
func (m *Expand2) XXX_DiscardUnknown() {
	xxx_messageInfo_Expand2.DiscardUnknown(m)
}

var xxx_messageInfo_Expand2 proto.InternalMessageInfo

func (m *Expand2) GetProjExprs() []*ExprSlice {
	if m != nil {
		return m.ProjExprs
	}
	return nil
}

func (m *Expand2) GetGeneratedOutputNames() []string {
	if m != nil {
		return m.GeneratedOutputNames
	}
	return nil
}

func (m *Expand2) GetChild() *Executor {
	if m != nil {
		return m.Child
	}
	return nil
}

func init() {
	proto.RegisterEnum("tipb.ExecType", ExecType_name, ExecType_value)
	proto.RegisterEnum("tipb.ExchangeType", ExchangeType_name, ExchangeType_value)
	proto.RegisterEnum("tipb.CompressionMode", CompressionMode_name, CompressionMode_value)
	proto.RegisterEnum("tipb.EngineType", EngineType_name, EngineType_value)
	proto.RegisterEnum("tipb.VectorIndexKind", VectorIndexKind_name, VectorIndexKind_value)
	proto.RegisterEnum("tipb.VectorDistanceMetric", VectorDistanceMetric_name, VectorDistanceMetric_value)
	proto.RegisterEnum("tipb.ANNQueryType", ANNQueryType_name, ANNQueryType_value)
	proto.RegisterEnum("tipb.ColumnarIndexType", ColumnarIndexType_name, ColumnarIndexType_value)
	proto.RegisterEnum("tipb.JoinType", JoinType_name, JoinType_value)
	proto.RegisterEnum("tipb.JoinExecType", JoinExecType_name, JoinExecType_value)
	proto.RegisterEnum("tipb.RuntimeFilterType", RuntimeFilterType_name, RuntimeFilterType_value)
	proto.RegisterEnum("tipb.RuntimeFilterMode", RuntimeFilterMode_name, RuntimeFilterMode_value)
	proto.RegisterEnum("tipb.TiFlashPreAggMode", TiFlashPreAggMode_name, TiFlashPreAggMode_value)
	proto.RegisterEnum("tipb.WindowBoundType", WindowBoundType_name, WindowBoundType_value)
	proto.RegisterEnum("tipb.RangeCmpDataType", RangeCmpDataType_name, RangeCmpDataType_value)
	proto.RegisterEnum("tipb.WindowFrameType", WindowFrameType_name, WindowFrameType_value)
	proto.RegisterType((*Executor)(nil), "tipb.Executor")
	proto.RegisterType((*ExchangeSender)(nil), "tipb.ExchangeSender")
	proto.RegisterType((*EncodedBytesSlice)(nil), "tipb.EncodedBytesSlice")
	proto.RegisterType((*ExchangeReceiver)(nil), "tipb.ExchangeReceiver")
	proto.RegisterType((*ANNQueryInfo)(nil), "tipb.ANNQueryInfo")
	proto.RegisterType((*InvertedQueryInfo)(nil), "tipb.InvertedQueryInfo")
	proto.RegisterType((*ColumnarIndexInfo)(nil), "tipb.ColumnarIndexInfo")
	proto.RegisterType((*TableScan)(nil), "tipb.TableScan")
	proto.RegisterType((*PartitionTableScan)(nil), "tipb.PartitionTableScan")
	proto.RegisterType((*Join)(nil), "tipb.Join")
	proto.RegisterType((*RuntimeFilter)(nil), "tipb.RuntimeFilter")
	proto.RegisterType((*IndexScan)(nil), "tipb.IndexScan")
	proto.RegisterType((*Selection)(nil), "tipb.Selection")
	proto.RegisterType((*Projection)(nil), "tipb.Projection")
	proto.RegisterType((*Aggregation)(nil), "tipb.Aggregation")
	proto.RegisterType((*TopN)(nil), "tipb.TopN")
	proto.RegisterType((*Limit)(nil), "tipb.Limit")
	proto.RegisterType((*Kill)(nil), "tipb.Kill")
	proto.RegisterType((*ExecutorExecutionSummary)(nil), "tipb.ExecutorExecutionSummary")
	proto.RegisterType((*TiFlashExecutionInfo)(nil), "tipb.TiFlashExecutionInfo")
	proto.RegisterType((*TiFlashRegionNumOfInstance)(nil), "tipb.TiFlashRegionNumOfInstance")
	proto.RegisterType((*TiFlashScanContext)(nil), "tipb.TiFlashScanContext")
	proto.RegisterType((*TiFlashWaitSummary)(nil), "tipb.TiFlashWaitSummary")
	proto.RegisterType((*TiFlashNetWorkSummary)(nil), "tipb.TiFlashNetWorkSummary")
	proto.RegisterType((*Sort)(nil), "tipb.Sort")
	proto.RegisterType((*WindowFrameBound)(nil), "tipb.WindowFrameBound")
	proto.RegisterType((*WindowFrame)(nil), "tipb.WindowFrame")
	proto.RegisterType((*Window)(nil), "tipb.Window")
	proto.RegisterType((*GroupingExpr)(nil), "tipb.GroupingExpr")
	proto.RegisterType((*GroupingSet)(nil), "tipb.GroupingSet")
	proto.RegisterType((*Expand)(nil), "tipb.Expand")
	proto.RegisterType((*ExprSlice)(nil), "tipb.ExprSlice")
	proto.RegisterType((*Expand2)(nil), "tipb.Expand2")
}

func init() { proto.RegisterFile("executor.proto", fileDescriptor_12d1cdcda51e000f) }

var fileDescriptor_12d1cdcda51e000f = []byte{
	// 4720 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x5a, 0xcd, 0x6f, 0x1b, 0x49,
	0x76, 0x17, 0x29, 0x52, 0x22, 0x1f, 0x29, 0xaa, 0x55, 0x92, 0x6c, 0xda, 0x5e, 0xdb, 0x1a, 0xae,
	0xbd, 0x23, 0x28, 0x3b, 0x1e, 0x8f, 0xec, 0x9d, 0xaf, 0xfd, 0x98, 0xd1, 0xe7, 0x98, 0xb6, 0x44,
	0x69, 0x9b, 0x8a, 0x67, 0xb1, 0x08, 0xd0, 0x68, 0x75, 0x17, 0xa9, 0xb2, 0xba, 0xab, 0xdb, 0x5d,
	0x4d, 0x4b, 0x9a, 0xd3, 0xe4, 0x9a, 0x53, 0x90, 0x20, 0x41, 0xce, 0x39, 0xed, 0x29, 0xff, 0x42,
	0x02, 0x04, 0x01, 0xf6, 0xb8, 0xc8, 0x69, 0x13, 0x20, 0x41, 0x30, 0x73, 0xca, 0x29, 0xf7, 0x9c,
	0x82, 0x7a, 0x55, 0xdd, 0x2c, 0x8a, 0x94, 0xc6, 0x93, 0xec, 0x21, 0x27, 0xb2, 0xdf, 0xfb, 0xfd,
	0x5e, 0x7d, 0xbd, 0x57, 0xf5, 0xea, 0x75, 0x43, 0x83, 0x9e, 0x53, 0x6f, 0x90, 0x46, 0xc9, 0xa3,
	0x38, 0x89, 0xd2, 0x88, 0x94, 0x52, 0x16, 0x1f, 0xdf, 0xb6, 0xe8, 0x79, 0x9c, 0x50, 0x21, 0x58,
	0xc4, 0x95, 0xfc, 0x76, 0x5d, 0x78, 0x27, 0x34, 0x74, 0xf5, 0xd3, 0x52, 0x3f, 0xea, 0x47, 0xf8,
	0xf7, 0x7d, 0xf9, 0x4f, 0x4b, 0xe7, 0x93, 0x81, 0x48, 0xf1, 0xaf, 0x12, 0xb4, 0xfe, 0x71, 0x16,
	0x2a, 0x3b, 0xda, 0x3e, 0x79, 0x00, 0xc5, 0x34, 0x6e, 0x16, 0x56, 0x0a, 0xab, 0x8d, 0xf5, 0xc6,
	0x23, 0xd9, 0xcc, 0x23, 0xa9, 0x3b, 0xba, 0x88, 0xe9, 0x66, 0xe9, 0xb7, 0xff, 0x7e, 0x7f, 0xca,
	0x2e, 0xa6, 0x31, 0x59, 0x83, 0x4a, 0x7a, 0x1c, 0x38, 0xc2, 0x73, 0x79, 0xb3, 0xb8, 0x52, 0x58,
	0xad, 0xad, 0xcf, 0x2b, 0xec, 0x91, 0x7b, 0x1c, 0xd0, 0xae, 0xe7, 0x72, 0x7b, 0x36, 0x3d, 0x0e,
	0xe4, 0x1f, 0x89, 0x65, 0xfe, 0xb9, 0xc2, 0x4e, 0x9b, 0xd8, 0x36, 0xf7, 0xe9, 0xb9, 0xc2, 0x32,
	0x1f, 0xff, 0x90, 0xf7, 0xa0, 0x2a, 0x68, 0x40, 0xbd, 0x94, 0x45, 0xbc, 0x59, 0x32, 0xc1, 0xdd,
	0x4c, 0x6c, 0x0f, 0x11, 0xe4, 0x09, 0xd4, 0xdc, 0x7e, 0x3f, 0xa1, 0x7d, 0x17, 0x09, 0x65, 0x24,
	0x2c, 0x28, 0xc2, 0xc6, 0x50, 0x61, 0x9b, 0x28, 0x72, 0x0f, 0x4a, 0x69, 0x14, 0x77, 0x9a, 0x33,
	0x88, 0x06, 0xdd, 0xef, 0x28, 0xee, 0xd8, 0x28, 0x27, 0xef, 0x40, 0x39, 0x60, 0x21, 0x4b, 0x9b,
	0xb3, 0x08, 0xa8, 0x29, 0xc0, 0x9e, 0x14, 0xd9, 0x4a, 0x43, 0xb6, 0x60, 0x81, 0x9e, 0x7b, 0x27,
	0x2e, 0xef, 0x53, 0x27, 0xa1, 0x1e, 0x65, 0x6f, 0x68, 0xd2, 0xac, 0x20, 0xfc, 0x46, 0x36, 0x67,
	0x4a, 0x6d, 0x6b, 0xad, 0x6d, 0xd1, 0x4b, 0x12, 0xd9, 0x8f, 0x57, 0x11, 0xe3, 0xcd, 0xaa, 0xd9,
	0x8f, 0xe7, 0x11, 0xe3, 0x36, 0xca, 0xc9, 0x7d, 0xa8, 0x65, 0xab, 0xee, 0x30, 0xbf, 0x09, 0x2b,
	0x85, 0xd5, 0xaa, 0x0d, 0x99, 0xa8, 0xed, 0x4b, 0x03, 0xa7, 0x2c, 0x08, 0x9a, 0x35, 0xd3, 0xc0,
	0x0b, 0x16, 0x04, 0x36, 0xca, 0xc9, 0xcf, 0x61, 0x3e, 0xef, 0xa5, 0xa0, 0xdc, 0xa7, 0x49, 0xb3,
	0x8e, 0xd0, 0xa5, 0xd1, 0x3e, 0x76, 0x51, 0x67, 0x37, 0xe8, 0xc8, 0x33, 0x79, 0x0c, 0x70, 0x98,
	0x44, 0xaf, 0xf4, 0x62, 0xcc, 0x21, 0xd3, 0x52, 0xcc, 0xa1, 0xdc, 0x36, 0x30, 0xe4, 0x39, 0x2c,
	0xc5, 0x6e, 0x92, 0x32, 0xf9, 0xe0, 0xa4, 0xd2, 0x13, 0xd4, 0xaa, 0x37, 0x90, 0xdb, 0xd4, 0xdc,
	0x0c, 0x31, 0x74, 0x15, 0x12, 0x8f, 0xc9, 0xe4, 0xe0, 0x44, 0x94, 0xa4, 0xcd, 0x79, 0x73, 0x70,
	0xdd, 0x28, 0x49, 0x6d, 0x94, 0x93, 0x07, 0x30, 0x73, 0xc6, 0xb8, 0x1f, 0x9d, 0x35, 0x2d, 0x44,
	0xd4, 0x15, 0xe2, 0x4b, 0x94, 0xd9, 0x5a, 0x47, 0x3a, 0xf0, 0x4e, 0x8f, 0x71, 0xea, 0xf4, 0x13,
	0x97, 0x71, 0xea, 0x3b, 0xe2, 0x64, 0xd0, 0xeb, 0xc9, 0x6e, 0xa5, 0x09, 0x75, 0x43, 0xc7, 0x8b,
	0x06, 0x3c, 0x6d, 0x2e, 0xac, 0x14, 0x56, 0x4b, 0xda, 0xb9, 0xef, 0x4a, 0xf8, 0x17, 0x0a, 0xdd,
	0x55, 0xe0, 0x2e, 0x62, 0xb7, 0x24, 0x94, 0x3c, 0x87, 0xfb, 0x13, 0xed, 0x1d, 0xbb, 0xa9, 0x77,
	0xe2, 0x08, 0xf6, 0x15, 0x6d, 0x12, 0xc3, 0xda, 0x9d, 0x71, 0x6b, 0x9b, 0x12, 0xd9, 0x65, 0x5f,
	0x51, 0x39, 0x02, 0x7a, 0x1e, 0xbb, 0xdc, 0x6f, 0x2e, 0x9a, 0x23, 0xd8, 0x41, 0x99, 0xad, 0x75,
	0xe4, 0x5d, 0x98, 0x55, 0xff, 0xd6, 0x9b, 0x4b, 0x08, 0x9b, 0x33, 0x61, 0xeb, 0x76, 0xa6, 0x6d,
	0xfd, 0xf3, 0x34, 0x34, 0x46, 0x57, 0x94, 0xac, 0x1a, 0xb1, 0x4c, 0x46, 0xd7, 0x7c, 0x2c, 0x9e,
	0x17, 0x28, 0xf7, 0x22, 0x9f, 0xfa, 0x4e, 0xea, 0x8a, 0x53, 0x27, 0xa4, 0xa9, 0xdb, 0x2c, 0xae,
	0x4c, 0xaf, 0xd6, 0xed, 0x79, 0xad, 0x38, 0x72, 0xc5, 0xe9, 0x3e, 0x4d, 0x5d, 0xf2, 0x01, 0x34,
	0x86, 0xab, 0x7c, 0x4a, 0x2f, 0x44, 0x73, 0x7a, 0x65, 0x7a, 0xb8, 0x46, 0x3b, 0xe7, 0x71, 0x62,
	0xcf, 0xe5, 0x88, 0x17, 0xf4, 0x42, 0x90, 0x07, 0x50, 0xf6, 0x4e, 0x58, 0xe0, 0xeb, 0x90, 0x36,
	0xf6, 0x15, 0xe9, 0xca, 0xb6, 0x52, 0x92, 0x87, 0x50, 0x4e, 0x2f, 0x62, 0x2a, 0x9a, 0x65, 0xb4,
	0xa7, 0x03, 0x7f, 0x97, 0xd1, 0xc0, 0x97, 0xdd, 0xb5, 0x95, 0x96, 0x7c, 0x04, 0xf3, 0x6e, 0x10,
	0x38, 0x3d, 0x29, 0x77, 0x14, 0x61, 0x66, 0x32, 0x61, 0xce, 0x0d, 0x82, 0xfc, 0x49, 0x90, 0x9f,
	0x43, 0xcd, 0x8b, 0xc2, 0x6c, 0xc7, 0xc4, 0xf0, 0x6e, 0xac, 0x2f, 0x2b, 0xd2, 0xd6, 0x50, 0xb1,
	0x1f, 0xf9, 0xd9, 0xd4, 0x98, 0x78, 0xb2, 0x07, 0x37, 0x06, 0x71, 0xe6, 0x38, 0x29, 0x35, 0x26,
	0xaa, 0x82, 0xcd, 0xdf, 0xd4, 0xa3, 0x52, 0xd3, 0xb5, 0x79, 0x91, 0x52, 0xd1, 0x0d, 0x98, 0x47,
	0xed, 0xc5, 0x8c, 0xb6, 0x95, 0xd2, 0x7c, 0x16, 0x1f, 0x40, 0x43, 0xb8, 0x21, 0x75, 0xbe, 0x8a,
	0x38, 0x75, 0x7a, 0x81, 0xdb, 0x6f, 0x56, 0x57, 0xa6, 0x57, 0x2b, 0x76, 0x5d, 0x4a, 0x7f, 0x1d,
	0x71, 0xba, 0x1b, 0xb8, 0xfd, 0xd6, 0xc7, 0xb0, 0x30, 0x66, 0x8f, 0xfc, 0x10, 0xe6, 0xcc, 0xc5,
	0x12, 0xcd, 0x02, 0x2e, 0x54, 0xdd, 0x58, 0x28, 0xd1, 0xfa, 0xba, 0x08, 0xd6, 0xe5, 0x4d, 0x68,
	0xf2, 0x32, 0x17, 0x26, 0x2f, 0xf3, 0x63, 0xa8, 0x99, 0x53, 0x5c, 0x9c, 0x3c, 0xc5, 0xd0, 0x1b,
	0xce, 0x6f, 0x0b, 0xdd, 0x6d, 0xfa, 0x2a, 0x77, 0x43, 0x47, 0xdb, 0x86, 0xfb, 0x51, 0xc2, 0xfa,
	0x8c, 0xbb, 0x01, 0x4e, 0x62, 0x9c, 0xf8, 0x91, 0x37, 0xa0, 0x89, 0xd1, 0x9f, 0x12, 0xf6, 0xe7,
	0x4e, 0x06, 0xdb, 0x4a, 0xe9, 0xa1, 0x06, 0x5d, 0x33, 0x79, 0xe5, 0x09, 0x93, 0xf7, 0x67, 0x25,
	0xa8, 0x6f, 0x74, 0x3a, 0xbf, 0x1c, 0xd0, 0xe4, 0xa2, 0xcd, 0x7b, 0x11, 0xf9, 0x08, 0xe0, 0xb5,
	0x7c, 0xc0, 0x21, 0x8d, 0xc6, 0x45, 0x86, 0x33, 0xe2, 0xa2, 0xfa, 0x3a, 0x13, 0x90, 0x36, 0xcc,
	0xfb, 0x4c, 0xa4, 0x2e, 0xf7, 0xa8, 0xec, 0x63, 0xc2, 0x3c, 0x3c, 0xf5, 0x1a, 0xeb, 0xb7, 0x15,
	0xfb, 0x25, 0xf5, 0xd2, 0x28, 0xd9, 0xd6, 0x90, 0x7d, 0x44, 0x68, 0x2b, 0x0d, 0x7f, 0x44, 0x4a,
	0x6e, 0x41, 0x39, 0x8d, 0x62, 0xe7, 0x14, 0xe7, 0x69, 0x4e, 0x83, 0xe4, 0xc1, 0xf3, 0x82, 0x3c,
	0x94, 0xfe, 0x19, 0x0c, 0x42, 0xee, 0x70, 0x37, 0xa4, 0x18, 0x2b, 0x55, 0x0d, 0x00, 0xa5, 0xe8,
	0xb8, 0x21, 0x25, 0x8f, 0x61, 0xc9, 0xa7, 0x71, 0x42, 0x3d, 0x37, 0xa5, 0xbe, 0xa3, 0x19, 0xcc,
	0xc7, 0xd3, 0x6f, 0xda, 0x26, 0x43, 0xdd, 0x16, 0xaa, 0xf0, 0xa0, 0xa8, 0x25, 0xb4, 0xe7, 0xbc,
	0xa1, 0x9e, 0xd3, 0x7b, 0xb2, 0x8e, 0x07, 0x5f, 0xdd, 0xae, 0x26, 0xb4, 0xf7, 0x92, 0x7a, 0xbb,
	0x4f, 0xd6, 0xc9, 0x7d, 0xa8, 0x30, 0x79, 0x16, 0x4b, 0x2b, 0xf2, 0x14, 0x9b, 0xd6, 0xad, 0xce,
	0xa2, 0xb4, 0x2d, 0x37, 0xa1, 0x7a, 0xe8, 0x9e, 0x3b, 0xd9, 0x50, 0xf0, 0x2c, 0x2a, 0x64, 0x31,
	0x12, 0xba, 0xe7, 0xd9, 0xc8, 0xc9, 0x1a, 0x34, 0x4e, 0xb8, 0x38, 0x73, 0x68, 0xcf, 0x11, 0xd4,
	0x4d, 0xbc, 0x13, 0xdc, 0xb4, 0xb2, 0x61, 0xd6, 0xa5, 0x6e, 0xa7, 0xd7, 0x45, 0x0d, 0x79, 0x04,
	0x33, 0xaa, 0xf3, 0xcd, 0x65, 0xf3, 0x6c, 0xd1, 0xbd, 0xe6, 0xbd, 0x48, 0xb3, 0x34, 0x8a, 0x7c,
	0x08, 0x4b, 0x94, 0xe3, 0xa1, 0x92, 0xaf, 0x45, 0x9c, 0x44, 0xaf, 0x9a, 0x37, 0x56, 0x0a, 0xab,
	0x15, 0x8d, 0x25, 0x0a, 0x91, 0xf5, 0x47, 0x9e, 0x4d, 0xcf, 0x4b, 0x95, 0x59, 0xab, 0xd2, 0xfa,
	0x12, 0x16, 0xda, 0xfc, 0x0d, 0x4d, 0x52, 0xea, 0x0f, 0x1d, 0xc2, 0x1c, 0x78, 0x61, 0xd2, 0xc0,
	0xdf, 0x81, 0xea, 0x70, 0x82, 0x8b, 0x06, 0xa2, 0xe2, 0xe9, 0xc9, 0x6d, 0xfd, 0x5b, 0x01, 0x16,
	0x54, 0x9f, 0xdd, 0x04, 0x33, 0x1a, 0xb4, 0xfc, 0x33, 0x00, 0x65, 0xd9, 0x70, 0xb5, 0x9b, 0xe6,
	0x00, 0x35, 0xd8, 0xf4, 0x37, 0x96, 0x09, 0xc8, 0xa7, 0xd0, 0x70, 0x39, 0x77, 0x94, 0xb3, 0x32,
	0xde, 0x8b, 0x74, 0x92, 0x75, 0xc9, 0x59, 0x65, 0x4b, 0xcf, 0xa6, 0xec, 0xba, 0xcb, 0xf9, 0x70,
	0x4c, 0x3b, 0xb0, 0xc0, 0x70, 0xa0, 0x26, 0x5d, 0xe5, 0x5d, 0x37, 0xb3, 0xbc, 0xeb, 0xd2, 0x3c,
	0x3c, 0x9b, 0xb2, 0xe7, 0x15, 0x27, 0x17, 0x6d, 0xce, 0x42, 0x19, 0xfb, 0xd3, 0xfa, 0xa6, 0x0c,
	0xd5, 0xe1, 0xb1, 0x7c, 0x1f, 0x2a, 0xea, 0x60, 0xbf, 0x3c, 0x63, 0x28, 0x6d, 0xfb, 0x64, 0x0d,
	0x66, 0xd5, 0xd4, 0x64, 0x5b, 0xc6, 0xd8, 0xb2, 0xda, 0x19, 0x80, 0x34, 0xa1, 0xe4, 0x53, 0xe1,
	0x61, 0xef, 0xb2, 0x15, 0x44, 0x09, 0xf9, 0x31, 0x90, 0x38, 0x61, 0xa1, 0x9b, 0x5c, 0x0c, 0x1d,
	0x5c, 0xe0, 0xce, 0x30, 0x6d, 0x5b, 0x5a, 0x93, 0xb9, 0xb7, 0x20, 0x9f, 0x83, 0xc5, 0xe9, 0x79,
	0xea, 0x24, 0xd4, 0xf5, 0x1d, 0xca, 0xfb, 0x8c, 0x53, 0x8c, 0x86, 0x46, 0xd6, 0xf8, 0x0e, 0xca,
	0x8c, 0xb9, 0x6e, 0x48, 0xbc, 0x4d, 0x5d, 0x5f, 0x69, 0xc8, 0x8f, 0x61, 0x26, 0x91, 0xfb, 0x54,
	0x76, 0x94, 0xe8, 0x13, 0xea, 0x05, 0xbd, 0xb0, 0xa5, 0x38, 0xf3, 0x44, 0x85, 0x21, 0x9f, 0xc0,
	0xad, 0xac, 0x77, 0x71, 0x42, 0x7b, 0xec, 0xdc, 0xec, 0xe4, 0x2c, 0x76, 0xf2, 0x86, 0x06, 0x1c,
	0xa2, 0x7e, 0xd8, 0xd5, 0xbb, 0x00, 0xa7, 0x94, 0xc6, 0x4e, 0x94, 0xf8, 0x3a, 0x65, 0xac, 0xd8,
	0x55, 0x29, 0x39, 0x90, 0x02, 0xb2, 0x02, 0x75, 0x26, 0x9c, 0x9e, 0x2b, 0x52, 0x95, 0x39, 0x55,
	0x11, 0x00, 0x4c, 0xec, 0xba, 0x22, 0xc5, 0x05, 0xd8, 0x87, 0xbb, 0xf1, 0x40, 0x9c, 0x50, 0xdf,
	0xf1, 0xa3, 0x33, 0xee, 0xf4, 0x58, 0x90, 0xd2, 0xc4, 0xf1, 0x22, 0xee, 0xe3, 0x71, 0x2b, 0x9a,
	0x30, 0x76, 0x18, 0xdf, 0x56, 0x84, 0xed, 0xe8, 0x8c, 0xef, 0x22, 0x7c, 0x2b, 0x47, 0x93, 0x2d,
	0x58, 0x4c, 0x06, 0x3c, 0x65, 0x21, 0xcd, 0x4c, 0x05, 0x4c, 0xa4, 0xcd, 0x1a, 0x1a, 0x59, 0x54,
	0x46, 0x6c, 0x05, 0x50, 0x5c, 0x7b, 0x21, 0x31, 0x1f, 0xf7, 0x98, 0x48, 0xc9, 0x7b, 0x60, 0xc9,
	0xed, 0xe1, 0xcc, 0x65, 0xa9, 0x83, 0xa6, 0x42, 0x81, 0x99, 0x66, 0x59, 0xcf, 0xdb, 0x5c, 0xe8,
	0x9e, 0x7f, 0xe9, 0xb2, 0xf4, 0x88, 0x85, 0x74, 0x5f, 0x90, 0xed, 0x91, 0x0d, 0x2c, 0x77, 0x74,
	0x9d, 0x62, 0x4e, 0xf0, 0x71, 0x73, 0x53, 0xdb, 0xd0, 0xbe, 0x4e, 0x5e, 0xc0, 0xf2, 0x40, 0xe4,
	0x1b, 0xa0, 0x9b, 0x38, 0xe8, 0xae, 0x54, 0x34, 0x1b, 0xe6, 0x69, 0x3c, 0x16, 0x99, 0xf6, 0xa2,
	0x64, 0x8d, 0x88, 0xa9, 0x68, 0xfd, 0x69, 0x19, 0xc8, 0x78, 0x62, 0xfa, 0xff, 0xd3, 0xdb, 0xaf,
	0xf5, 0xbe, 0xf2, 0xb5, 0xde, 0xf7, 0x43, 0x18, 0x26, 0x66, 0x08, 0x9f, 0x41, 0x78, 0x3d, 0x17,
	0x4a, 0xd0, 0x65, 0x1f, 0x9c, 0xfd, 0xfe, 0x3e, 0x58, 0xf9, 0x43, 0xf8, 0x60, 0xf5, 0xff, 0xec,
	0x83, 0xf0, 0xfd, 0x7d, 0xb0, 0xf6, 0x87, 0xf1, 0xc1, 0xfa, 0xff, 0xc2, 0x07, 0xff, 0xbb, 0x0c,
	0x25, 0x79, 0xfd, 0x23, 0x1f, 0x40, 0x55, 0x5e, 0x00, 0xcd, 0xa3, 0xa3, 0x31, 0xbc, 0x1d, 0x1a,
	0xbb, 0x58, 0xe5, 0x95, 0x7e, 0x26, 0xbf, 0x80, 0x06, 0x52, 0xe4, 0xed, 0x50, 0xf1, 0x8a, 0x66,
	0x76, 0x23, 0x79, 0x97, 0x6e, 0xf1, 0xf5, 0x57, 0x86, 0x4c, 0xde, 0xd1, 0x31, 0x07, 0x4f, 0x28,
	0xd7, 0xd9, 0xfc, 0xe5, 0x1c, 0x3d, 0xd7, 0xcb, 0x33, 0x91, 0x71, 0x4e, 0xe5, 0xa5, 0xf4, 0x1c,
	0x93, 0x94, 0xfc, 0x4c, 0x44, 0x71, 0xdb, 0x3f, 0x27, 0x8f, 0xa1, 0x11, 0xd0, 0x5e, 0xea, 0x60,
	0x9f, 0xf0, 0x8a, 0x50, 0x1e, 0xf3, 0x88, 0xba, 0x44, 0xc8, 0x8e, 0xe1, 0x0d, 0x61, 0x1d, 0xe6,
	0x13, 0xd6, 0x3f, 0x31, 0x29, 0x33, 0xe3, 0xb7, 0x0a, 0x84, 0xe4, 0x9c, 0xc7, 0x50, 0x8b, 0x93,
	0xe8, 0x98, 0xea, 0x0c, 0x75, 0xf6, 0x8a, 0x0c, 0x15, 0x31, 0x2a, 0x43, 0x7d, 0x0c, 0xb5, 0xe3,
	0x01, 0xcb, 0x73, 0xda, 0xca, 0x15, 0x0c, 0xc4, 0x28, 0xc6, 0x13, 0x98, 0xc7, 0x91, 0x18, 0xce,
	0x5d, 0x1d, 0xeb, 0x17, 0x0e, 0xd6, 0x70, 0xe8, 0x9f, 0x80, 0xa5, 0x06, 0x73, 0xed, 0xb6, 0xac,
	0x06, 0x3c, 0x4a, 0x8b, 0xd2, 0x93, 0xd1, 0x48, 0xaa, 0x8d, 0xd3, 0x10, 0x63, 0xd0, 0x9e, 0xc1,
	0x1d, 0x45, 0xa3, 0xaf, 0x0d, 0xa6, 0xd3, 0x4b, 0xa2, 0xd0, 0x61, 0x5c, 0xbb, 0xa2, 0x69, 0xe1,
	0x26, 0xc2, 0x77, 0x5e, 0x0f, 0x6d, 0xec, 0x26, 0x51, 0xd8, 0xe6, 0xe4, 0x29, 0xdc, 0x64, 0xc2,
	0xe1, 0x83, 0x20, 0x70, 0xdc, 0x33, 0x37, 0xa1, 0x8e, 0xa0, 0x21, 0xc3, 0x15, 0xc1, 0xbd, 0xb9,
	0x62, 0x2f, 0x32, 0xd1, 0x19, 0x04, 0xc1, 0x86, 0x54, 0x76, 0x69, 0xc8, 0xd0, 0x5d, 0xaf, 0x08,
	0xdf, 0xc6, 0xf7, 0x09, 0xdf, 0xd6, 0x7f, 0x16, 0x61, 0x6e, 0x04, 0x44, 0x96, 0xa0, 0xa8, 0x77,
	0xdd, 0x2c, 0x84, 0x8b, 0xcc, 0x27, 0x4f, 0xc1, 0x12, 0xd1, 0x20, 0xf1, 0xa8, 0x43, 0xcf, 0x63,
	0xdd, 0x52, 0x71, 0x7c, 0x41, 0x14, 0x46, 0xfe, 0xc7, 0xcd, 0xe1, 0x29, 0x58, 0xa9, 0x9b, 0xf4,
	0x69, 0x6a, 0xb0, 0xc6, 0x2f, 0xad, 0x0d, 0x85, 0xc9, 0x59, 0xeb, 0x40, 0xf2, 0xb6, 0x86, 0x75,
	0x18, 0x33, 0x2d, 0xb7, 0xb2, 0x76, 0xf2, 0x9a, 0xcc, 0x3a, 0x90, 0xbc, 0xa5, 0x21, 0xa7, 0x6c,
	0x72, 0xb2, 0x56, 0x72, 0xce, 0x87, 0x30, 0x9b, 0xf4, 0x54, 0xd4, 0xce, 0x98, 0x89, 0xe2, 0xc8,
	0x7c, 0x18, 0xa1, 0x3b, 0x93, 0xf4, 0x30, 0x68, 0x15, 0x2f, 0x8c, 0x7c, 0xaa, 0xef, 0xb2, 0x93,
	0x78, 0xc6, 0x6d, 0x76, 0x26, 0xe9, 0xc9, 0xa7, 0xd6, 0xbf, 0x14, 0xa0, 0x9a, 0xd7, 0xde, 0xbe,
	0xfb, 0x8c, 0x33, 0x93, 0xe4, 0xe2, 0xa4, 0x24, 0xd9, 0x38, 0x04, 0xa7, 0xdf, 0xf6, 0x10, 0x2c,
	0x8d, 0x1d, 0x82, 0x37, 0x60, 0x66, 0xc0, 0xd9, 0xeb, 0x81, 0x4a, 0xdd, 0x2a, 0xb6, 0x7e, 0xba,
	0xe2, 0x70, 0x9c, 0x99, 0x7c, 0x38, 0xb6, 0xfe, 0xb2, 0x00, 0xd5, 0xbc, 0x54, 0x48, 0xd6, 0x00,
	0x8c, 0x58, 0x2a, 0x8c, 0xad, 0xb8, 0xa1, 0x25, 0x4f, 0xa1, 0x91, 0xc4, 0xdc, 0x8c, 0x3d, 0xe5,
	0x57, 0xba, 0xde, 0x62, 0xc7, 0x5c, 0xef, 0x41, 0x31, 0x37, 0x82, 0x2f, 0xaf, 0x6c, 0x4c, 0x5f,
	0x53, 0xd9, 0x68, 0x7d, 0x5d, 0x30, 0x6b, 0x69, 0x64, 0x05, 0xca, 0xd2, 0x0f, 0x27, 0xf5, 0x48,
	0x29, 0xc8, 0x1a, 0x54, 0x65, 0x67, 0x14, 0x6a, 0x62, 0x3f, 0x2a, 0x89, 0xfa, 0xf3, 0xb6, 0x5d,
	0xf8, 0x87, 0x22, 0xd4, 0x8c, 0x92, 0x28, 0x79, 0x08, 0x95, 0x7e, 0x12, 0x0d, 0x62, 0xe7, 0xf8,
	0x62, 0x42, 0x37, 0x66, 0x51, 0xb7, 0x79, 0x41, 0xde, 0x87, 0xba, 0xec, 0x48, 0x0e, 0x2d, 0x4d,
	0xea, 0x0b, 0x24, 0x31, 0xff, 0x42, 0x13, 0x1e, 0x42, 0xc5, 0xed, 0xf7, 0x9d, 0xde, 0x80, 0x7b,
	0x13, 0x02, 0x73, 0xd6, 0xed, 0xf7, 0x77, 0x07, 0xdc, 0xcb, 0xec, 0xe6, 0xd0, 0xf2, 0x55, 0x76,
	0x37, 0x34, 0x61, 0x05, 0x2a, 0xaa, 0x88, 0x42, 0xfd, 0x91, 0x0c, 0x2a, 0x97, 0x0e, 0xe7, 0x61,
	0xe6, 0xba, 0x22, 0xd3, 0x27, 0x50, 0x8f, 0x13, 0x8a, 0x0d, 0x8f, 0x47, 0xce, 0x11, 0xdb, 0x0d,
	0x5c, 0x71, 0x72, 0x98, 0xd0, 0x8d, 0x7e, 0x5f, 0xc6, 0x8a, 0x3c, 0x3d, 0xb2, 0xff, 0xad, 0xbf,
	0x2d, 0x40, 0xe9, 0x28, 0x8a, 0x3b, 0xe4, 0x5d, 0xa8, 0x60, 0xfe, 0x3e, 0x9c, 0x3b, 0x5d, 0xbb,
	0xdb, 0xbc, 0x68, 0xa7, 0x34, 0xb4, 0x67, 0x51, 0xbb, 0x79, 0x41, 0x6e, 0x67, 0xa5, 0xe4, 0xa2,
	0x51, 0x14, 0xd4, 0x35, 0xe4, 0xb7, 0x5a, 0x36, 0x39, 0x4f, 0xc3, 0x8c, 0x2d, 0x9f, 0xff, 0xd1,
	0xe6, 0x6a, 0x39, 0x62, 0xf3, 0xa2, 0xf5, 0x15, 0x94, 0xb1, 0x54, 0x3d, 0x6c, 0xbb, 0x70, 0x4d,
	0xdb, 0xc5, 0xef, 0xd3, 0xf6, 0xf4, 0x77, 0xb5, 0xfd, 0x39, 0x94, 0x5e, 0xb0, 0x20, 0x20, 0x3f,
	0x90, 0x37, 0x7b, 0xce, 0xdb, 0xdb, 0x23, 0x6d, 0x6b, 0x99, 0xec, 0x98, 0xca, 0xb5, 0x8a, 0xc6,
	0x32, 0x2a, 0x51, 0xeb, 0xeb, 0x12, 0x34, 0xb3, 0x6e, 0xa8, 0x5f, 0x16, 0xf1, 0xee, 0x20, 0x94,
	0x41, 0x4e, 0xd6, 0x60, 0x01, 0x4f, 0x99, 0x38, 0x89, 0x3c, 0x2a, 0x64, 0xde, 0x85, 0x41, 0x5d,
	0x58, 0x2d, 0xd9, 0xf3, 0x52, 0x71, 0x98, 0xc9, 0x3b, 0x32, 0x80, 0x16, 0xf8, 0x20, 0x94, 0x50,
	0x7f, 0xe0, 0x51, 0xdf, 0x49, 0xa2, 0x33, 0xa1, 0x56, 0xc1, 0x9e, 0xe7, 0x83, 0xf0, 0x50, 0xcb,
	0xed, 0xe8, 0x4c, 0x90, 0x87, 0xd0, 0x90, 0x58, 0x96, 0xd2, 0xc4, 0x55, 0x91, 0x3f, 0x8d, 0xc0,
	0x39, 0x3e, 0x08, 0xdb, 0xb9, 0xf0, 0x72, 0x3d, 0xbe, 0x34, 0x56, 0x8f, 0x5f, 0x81, 0x9a, 0x17,
	0x71, 0x6f, 0x90, 0x24, 0x94, 0x7b, 0x17, 0xb8, 0x8d, 0x95, 0x6c, 0x53, 0x44, 0xf6, 0x60, 0x29,
	0x65, 0x3d, 0xe9, 0x62, 0x98, 0x5a, 0xcb, 0xcd, 0x26, 0xa5, 0xe7, 0xa9, 0xf6, 0xd8, 0xe6, 0x88,
	0x13, 0xca, 0xcd, 0x79, 0x4b, 0xe9, 0x9f, 0x4d, 0xd9, 0x44, 0xf3, 0x0c, 0xa9, 0xec, 0x77, 0x32,
	0x90, 0x36, 0xc4, 0x20, 0x8c, 0xd3, 0xac, 0xa4, 0x59, 0xb7, 0xe7, 0x92, 0xc1, 0xd6, 0x50, 0x48,
	0x9e, 0x0f, 0x1b, 0xc5, 0xec, 0x58, 0xa8, 0xe9, 0xd4, 0xef, 0x2b, 0x46, 0x1b, 0x95, 0x19, 0xb2,
	0x9e, 0xee, 0xbc, 0x49, 0x43, 0x46, 0xba, 0x70, 0x33, 0xb3, 0xc5, 0x69, 0x7a, 0x16, 0x25, 0xa7,
	0xb9, 0x39, 0xf5, 0x1a, 0xe3, 0xce, 0x88, 0xb9, 0x0e, 0x4d, 0xbf, 0x8c, 0x92, 0xd3, 0xcc, 0xe2,
	0xb2, 0xe6, 0x76, 0x14, 0x55, 0x8b, 0x37, 0xeb, 0x00, 0xdb, 0x34, 0x75, 0x59, 0x20, 0x8f, 0x8a,
	0x56, 0x1f, 0x96, 0x34, 0x3b, 0x77, 0x00, 0xac, 0x6b, 0x1c, 0xc0, 0x22, 0xcd, 0x04, 0xba, 0x51,
	0x46, 0xb3, 0x2d, 0xf4, 0xde, 0xa8, 0x07, 0x5f, 0x76, 0x1d, 0x9b, 0xd0, 0x51, 0x09, 0xa3, 0xa2,
	0xf5, 0x27, 0x70, 0x5b, 0x37, 0x64, 0xd3, 0x3e, 0x8b, 0x78, 0x67, 0x10, 0x1e, 0xf4, 0xda, 0x5c,
	0x57, 0xb2, 0xee, 0x43, 0x8d, 0xe9, 0xff, 0xd9, 0xc9, 0x58, 0xb5, 0x21, 0x13, 0xb5, 0x7d, 0x79,
	0x93, 0x4f, 0x90, 0xe7, 0xf0, 0x41, 0xa8, 0x5d, 0xab, 0x9a, 0x64, 0x96, 0x5a, 0x7f, 0x4f, 0x80,
	0x8c, 0xaf, 0x24, 0x79, 0x0a, 0x4b, 0x7e, 0xd8, 0x63, 0xfa, 0xcd, 0x08, 0xa7, 0xbe, 0x13, 0xbb,
	0xde, 0xa9, 0x76, 0xe3, 0xcd, 0x62, 0xb3, 0x60, 0x13, 0xa5, 0xef, 0x2a, 0xf5, 0xa1, 0xd4, 0x9a,
	0xac, 0x53, 0x16, 0xc7, 0x39, 0xab, 0x38, 0xc6, 0x52, 0x6a, 0xc5, 0xfa, 0x08, 0x9a, 0x9a, 0xe5,
	0xbb, 0xa9, 0x9b, 0x37, 0x88, 0xa1, 0xa0, 0x3c, 0x7c, 0x59, 0xe9, 0xb7, 0xdd, 0xd4, 0xd5, 0xed,
	0x61, 0x40, 0x5c, 0x26, 0xea, 0x36, 0x91, 0x58, 0x1a, 0x23, 0x2a, 0x2d, 0x12, 0x3f, 0x86, 0x9b,
	0x69, 0x94, 0xba, 0x81, 0xa3, 0xe9, 0x89, 0x70, 0x82, 0xc8, 0xf5, 0xe5, 0x5d, 0xac, 0x9c, 0x77,
	0x75, 0x11, 0x21, 0xdb, 0x88, 0xb0, 0xc5, 0x5e, 0xe4, 0xfa, 0xfb, 0x82, 0xbc, 0x0f, 0x4b, 0xa3,
	0x4c, 0xaa, 0x68, 0x33, 0xd8, 0xdc, 0x82, 0x49, 0xa1, 0x48, 0xf8, 0x49, 0xd6, 0x94, 0x4a, 0xe8,
	0x05, 0x77, 0x63, 0x71, 0x12, 0xa5, 0x92, 0x33, 0x8b, 0x1c, 0x65, 0x6f, 0x53, 0x6a, 0xbb, 0x5a,
	0xb9, 0x8f, 0x37, 0xe0, 0x20, 0xf2, 0xdc, 0xc0, 0x51, 0x2b, 0x25, 0x30, 0x0a, 0x4a, 0x76, 0x1d,
	0x85, 0xca, 0x0f, 0x70, 0x43, 0x48, 0x68, 0x18, 0xa5, 0x34, 0x47, 0x55, 0xd5, 0x86, 0xa0, 0xa4,
	0x19, 0xec, 0x47, 0x30, 0x3f, 0x10, 0x34, 0x51, 0x7d, 0x3d, 0xbe, 0x48, 0xa9, 0xba, 0x71, 0x96,
	0xec, 0x39, 0x29, 0x96, 0xfd, 0xc4, 0xa2, 0x3d, 0xf9, 0x00, 0x96, 0x55, 0x57, 0x03, 0xea, 0x26,
	0x3c, 0x23, 0x84, 0x02, 0x2f, 0x9b, 0x25, 0x9b, 0xa0, 0x72, 0x4f, 0xe9, 0xf4, 0xe8, 0x7e, 0x06,
	0x77, 0x7c, 0x26, 0xe4, 0x21, 0x85, 0x58, 0xcf, 0xf5, 0x4e, 0xa8, 0x73, 0xc2, 0x52, 0xdd, 0x4c,
	0x1d, 0x89, 0x37, 0x15, 0x44, 0x52, 0xb6, 0x24, 0xe0, 0x19, 0x4b, 0x55, 0x83, 0xbf, 0x80, 0x1f,
	0x8c, 0xb3, 0x43, 0x26, 0x84, 0xa6, 0xcf, 0x21, 0xbd, 0x79, 0x89, 0xbe, 0xcf, 0x84, 0x50, 0xfc,
	0x0f, 0xa1, 0x79, 0x79, 0x19, 0xbd, 0x13, 0xea, 0x9d, 0xca, 0x3e, 0x37, 0x8c, 0xc9, 0xcd, 0xd6,
	0x70, 0x4b, 0x2a, 0xf7, 0x85, 0x4c, 0xd5, 0x44, 0xea, 0x66, 0xab, 0x97, 0xcd, 0xdd, 0x3c, 0x32,
	0x2c, 0xd4, 0xc8, 0xc6, 0xb2, 0xe9, 0xbb, 0x0d, 0x15, 0x41, 0xfb, 0x21, 0xe5, 0xa9, 0xc0, 0x77,
	0x78, 0x25, 0x3b, 0x7f, 0x56, 0xc1, 0xe5, 0x66, 0xef, 0x37, 0x16, 0xb2, 0xe0, 0x72, 0xd5, 0xcb,
	0x0d, 0xa9, 0xf6, 0x69, 0x90, 0xba, 0xca, 0x25, 0x89, 0x52, 0xa3, 0x04, 0xdd, 0xf0, 0x3e, 0xd4,
	0x94, 0x5a, 0x0d, 0x77, 0x11, 0xf5, 0x8a, 0xa1, 0x06, 0xf8, 0x23, 0x98, 0x0f, 0xdf, 0x78, 0x9e,
	0xc3, 0x78, 0x3c, 0x48, 0x95, 0x91, 0x25, 0xb5, 0x72, 0x52, 0xdc, 0x96, 0x52, 0x34, 0xb4, 0x0a,
	0x96, 0x81, 0x53, 0xd6, 0x96, 0x11, 0xd8, 0xc8, 0x81, 0xca, 0x62, 0x86, 0x8c, 0x06, 0x69, 0x6e,
	0xf2, 0xc6, 0x10, 0x79, 0x80, 0x62, 0xb4, 0xb9, 0x02, 0xf5, 0x20, 0xc4, 0x98, 0x52, 0xa8, 0x9b,
	0xaa, 0x77, 0x41, 0x28, 0x03, 0x09, 0x11, 0x3f, 0x85, 0xdb, 0xa6, 0x6b, 0x63, 0xe3, 0xfa, 0xbd,
	0x53, 0x28, 0x9a, 0x4d, 0xb5, 0xf6, 0x43, 0xef, 0x6e, 0x0f, 0xf5, 0xfb, 0x86, 0xb3, 0x29, 0xf2,
	0x31, 0x4b, 0x43, 0x37, 0x96, 0xbc, 0x5b, 0x86, 0xb3, 0x21, 0x6f, 0x13, 0x55, 0xfb, 0x82, 0xbc,
	0x07, 0x8b, 0x21, 0xe3, 0x8e, 0x8a, 0x8b, 0x61, 0x43, 0xb7, 0xd5, 0xba, 0x85, 0x8c, 0xef, 0x49,
	0x4d, 0x37, 0x6b, 0x41, 0xc2, 0xdd, 0xf3, 0x31, 0xf8, 0x1d, 0x0d, 0x77, 0xcf, 0x47, 0xe1, 0xef,
	0xc3, 0x92, 0xb4, 0xae, 0x03, 0x6a, 0x88, 0xff, 0x81, 0x8a, 0xec, 0x90, 0x71, 0x1b, 0x55, 0x23,
	0x04, 0xf7, 0x7c, 0x9c, 0x70, 0x57, 0x13, 0xdc, 0xf3, 0x4b, 0x84, 0x43, 0x58, 0xd4, 0xbe, 0xe6,
	0x44, 0x3d, 0x27, 0xdb, 0xa2, 0x9b, 0xf7, 0xf0, 0x64, 0x58, 0x19, 0x39, 0x90, 0x26, 0xec, 0xf4,
	0xf6, 0x82, 0x26, 0x1b, 0x9b, 0xff, 0x70, 0x03, 0xc4, 0x45, 0x1d, 0xd9, 0x39, 0xef, 0x9b, 0x1b,
	0xe0, 0xfe, 0x1b, 0xcf, 0x9b, 0xbc, 0x73, 0x2a, 0xa2, 0xb9, 0x73, 0xae, 0x8c, 0x11, 0x8d, 0x9d,
	0xf3, 0x73, 0xb8, 0xab, 0x89, 0x41, 0x98, 0x5d, 0xa3, 0x47, 0x9a, 0x7d, 0x07, 0xd9, 0xb7, 0x14,
	0x68, 0x2f, 0x54, 0x97, 0x3b, 0xb3, 0xe9, 0x89, 0x16, 0xcc, 0xf6, 0x5b, 0x13, 0x2d, 0x18, 0x7d,
	0xf8, 0x0c, 0xee, 0x2a, 0xd7, 0x79, 0x83, 0xaf, 0xb3, 0x1c, 0xe6, 0x9f, 0xab, 0xed, 0x1b, 0x4b,
	0x09, 0xe2, 0x49, 0xd3, 0x57, 0xfb, 0x06, 0x82, 0xd4, 0x2b, 0xaf, 0xb6, 0x7f, 0x2e, 0x37, 0xf0,
	0xdd, 0x24, 0x0a, 0xbb, 0x4f, 0xc8, 0x16, 0xdc, 0xbf, 0xc6, 0x80, 0xcf, 0xc4, 0x69, 0x93, 0xa2,
	0x89, 0xdb, 0x93, 0x4d, 0x6c, 0x33, 0x71, 0x4a, 0x76, 0x60, 0xe5, 0x1a, 0x23, 0xb8, 0x97, 0x35,
	0x7b, 0x68, 0xe5, 0xce, 0x64, 0x2b, 0xb8, 0x99, 0x5d, 0x3d, 0x98, 0xac, 0x38, 0xd8, 0xbf, 0x6a,
	0x30, 0xba, 0x42, 0x38, 0x69, 0x30, 0xea, 0x9d, 0x56, 0x6e, 0xe2, 0x64, 0xd2, 0x60, 0xd4, 0xdb,
	0x2d, 0x6d, 0xe4, 0x00, 0x1e, 0x5e, 0x65, 0xe4, 0x0d, 0x13, 0x2c, 0x95, 0x39, 0x6c, 0xe4, 0x53,
	0xd1, 0x64, 0x68, 0x6a, 0x65, 0x92, 0xa9, 0x97, 0x0a, 0xd8, 0x91, 0x38, 0xd2, 0x85, 0x77, 0xaf,
	0x32, 0xe8, 0x33, 0xe1, 0xb9, 0x89, 0x9f, 0x9b, 0x7c, 0x85, 0x26, 0x5b, 0x93, 0x4c, 0x6e, 0x67,
	0x50, 0x65, 0x74, 0x17, 0xde, 0x19, 0x33, 0x8a, 0xdb, 0xef, 0x1b, 0xea, 0xe5, 0x83, 0x3d, 0x9d,
	0x34, 0xe7, 0x72, 0x3f, 0x7f, 0x49, 0x3d, 0x3d, 0xda, 0x3d, 0x78, 0x30, 0xd9, 0x0e, 0x16, 0x9c,
	0x44, 0x6e, 0x2a, 0x40, 0x53, 0xf7, 0xc6, 0x4d, 0x1d, 0x20, 0x4e, 0x59, 0x6b, 0xfd, 0xa6, 0x90,
	0x67, 0x50, 0x66, 0x0a, 0xfa, 0x00, 0x1a, 0x21, 0xe3, 0x47, 0xdd, 0x03, 0x95, 0xcd, 0xe6, 0x57,
	0x80, 0xba, 0x92, 0x4a, 0x68, 0x47, 0x90, 0x27, 0x70, 0x23, 0x66, 0x31, 0x0d, 0x18, 0xa7, 0xce,
	0xeb, 0x01, 0x1d, 0xd0, 0x1c, 0xad, 0x32, 0xb5, 0xc5, 0x4c, 0xfb, 0x4b, 0xa9, 0xd4, 0xa4, 0x8f,
	0xa0, 0x99, 0x93, 0x8e, 0x13, 0xea, 0x9e, 0xd2, 0x24, 0xa7, 0xe9, 0x84, 0x29, 0xd3, 0x6f, 0x2a,
	0xb5, 0x22, 0xb6, 0xfe, 0xab, 0x00, 0xcb, 0x13, 0x53, 0x5e, 0xb9, 0x1d, 0xab, 0x62, 0x29, 0xbe,
	0xaa, 0x16, 0x94, 0x67, 0x99, 0x82, 0xea, 0x34, 0x41, 0xe5, 0xaf, 0x23, 0x8e, 0x9f, 0x6c, 0xa8,
	0xa3, 0xe4, 0x23, 0x68, 0x1a, 0x14, 0xfd, 0x79, 0x91, 0x66, 0xa9, 0xce, 0x2f, 0xe7, 0x2c, 0xfd,
	0x66, 0x3f, 0xcf, 0x33, 0x18, 0x4f, 0x27, 0xb4, 0x35, 0x9d, 0xb5, 0x95, 0x4e, 0x6c, 0x2b, 0x9d,
	0xdc, 0x56, 0x29, 0x6b, 0x2b, 0x1d, 0x6f, 0xab, 0xf5, 0x15, 0x94, 0xba, 0x51, 0x92, 0x92, 0x1f,
	0xc1, 0xec, 0x31, 0xde, 0x04, 0xc5, 0xe4, 0x9b, 0xb0, 0x56, 0x92, 0x07, 0x30, 0xc7, 0x04, 0xbe,
	0x61, 0x71, 0x03, 0x49, 0x54, 0x97, 0x3f, 0x7b, 0x54, 0xf8, 0x96, 0xa5, 0x8c, 0xbf, 0x28, 0x82,
	0xa5, 0xbe, 0xf3, 0xd9, 0x4d, 0xdc, 0x90, 0x6e, 0x46, 0x03, 0x2e, 0x2f, 0xab, 0x25, 0xa3, 0x5e,
	0xbe, 0x6c, 0x7e, 0x0d, 0x84, 0x00, 0xa3, 0x7e, 0x86, 0x40, 0xd2, 0x82, 0xea, 0x80, 0x1f, 0x4b,
	0x15, 0xf5, 0x47, 0xae, 0xa2, 0x43, 0x31, 0xb9, 0x01, 0x33, 0x51, 0xaf, 0x27, 0x68, 0xaa, 0xa7,
	0x50, 0x3f, 0x91, 0x55, 0xa8, 0x7a, 0x6e, 0xe0, 0xed, 0x0e, 0xb8, 0x27, 0xf4, 0x95, 0xdc, 0xac,
	0x72, 0x0c, 0x95, 0xe4, 0x8f, 0xa0, 0xd6, 0x93, 0x9d, 0x74, 0xf0, 0xd5, 0xa1, 0xfe, 0x42, 0x6d,
	0xa4, 0x04, 0x85, 0x6a, 0x7c, 0xcb, 0x48, 0x3e, 0x85, 0x39, 0x2f, 0x8c, 0x55, 0xd2, 0x6d, 0x94,
	0x03, 0xf5, 0x27, 0x65, 0x88, 0xd9, 0x0a, 0x63, 0x99, 0x74, 0x63, 0x9d, 0xba, 0xe6, 0x0d, 0x1f,
	0x5a, 0x7f, 0x5d, 0x80, 0x9a, 0x31, 0x29, 0xd7, 0xcd, 0x07, 0x02, 0xc6, 0xe6, 0xe3, 0xc7, 0x50,
	0x16, 0xa9, 0xab, 0x57, 0x26, 0xff, 0x8e, 0xed, 0xf2, 0x3c, 0xdb, 0x0a, 0x44, 0x56, 0x61, 0x9a,
	0xf2, 0x6c, 0x9d, 0xae, 0xc2, 0x4a, 0x48, 0xeb, 0x5f, 0x0b, 0x30, 0xa3, 0x34, 0xe4, 0x5d, 0xa8,
	0xf6, 0x06, 0xdc, 0x73, 0xb0, 0x02, 0x38, 0x5e, 0x74, 0xaa, 0x48, 0xe5, 0x36, 0x15, 0xde, 0x58,
	0xe5, 0xa1, 0xf8, 0x1d, 0x95, 0x87, 0x91, 0x8a, 0xcc, 0xf4, 0x75, 0x15, 0x99, 0x77, 0xa1, 0x8c,
	0x13, 0xae, 0xbf, 0x44, 0x5a, 0x18, 0xeb, 0xb9, 0xad, 0xf4, 0x43, 0x57, 0x2c, 0x5f, 0xe7, 0x8a,
	0x9f, 0x41, 0x1d, 0x0b, 0x5f, 0x8c, 0xf7, 0xe5, 0x10, 0xc8, 0xfb, 0x30, 0xd7, 0xd7, 0xcf, 0x58,
	0xbc, 0x9b, 0x30, 0xca, 0x7a, 0xdf, 0x20, 0xb4, 0x9e, 0x41, 0x2d, 0x33, 0xd0, 0xa5, 0x29, 0xf9,
	0x04, 0x1a, 0x23, 0xfc, 0x2c, 0xaa, 0xf4, 0x7b, 0x1c, 0xb3, 0x2d, 0x7b, 0xce, 0x34, 0x24, 0x5a,
	0x5f, 0x17, 0x60, 0x46, 0x7d, 0x14, 0x46, 0x3e, 0x34, 0x7a, 0x21, 0x68, 0x9a, 0x19, 0x59, 0x18,
	0x35, 0xd2, 0xa5, 0xe9, 0xb0, 0x33, 0x5d, 0x9a, 0x8a, 0xb7, 0x2c, 0x0b, 0x35, 0x61, 0xf6, 0x0d,
	0x4d, 0xf0, 0x13, 0x2a, 0x15, 0x15, 0xd9, 0x63, 0xeb, 0x3d, 0xa8, 0xca, 0xbe, 0xa8, 0xaf, 0x94,
	0xbe, 0xb3, 0xc8, 0xd9, 0xfa, 0xab, 0x02, 0xcc, 0xea, 0xcf, 0xd8, 0xc8, 0x23, 0x80, 0x38, 0x89,
	0x5e, 0x8d, 0x0c, 0x7a, 0x7e, 0x48, 0x51, 0x1f, 0x52, 0x55, 0x25, 0x44, 0x15, 0x3d, 0x9f, 0xc2,
	0x8d, 0x3e, 0xe5, 0x34, 0xc1, 0xd7, 0x77, 0x3a, 0xe9, 0xe6, 0x6e, 0xa8, 0x3f, 0x54, 0xaa, 0xda,
	0x4b, 0xb9, 0x56, 0xa5, 0xde, 0x1d, 0xa9, 0x7b, 0xbb, 0xfd, 0x65, 0xed, 0x9f, 0x8a, 0xea, 0x7b,
	0x58, 0x2c, 0xb2, 0x2f, 0xc0, 0x9c, 0xfc, 0xcd, 0xdf, 0x09, 0x5b, 0x53, 0x99, 0x28, 0x2f, 0xa1,
	0x5b, 0x85, 0x4c, 0x94, 0x57, 0x9e, 0xad, 0x22, 0x59, 0x84, 0x79, 0x29, 0x32, 0x6a, 0xae, 0xd6,
	0x34, 0xa9, 0x43, 0x05, 0xad, 0x45, 0x71, 0xc7, 0x2a, 0x91, 0x39, 0xa8, 0xca, 0x27, 0xac, 0xd7,
	0x59, 0xe5, 0xdc, 0x08, 0xe6, 0xb5, 0x1b, 0xfd, 0xbe, 0x35, 0x93, 0xe1, 0x9f, 0x47, 0x8c, 0x5b,
	0xb3, 0xd9, 0xd3, 0x0b, 0x16, 0x04, 0x56, 0x85, 0xdc, 0x00, 0x22, 0x9f, 0x46, 0xbf, 0xf9, 0xb3,
	0xaa, 0xa4, 0x09, 0x4b, 0xa6, 0x3c, 0xfb, 0xf8, 0xcb, 0x02, 0x42, 0xa0, 0x21, 0x35, 0xc3, 0x4a,
	0xb4, 0x55, 0x23, 0xb7, 0xe1, 0x06, 0xca, 0xc6, 0x5e, 0x7e, 0x5b, 0xf5, 0xac, 0x3d, 0xb9, 0x35,
	0x5b, 0x73, 0xa4, 0x01, 0x20, 0x9f, 0x54, 0xac, 0x58, 0x8d, 0xec, 0x59, 0xad, 0xa0, 0x35, 0x4f,
	0xe6, 0xa1, 0x36, 0x7c, 0x5e, 0xb7, 0xac, 0xb5, 0x8f, 0xa1, 0x6e, 0x7e, 0xff, 0x25, 0x01, 0x87,
	0xae, 0x10, 0x47, 0x27, 0x49, 0x34, 0xe8, 0x9f, 0x58, 0x53, 0x72, 0xfc, 0x9b, 0x49, 0xe4, 0xfa,
	0x9e, 0x2b, 0x52, 0xab, 0x40, 0x2a, 0x50, 0x7a, 0xe6, 0x8a, 0x13, 0xab, 0xb8, 0xf6, 0x53, 0x98,
	0xbf, 0xf4, 0x41, 0x9e, 0x54, 0x76, 0x0e, 0x3a, 0x3b, 0xd6, 0x94, 0xfc, 0xb7, 0xbb, 0xd1, 0x3d,
	0xb2, 0x0a, 0x64, 0x09, 0xac, 0x67, 0xed, 0x2f, 0x9e, 0x39, 0x5b, 0x07, 0xfb, 0x87, 0xf6, 0x4e,
	0xb7, 0xdb, 0x3e, 0xe8, 0x58, 0xc5, 0xb5, 0x47, 0x00, 0xc3, 0xef, 0x3d, 0x48, 0x15, 0xca, 0x78,
	0x1f, 0x51, 0xc4, 0x23, 0xf6, 0xe2, 0xa5, 0x55, 0x20, 0x35, 0x98, 0xd5, 0xc7, 0xb5, 0x55, 0x5c,
	0x7b, 0x02, 0xf3, 0x3a, 0x09, 0x91, 0x0b, 0xfa, 0x82, 0x71, 0xb9, 0xef, 0x93, 0x76, 0xe7, 0xe5,
	0xc6, 0x5e, 0x7b, 0xdb, 0x69, 0x77, 0xb6, 0x77, 0x7e, 0xe5, 0xbc, 0x68, 0x77, 0xb6, 0x95, 0x85,
	0x67, 0x9d, 0xee, 0x97, 0x56, 0x61, 0xed, 0x18, 0x96, 0x26, 0x7d, 0xf4, 0x45, 0xee, 0xc0, 0xcd,
	0x8c, 0xb9, 0xdd, 0xee, 0x1e, 0x6d, 0x74, 0xb6, 0x76, 0x9c, 0xfd, 0x9d, 0x23, 0xbb, 0xbd, 0x65,
	0x4d, 0x91, 0x19, 0x28, 0xee, 0x7d, 0x60, 0x15, 0xf0, 0x77, 0xdd, 0x2a, 0x12, 0x80, 0x99, 0xad,
	0x83, 0x6e, 0xbb, 0xb3, 0x63, 0x4d, 0xcb, 0xc5, 0x6f, 0x77, 0x3a, 0x3b, 0xb6, 0x73, 0x68, 0x1f,
	0x6c, 0xff, 0xf1, 0xd6, 0x91, 0x55, 0x5a, 0xfb, 0x60, 0xf8, 0xf9, 0x1a, 0x0e, 0x65, 0x09, 0xac,
	0x36, 0x7f, 0xe3, 0x06, 0xcc, 0xcf, 0x65, 0xd6, 0x94, 0x1c, 0xcb, 0x81, 0xda, 0xdc, 0xac, 0xc2,
	0xda, 0xee, 0xa5, 0x6f, 0x91, 0xb2, 0x79, 0x57, 0xfe, 0x8a, 0x5c, 0x6b, 0x2a, 0x5b, 0x39, 0x35,
	0x00, 0xab, 0x40, 0x2c, 0xa8, 0x6b, 0x00, 0x7e, 0x17, 0x64, 0x15, 0xd7, 0xfe, 0xae, 0x00, 0x95,
	0xec, 0x65, 0xf3, 0xd0, 0xdf, 0x39, 0x4d, 0xd0, 0x13, 0xa7, 0xc8, 0x32, 0x2c, 0xa0, 0xe7, 0xd2,
	0x5e, 0x7a, 0x30, 0x48, 0xb5, 0xb8, 0x90, 0xb9, 0xa4, 0xcd, 0xfa, 0x27, 0x86, 0xbc, 0x98, 0x35,
	0x90, 0xbd, 0x32, 0xb4, 0xa6, 0xe5, 0x58, 0x30, 0x3a, 0x78, 0xca, 0x72, 0x69, 0x89, 0xdc, 0x82,
	0xe5, 0x11, 0xb3, 0xb9, 0xaa, 0x4c, 0xee, 0xc2, 0xad, 0x8c, 0x30, 0xae, 0x9e, 0x59, 0x5b, 0x81,
	0xba, 0xf9, 0x92, 0x3b, 0x6b, 0x51, 0xfa, 0x93, 0xea, 0xf2, 0xda, 0xa7, 0xb0, 0x30, 0xf6, 0x42,
	0x4d, 0xae, 0x44, 0xbb, 0xa3, 0x26, 0x71, 0xbf, 0xdd, 0x71, 0xf6, 0x37, 0x7e, 0xa5, 0xa6, 0x63,
	0x73, 0xef, 0xe0, 0x60, 0xdf, 0xd9, 0x6d, 0xef, 0x1d, 0xed, 0xd8, 0x56, 0x71, 0x6d, 0xed, 0x12,
	0x17, 0x3d, 0x52, 0x7a, 0xd6, 0xc1, 0xd6, 0xc6, 0x9e, 0x35, 0x25, 0x17, 0xf2, 0x8b, 0xbd, 0x83,
	0xcd, 0x8d, 0x3d, 0xab, 0xb0, 0xb6, 0x09, 0x0b, 0x63, 0xaf, 0x11, 0xe4, 0x12, 0xec, 0x46, 0x89,
	0x47, 0x95, 0x48, 0x79, 0xd2, 0xc6, 0x20, 0x8d, 0xac, 0x82, 0x0c, 0x4a, 0x54, 0xa9, 0xb0, 0x67,
	0xbc, 0x6f, 0x15, 0xd7, 0x3e, 0x83, 0xf9, 0x4b, 0xa9, 0x8b, 0x8c, 0x95, 0xdd, 0x28, 0x08, 0xa2,
	0x33, 0x89, 0xc0, 0xd0, 0x39, 0x94, 0xe9, 0x9a, 0x2f, 0x1f, 0x0b, 0x72, 0x45, 0xb7, 0xb0, 0xc8,
	0x9c, 0xda, 0xd1, 0x99, 0x55, 0x5c, 0x3b, 0x00, 0xeb, 0x72, 0xba, 0x40, 0x66, 0x61, 0xba, 0xcd,
	0x53, 0x6b, 0x4a, 0x76, 0x7c, 0x37, 0x88, 0xdc, 0x54, 0x05, 0xc2, 0x36, 0xf5, 0x58, 0xe8, 0x06,
	0x56, 0x51, 0x86, 0xfb, 0xb6, 0x9b, 0x52, 0x99, 0x7e, 0xab, 0xad, 0x6a, 0x7b, 0xa0, 0x6a, 0xdf,
	0x56, 0x49, 0x06, 0xc9, 0xa5, 0xe4, 0x41, 0x0e, 0x41, 0x5e, 0x1b, 0xd5, 0xf0, 0xb1, 0x35, 0x61,
	0x15, 0x70, 0x2a, 0xe4, 0x99, 0x22, 0xac, 0xe2, 0xe6, 0x27, 0xbf, 0xff, 0x4d, 0xa5, 0xf0, 0xdb,
	0x6f, 0xee, 0x15, 0x7e, 0xf7, 0xcd, 0xbd, 0xc2, 0x7f, 0x7c, 0x73, 0xaf, 0xf0, 0xe7, 0xdf, 0xde,
	0x9b, 0xfa, 0x9b, 0x6f, 0xef, 0x4d, 0xfd, 0xee, 0xdb, 0x7b, 0x53, 0xbf, 0xff, 0xf6, 0xde, 0x14,
	0x2c, 0x7b, 0x51, 0xf8, 0x48, 0x9e, 0x3f, 0x9e, 0x1b, 0x3f, 0x4a, 0x99, 0x7f, 0x8c, 0x3b, 0xf2,
	0x61, 0xe1, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0xec, 0x4b, 0xe4, 0x30, 0xf1, 0x30, 0x00, 0x00,
}

func (m *Executor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Executor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Executor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Expand2 != nil {
		{
			size, err := m.Expand2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.Expand != nil {
		{
			size, err := m.Expand.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	i = encodeVarintExecutor(dAtA, i, uint64(m.FineGrainedShuffleBatchSize))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x90
	i = encodeVarintExecutor(dAtA, i, uint64(m.FineGrainedShuffleStreamCount))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x88
	if m.Window != nil {
		{
			size, err := m.Window.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.Sort != nil {
		{
			size, err := m.Sort.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.PartitionTableScan != nil {
		{
			size, err := m.PartitionTableScan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.Projection != nil {
		{
			size, err := m.Projection.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.ExchangeSender != nil {
		{
			size, err := m.ExchangeSender.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.Kill != nil {
		{
			size, err := m.Kill.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.ExecutorId != nil {
		i -= len(*m.ExecutorId)
		copy(dAtA[i:], *m.ExecutorId)
		i = encodeVarintExecutor(dAtA, i, uint64(len(*m.ExecutorId)))
		i--
		dAtA[i] = 0x52
	}
	if m.Join != nil {
		{
			size, err := m.Join.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.ExchangeReceiver != nil {
		{
			size, err := m.ExchangeReceiver.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Limit != nil {
		{
			size, err := m.Limit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.TopN != nil {
		{
			size, err := m.TopN.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Aggregation != nil {
		{
			size, err := m.Aggregation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Selection != nil {
		{
			size, err := m.Selection.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.IdxScan != nil {
		{
			size, err := m.IdxScan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.TblScan != nil {
		{
			size, err := m.TblScan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	i = encodeVarintExecutor(dAtA, i, uint64(m.Tp))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *ExchangeSender) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExchangeSender) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExchangeSender) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SameZoneFlag) > 0 {
		for iNdEx := len(m.SameZoneFlag) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.SameZoneFlag[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x48
		}
	}
	if len(m.UpstreamCteTaskMeta) > 0 {
		for iNdEx := len(m.UpstreamCteTaskMeta) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UpstreamCteTaskMeta[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	i = encodeVarintExecutor(dAtA, i, uint64(m.Compression))
	i--
	dAtA[i] = 0x38
	if len(m.AllFieldTypes) > 0 {
		for iNdEx := len(m.AllFieldTypes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AllFieldTypes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Types) > 0 {
		for iNdEx := len(m.Types) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Types[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Child != nil {
		{
			size, err := m.Child.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.PartitionKeys) > 0 {
		for iNdEx := len(m.PartitionKeys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PartitionKeys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.EncodedTaskMeta) > 0 {
		for iNdEx := len(m.EncodedTaskMeta) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EncodedTaskMeta[iNdEx])
			copy(dAtA[i:], m.EncodedTaskMeta[iNdEx])
			i = encodeVarintExecutor(dAtA, i, uint64(len(m.EncodedTaskMeta[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	i = encodeVarintExecutor(dAtA, i, uint64(m.Tp))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *EncodedBytesSlice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncodedBytesSlice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncodedBytesSlice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EncodedTasks) > 0 {
		for iNdEx := len(m.EncodedTasks) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EncodedTasks[iNdEx])
			copy(dAtA[i:], m.EncodedTasks[iNdEx])
			i = encodeVarintExecutor(dAtA, i, uint64(len(m.EncodedTasks[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ExchangeReceiver) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExchangeReceiver) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExchangeReceiver) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SameZoneFlag) > 0 {
		for iNdEx := len(m.SameZoneFlag) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.SameZoneFlag[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x28
		}
	}
	if len(m.OriginalCtePrdocuerTaskMeta) > 0 {
		for iNdEx := len(m.OriginalCtePrdocuerTaskMeta) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.OriginalCtePrdocuerTaskMeta[iNdEx])
			copy(dAtA[i:], m.OriginalCtePrdocuerTaskMeta[iNdEx])
			i = encodeVarintExecutor(dAtA, i, uint64(len(m.OriginalCtePrdocuerTaskMeta[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Tp != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.Tp))
		i--
		dAtA[i] = 0x18
	}
	if len(m.FieldTypes) > 0 {
		for iNdEx := len(m.FieldTypes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FieldTypes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.EncodedTaskMeta) > 0 {
		for iNdEx := len(m.EncodedTaskMeta) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EncodedTaskMeta[iNdEx])
			copy(dAtA[i:], m.EncodedTaskMeta[iNdEx])
			i = encodeVarintExecutor(dAtA, i, uint64(len(m.EncodedTaskMeta[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ANNQueryInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ANNQueryInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ANNQueryInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i--
	if m.EnableDistanceProj {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xb0
	{
		size, err := m.Column.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintExecutor(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xaa
	i = encodeVarintExecutor(dAtA, i, uint64(m.HnswEfSearch))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xa0
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MaxDistance))))
	i--
	dAtA[i] = 0x51
	i = encodeVarintExecutor(dAtA, i, uint64(m.IndexId))
	i--
	dAtA[i] = 0x40
	if m.RefVecF32 != nil {
		i -= len(m.RefVecF32)
		copy(dAtA[i:], m.RefVecF32)
		i = encodeVarintExecutor(dAtA, i, uint64(len(m.RefVecF32)))
		i--
		dAtA[i] = 0x32
	}
	if m.DeprecatedColumnId != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.DeprecatedColumnId))
		i--
		dAtA[i] = 0x28
	}
	i -= len(m.ColumnName)
	copy(dAtA[i:], m.ColumnName)
	i = encodeVarintExecutor(dAtA, i, uint64(len(m.ColumnName)))
	i--
	dAtA[i] = 0x22
	i = encodeVarintExecutor(dAtA, i, uint64(m.TopK))
	i--
	dAtA[i] = 0x18
	i = encodeVarintExecutor(dAtA, i, uint64(m.DistanceMetric))
	i--
	dAtA[i] = 0x10
	i = encodeVarintExecutor(dAtA, i, uint64(m.QueryType))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *InvertedQueryInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InvertedQueryInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InvertedQueryInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintExecutor(dAtA, i, uint64(m.ColumnId))
	i--
	dAtA[i] = 0x10
	i = encodeVarintExecutor(dAtA, i, uint64(m.IndexId))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *ColumnarIndexInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnarIndexInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnarIndexInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Index != nil {
		{
			size := m.Index.Size()
			i -= size
			if _, err := m.Index.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	i = encodeVarintExecutor(dAtA, i, uint64(m.IndexType))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *ColumnarIndexInfo_AnnQueryInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnarIndexInfo_AnnQueryInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnnQueryInfo != nil {
		{
			size, err := m.AnnQueryInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ColumnarIndexInfo_InvertQueryInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnarIndexInfo_InvertQueryInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.InvertQueryInfo != nil {
		{
			size, err := m.InvertQueryInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *TableScan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableScan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableScan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UsedColumnarIndexes) > 0 {
		for iNdEx := len(m.UsedColumnarIndexes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UsedColumnarIndexes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if m.DeprecatedAnnQuery != nil {
		{
			size, err := m.DeprecatedAnnQuery.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	i = encodeVarintExecutor(dAtA, i, uint64(m.MaxWaitTimeMs))
	i--
	dAtA[i] = 0x60
	if len(m.RuntimeFilterList) > 0 {
		for iNdEx := len(m.RuntimeFilterList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RuntimeFilterList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.PushedDownFilterConditions) > 0 {
		for iNdEx := len(m.PushedDownFilterConditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PushedDownFilterConditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if m.IsFastScan != nil {
		i--
		if *m.IsFastScan {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.KeepOrder != nil {
		i--
		if *m.KeepOrder {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.PrimaryPrefixColumnIds) > 0 {
		for iNdEx := len(m.PrimaryPrefixColumnIds) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintExecutor(dAtA, i, uint64(m.PrimaryPrefixColumnIds[iNdEx]))
			i--
			dAtA[i] = 0x38
		}
	}
	if len(m.Ranges) > 0 {
		for iNdEx := len(m.Ranges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ranges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	i = encodeVarintExecutor(dAtA, i, uint64(m.NextReadEngine))
	i--
	dAtA[i] = 0x28
	if len(m.PrimaryColumnIds) > 0 {
		for iNdEx := len(m.PrimaryColumnIds) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintExecutor(dAtA, i, uint64(m.PrimaryColumnIds[iNdEx]))
			i--
			dAtA[i] = 0x20
		}
	}
	i--
	if m.Desc {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x18
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Columns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	i = encodeVarintExecutor(dAtA, i, uint64(m.TableId))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *PartitionTableScan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionTableScan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionTableScan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UsedColumnarIndexes) > 0 {
		for iNdEx := len(m.UsedColumnarIndexes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UsedColumnarIndexes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.DeprecatedAnnQuery != nil {
		{
			size, err := m.DeprecatedAnnQuery.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	i = encodeVarintExecutor(dAtA, i, uint64(m.MaxWaitTimeMs))
	i--
	dAtA[i] = 0x50
	if len(m.RuntimeFilterList) > 0 {
		for iNdEx := len(m.RuntimeFilterList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RuntimeFilterList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.PushedDownFilterConditions) > 0 {
		for iNdEx := len(m.PushedDownFilterConditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PushedDownFilterConditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.IsFastScan != nil {
		i--
		if *m.IsFastScan {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.PartitionIds) > 0 {
		for iNdEx := len(m.PartitionIds) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintExecutor(dAtA, i, uint64(m.PartitionIds[iNdEx]))
			i--
			dAtA[i] = 0x30
		}
	}
	if len(m.PrimaryPrefixColumnIds) > 0 {
		for iNdEx := len(m.PrimaryPrefixColumnIds) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintExecutor(dAtA, i, uint64(m.PrimaryPrefixColumnIds[iNdEx]))
			i--
			dAtA[i] = 0x28
		}
	}
	if len(m.PrimaryColumnIds) > 0 {
		for iNdEx := len(m.PrimaryColumnIds) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintExecutor(dAtA, i, uint64(m.PrimaryColumnIds[iNdEx]))
			i--
			dAtA[i] = 0x20
		}
	}
	i--
	if m.Desc {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x18
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Columns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	i = encodeVarintExecutor(dAtA, i, uint64(m.TableId))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *Join) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Join) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Join) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RuntimeFilterList) > 0 {
		for iNdEx := len(m.RuntimeFilterList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RuntimeFilterList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if m.IsNullAwareSemiJoin != nil {
		i--
		if *m.IsNullAwareSemiJoin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if len(m.OtherEqConditionsFromIn) > 0 {
		for iNdEx := len(m.OtherEqConditionsFromIn) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OtherEqConditionsFromIn[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.OtherConditions) > 0 {
		for iNdEx := len(m.OtherConditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OtherConditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.RightConditions) > 0 {
		for iNdEx := len(m.RightConditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RightConditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.LeftConditions) > 0 {
		for iNdEx := len(m.LeftConditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LeftConditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.BuildTypes) > 0 {
		for iNdEx := len(m.BuildTypes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BuildTypes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.ProbeTypes) > 0 {
		for iNdEx := len(m.ProbeTypes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ProbeTypes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.RightJoinKeys) > 0 {
		for iNdEx := len(m.RightJoinKeys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RightJoinKeys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.LeftJoinKeys) > 0 {
		for iNdEx := len(m.LeftJoinKeys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LeftJoinKeys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	i = encodeVarintExecutor(dAtA, i, uint64(m.InnerIdx))
	i--
	dAtA[i] = 0x20
	if len(m.Children) > 0 {
		for iNdEx := len(m.Children) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Children[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	i = encodeVarintExecutor(dAtA, i, uint64(m.JoinExecType))
	i--
	dAtA[i] = 0x10
	i = encodeVarintExecutor(dAtA, i, uint64(m.JoinType))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *RuntimeFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RuntimeFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RuntimeFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintExecutor(dAtA, i, uint64(m.RfMode))
	i--
	dAtA[i] = 0x38
	i = encodeVarintExecutor(dAtA, i, uint64(m.RfType))
	i--
	dAtA[i] = 0x30
	i -= len(m.TargetExecutorId)
	copy(dAtA[i:], m.TargetExecutorId)
	i = encodeVarintExecutor(dAtA, i, uint64(len(m.TargetExecutorId)))
	i--
	dAtA[i] = 0x2a
	i -= len(m.SourceExecutorId)
	copy(dAtA[i:], m.SourceExecutorId)
	i = encodeVarintExecutor(dAtA, i, uint64(len(m.SourceExecutorId)))
	i--
	dAtA[i] = 0x22
	if len(m.TargetExprList) > 0 {
		for iNdEx := len(m.TargetExprList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TargetExprList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.SourceExprList) > 0 {
		for iNdEx := len(m.SourceExprList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SourceExprList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	i = encodeVarintExecutor(dAtA, i, uint64(m.Id))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *IndexScan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexScan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexScan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PrimaryColumnIds) > 0 {
		for iNdEx := len(m.PrimaryColumnIds) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintExecutor(dAtA, i, uint64(m.PrimaryColumnIds[iNdEx]))
			i--
			dAtA[i] = 0x30
		}
	}
	if m.Unique != nil {
		i--
		if *m.Unique {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	i--
	if m.Desc {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x20
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Columns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	i = encodeVarintExecutor(dAtA, i, uint64(m.IndexId))
	i--
	dAtA[i] = 0x10
	i = encodeVarintExecutor(dAtA, i, uint64(m.TableId))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *Selection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Selection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Selection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Child != nil {
		{
			size, err := m.Child.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RpnConditions) > 0 {
		for iNdEx := len(m.RpnConditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RpnConditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Projection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Projection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Projection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Child != nil {
		{
			size, err := m.Child.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RpnExprs) > 0 {
		for iNdEx := len(m.RpnExprs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RpnExprs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Exprs) > 0 {
		for iNdEx := len(m.Exprs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Exprs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Aggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Aggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Aggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PreAggMode != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.PreAggMode))
		i--
		dAtA[i] = 0x38
	}
	if m.Child != nil {
		{
			size, err := m.Child.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.RpnAggFunc) > 0 {
		for iNdEx := len(m.RpnAggFunc) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RpnAggFunc[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.RpnGroupBy) > 0 {
		for iNdEx := len(m.RpnGroupBy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RpnGroupBy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	i--
	if m.Streamed {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x18
	if len(m.AggFunc) > 0 {
		for iNdEx := len(m.AggFunc) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AggFunc[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.GroupBy) > 0 {
		for iNdEx := len(m.GroupBy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GroupBy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TopN) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopN) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TopN) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PartitionBy) > 0 {
		for iNdEx := len(m.PartitionBy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PartitionBy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Child != nil {
		{
			size, err := m.Child.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	i = encodeVarintExecutor(dAtA, i, uint64(m.Limit))
	i--
	dAtA[i] = 0x10
	if len(m.OrderBy) > 0 {
		for iNdEx := len(m.OrderBy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OrderBy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Limit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Limit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Limit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PartitionBy) > 0 {
		for iNdEx := len(m.PartitionBy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PartitionBy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Child != nil {
		{
			size, err := m.Child.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	i = encodeVarintExecutor(dAtA, i, uint64(m.Limit))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *Kill) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Kill) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Kill) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i--
	if m.Query {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	i = encodeVarintExecutor(dAtA, i, uint64(m.ConnID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *ExecutorExecutionSummary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecutorExecutionSummary) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecutorExecutionSummary) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TiflashNetworkSummary != nil {
		{
			size, err := m.TiflashNetworkSummary.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.TiflashWaitSummary != nil {
		{
			size, err := m.TiflashWaitSummary.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.RuConsumption != nil {
		i -= len(m.RuConsumption)
		copy(dAtA[i:], m.RuConsumption)
		i = encodeVarintExecutor(dAtA, i, uint64(len(m.RuConsumption)))
		i--
		dAtA[i] = 0x3a
	}
	if m.DetailInfo != nil {
		{
			size := m.DetailInfo.Size()
			i -= size
			if _, err := m.DetailInfo.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Concurrency != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.Concurrency))
		i--
		dAtA[i] = 0x28
	}
	if m.ExecutorId != nil {
		i -= len(*m.ExecutorId)
		copy(dAtA[i:], *m.ExecutorId)
		i = encodeVarintExecutor(dAtA, i, uint64(len(*m.ExecutorId)))
		i--
		dAtA[i] = 0x22
	}
	if m.NumIterations != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.NumIterations))
		i--
		dAtA[i] = 0x18
	}
	if m.NumProducedRows != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.NumProducedRows))
		i--
		dAtA[i] = 0x10
	}
	if m.TimeProcessedNs != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.TimeProcessedNs))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ExecutorExecutionSummary_TiflashScanContext) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecutorExecutionSummary_TiflashScanContext) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TiflashScanContext != nil {
		{
			size, err := m.TiflashScanContext.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *TiFlashExecutionInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TiFlashExecutionInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TiFlashExecutionInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExecutionSummaries) > 0 {
		for iNdEx := len(m.ExecutionSummaries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExecutionSummaries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TiFlashRegionNumOfInstance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TiFlashRegionNumOfInstance) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TiFlashRegionNumOfInstance) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RegionNum != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.RegionNum))
		i--
		dAtA[i] = 0x10
	}
	if m.InstanceId != nil {
		i -= len(*m.InstanceId)
		copy(dAtA[i:], *m.InstanceId)
		i = encodeVarintExecutor(dAtA, i, uint64(len(*m.InstanceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TiFlashScanContext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TiFlashScanContext) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TiFlashScanContext) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalVectorIdxReadOthersTimeMs != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.TotalVectorIdxReadOthersTimeMs))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xe0
	}
	if m.TotalVectorIdxReadVecTimeMs != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.TotalVectorIdxReadVecTimeMs))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xd8
	}
	if m.TotalVectorIdxSearchDiscardedNodes != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.TotalVectorIdxSearchDiscardedNodes))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xd0
	}
	if m.TotalVectorIdxSearchVisitedNodes != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.TotalVectorIdxSearchVisitedNodes))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xc8
	}
	if m.TotalVectorIdxSearchTimeMs != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.TotalVectorIdxSearchTimeMs))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xc0
	}
	if m.TotalVectorIdxLoadTimeMs != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.TotalVectorIdxLoadTimeMs))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb8
	}
	if m.TotalVectorIdxLoadFromCache != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.TotalVectorIdxLoadFromCache))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb0
	}
	if m.TotalVectorIdxLoadFromDisk != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.TotalVectorIdxLoadFromDisk))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.TotalVectorIdxLoadFromS3 != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.TotalVectorIdxLoadFromS3))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.DmfileLmFilterSkippedRows != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.DmfileLmFilterSkippedRows))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.DmfileLmFilterScannedRows != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.DmfileLmFilterScannedRows))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.DmfileMvccSkippedRows != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.DmfileMvccSkippedRows))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.DmfileMvccScannedRows != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.DmfileMvccScannedRows))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if len(m.RegionsOfInstance) > 0 {
		for iNdEx := len(m.RegionsOfInstance) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RegionsOfInstance[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xf2
		}
	}
	if m.MaxRemoteStreamMs != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.MaxRemoteStreamMs))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.MinRemoteStreamMs != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.MinRemoteStreamMs))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.MaxLocalStreamMs != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.MaxLocalStreamMs))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.MinLocalStreamMs != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.MinLocalStreamMs))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.TotalBuildBitmapMs != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.TotalBuildBitmapMs))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.TotalBuildInputstreamMs != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.TotalBuildInputstreamMs))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.LmSkipRows != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.LmSkipRows))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.MvccOutputRows != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.MvccOutputRows))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.MvccInputBytes != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.MvccInputBytes))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.MvccInputRows != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.MvccInputRows))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.DeltaBytes != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.DeltaBytes))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.DeltaRows != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.DeltaRows))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.ReadTasks != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.ReadTasks))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.Segments != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.Segments))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.StaleReadRegions != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.StaleReadRegions))
		i--
		dAtA[i] = 0x78
	}
	if m.TotalDmfileRsCheckMs != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.TotalDmfileRsCheckMs))
		i--
		dAtA[i] = 0x70
	}
	if m.DisaggReadCacheMissBytes != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.DisaggReadCacheMissBytes))
		i--
		dAtA[i] = 0x68
	}
	if m.DisaggReadCacheHitBytes != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.DisaggReadCacheHitBytes))
		i--
		dAtA[i] = 0x60
	}
	if m.TotalLearnerReadMs != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.TotalLearnerReadMs))
		i--
		dAtA[i] = 0x58
	}
	if m.UserReadBytes != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.UserReadBytes))
		i--
		dAtA[i] = 0x50
	}
	if m.RemoteRegions != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.RemoteRegions))
		i--
		dAtA[i] = 0x48
	}
	if m.LocalRegions != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.LocalRegions))
		i--
		dAtA[i] = 0x40
	}
	if m.TotalBuildSnapshotMs != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.TotalBuildSnapshotMs))
		i--
		dAtA[i] = 0x38
	}
	if m.TotalDmfileReadMs != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.TotalDmfileReadMs))
		i--
		dAtA[i] = 0x30
	}
	if m.TotalDmfileRsLoadMs != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.TotalDmfileRsLoadMs))
		i--
		dAtA[i] = 0x28
	}
	if m.DmfileDataSkippedRows != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.DmfileDataSkippedRows))
		i--
		dAtA[i] = 0x20
	}
	if m.DmfileDataScannedRows != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.DmfileDataScannedRows))
		i--
		dAtA[i] = 0x18
	}
	if m.DmfileSkippedPacks != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.DmfileSkippedPacks))
		i--
		dAtA[i] = 0x10
	}
	if m.DmfileScannedPacks != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.DmfileScannedPacks))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TiFlashWaitSummary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TiFlashWaitSummary) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TiFlashWaitSummary) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PipelineBreakerWaitNs != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.PipelineBreakerWaitNs))
		i--
		dAtA[i] = 0x18
	}
	if m.PipelineQueueWaitNs != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.PipelineQueueWaitNs))
		i--
		dAtA[i] = 0x10
	}
	if m.MinTSOWaitNs != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.MinTSOWaitNs))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TiFlashNetWorkSummary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TiFlashNetWorkSummary) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TiFlashNetWorkSummary) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InterZoneReceiveBytes != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.InterZoneReceiveBytes))
		i--
		dAtA[i] = 0x20
	}
	if m.InterZoneSendBytes != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.InterZoneSendBytes))
		i--
		dAtA[i] = 0x18
	}
	if m.InnerZoneReceiveBytes != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.InnerZoneReceiveBytes))
		i--
		dAtA[i] = 0x10
	}
	if m.InnerZoneSendBytes != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.InnerZoneSendBytes))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Sort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sort) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Sort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Child != nil {
		{
			size, err := m.Child.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.IsPartialSort != nil {
		i--
		if *m.IsPartialSort {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.ByItems) > 0 {
		for iNdEx := len(m.ByItems) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ByItems[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *WindowFrameBound) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WindowFrameBound) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WindowFrameBound) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CmpDataType != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.CmpDataType))
		i--
		dAtA[i] = 0x30
	}
	if m.FrameRange != nil {
		{
			size, err := m.FrameRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.CalcFuncs) > 0 {
		for iNdEx := len(m.CalcFuncs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CalcFuncs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Offset != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.Offset))
		i--
		dAtA[i] = 0x18
	}
	i--
	if m.Unbounded {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	i = encodeVarintExecutor(dAtA, i, uint64(m.Type))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *WindowFrame) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WindowFrame) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WindowFrame) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != nil {
		{
			size, err := m.End.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Start != nil {
		{
			size, err := m.Start.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	i = encodeVarintExecutor(dAtA, i, uint64(m.Type))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *Window) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Window) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Window) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Child != nil {
		{
			size, err := m.Child.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Frame != nil {
		{
			size, err := m.Frame.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.OrderBy) > 0 {
		for iNdEx := len(m.OrderBy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OrderBy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.PartitionBy) > 0 {
		for iNdEx := len(m.PartitionBy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PartitionBy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.FuncDesc) > 0 {
		for iNdEx := len(m.FuncDesc) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FuncDesc[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GroupingExpr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupingExpr) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupingExpr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GroupingExpr) > 0 {
		for iNdEx := len(m.GroupingExpr) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GroupingExpr[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GroupingSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupingSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupingSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GroupingExprs) > 0 {
		for iNdEx := len(m.GroupingExprs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GroupingExprs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Expand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Expand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Version != nil {
		i = encodeVarintExecutor(dAtA, i, uint64(*m.Version))
		i--
		dAtA[i] = 0x18
	}
	if m.Child != nil {
		{
			size, err := m.Child.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.GroupingSets) > 0 {
		for iNdEx := len(m.GroupingSets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GroupingSets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ExprSlice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExprSlice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExprSlice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Exprs) > 0 {
		for iNdEx := len(m.Exprs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Exprs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Expand2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Expand2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expand2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Child != nil {
		{
			size, err := m.Child.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutor(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.GeneratedOutputNames) > 0 {
		for iNdEx := len(m.GeneratedOutputNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.GeneratedOutputNames[iNdEx])
			copy(dAtA[i:], m.GeneratedOutputNames[iNdEx])
			i = encodeVarintExecutor(dAtA, i, uint64(len(m.GeneratedOutputNames[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ProjExprs) > 0 {
		for iNdEx := len(m.ProjExprs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ProjExprs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutor(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintExecutor(dAtA []byte, offset int, v uint64) int {
	offset -= sovExecutor(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Executor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovExecutor(uint64(m.Tp))
	if m.TblScan != nil {
		l = m.TblScan.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.IdxScan != nil {
		l = m.IdxScan.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.Selection != nil {
		l = m.Selection.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.Aggregation != nil {
		l = m.Aggregation.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.TopN != nil {
		l = m.TopN.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.Limit != nil {
		l = m.Limit.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.ExchangeReceiver != nil {
		l = m.ExchangeReceiver.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.Join != nil {
		l = m.Join.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.ExecutorId != nil {
		l = len(*m.ExecutorId)
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.Kill != nil {
		l = m.Kill.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.ExchangeSender != nil {
		l = m.ExchangeSender.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.Projection != nil {
		l = m.Projection.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.PartitionTableScan != nil {
		l = m.PartitionTableScan.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.Sort != nil {
		l = m.Sort.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.Window != nil {
		l = m.Window.Size()
		n += 2 + l + sovExecutor(uint64(l))
	}
	n += 2 + sovExecutor(uint64(m.FineGrainedShuffleStreamCount))
	n += 2 + sovExecutor(uint64(m.FineGrainedShuffleBatchSize))
	if m.Expand != nil {
		l = m.Expand.Size()
		n += 2 + l + sovExecutor(uint64(l))
	}
	if m.Expand2 != nil {
		l = m.Expand2.Size()
		n += 2 + l + sovExecutor(uint64(l))
	}
	return n
}

func (m *ExchangeSender) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovExecutor(uint64(m.Tp))
	if len(m.EncodedTaskMeta) > 0 {
		for _, b := range m.EncodedTaskMeta {
			l = len(b)
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.PartitionKeys) > 0 {
		for _, e := range m.PartitionKeys {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if m.Child != nil {
		l = m.Child.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if len(m.Types) > 0 {
		for _, e := range m.Types {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.AllFieldTypes) > 0 {
		for _, e := range m.AllFieldTypes {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	n += 1 + sovExecutor(uint64(m.Compression))
	if len(m.UpstreamCteTaskMeta) > 0 {
		for _, e := range m.UpstreamCteTaskMeta {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.SameZoneFlag) > 0 {
		n += 2 * len(m.SameZoneFlag)
	}
	return n
}

func (m *EncodedBytesSlice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.EncodedTasks) > 0 {
		for _, b := range m.EncodedTasks {
			l = len(b)
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	return n
}

func (m *ExchangeReceiver) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.EncodedTaskMeta) > 0 {
		for _, b := range m.EncodedTaskMeta {
			l = len(b)
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.FieldTypes) > 0 {
		for _, e := range m.FieldTypes {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if m.Tp != nil {
		n += 1 + sovExecutor(uint64(*m.Tp))
	}
	if len(m.OriginalCtePrdocuerTaskMeta) > 0 {
		for _, b := range m.OriginalCtePrdocuerTaskMeta {
			l = len(b)
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.SameZoneFlag) > 0 {
		n += 2 * len(m.SameZoneFlag)
	}
	return n
}

func (m *ANNQueryInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovExecutor(uint64(m.QueryType))
	n += 1 + sovExecutor(uint64(m.DistanceMetric))
	n += 1 + sovExecutor(uint64(m.TopK))
	l = len(m.ColumnName)
	n += 1 + l + sovExecutor(uint64(l))
	if m.DeprecatedColumnId != nil {
		n += 1 + sovExecutor(uint64(*m.DeprecatedColumnId))
	}
	if m.RefVecF32 != nil {
		l = len(m.RefVecF32)
		n += 1 + l + sovExecutor(uint64(l))
	}
	n += 1 + sovExecutor(uint64(m.IndexId))
	n += 9
	n += 2 + sovExecutor(uint64(m.HnswEfSearch))
	l = m.Column.Size()
	n += 2 + l + sovExecutor(uint64(l))
	n += 3
	return n
}

func (m *InvertedQueryInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovExecutor(uint64(m.IndexId))
	n += 1 + sovExecutor(uint64(m.ColumnId))
	return n
}

func (m *ColumnarIndexInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovExecutor(uint64(m.IndexType))
	if m.Index != nil {
		n += m.Index.Size()
	}
	return n
}

func (m *ColumnarIndexInfo_AnnQueryInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnnQueryInfo != nil {
		l = m.AnnQueryInfo.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	return n
}
func (m *ColumnarIndexInfo_InvertQueryInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InvertQueryInfo != nil {
		l = m.InvertQueryInfo.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	return n
}
func (m *TableScan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovExecutor(uint64(m.TableId))
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	n += 2
	if len(m.PrimaryColumnIds) > 0 {
		for _, e := range m.PrimaryColumnIds {
			n += 1 + sovExecutor(uint64(e))
		}
	}
	n += 1 + sovExecutor(uint64(m.NextReadEngine))
	if len(m.Ranges) > 0 {
		for _, e := range m.Ranges {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.PrimaryPrefixColumnIds) > 0 {
		for _, e := range m.PrimaryPrefixColumnIds {
			n += 1 + sovExecutor(uint64(e))
		}
	}
	if m.KeepOrder != nil {
		n += 2
	}
	if m.IsFastScan != nil {
		n += 2
	}
	if len(m.PushedDownFilterConditions) > 0 {
		for _, e := range m.PushedDownFilterConditions {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.RuntimeFilterList) > 0 {
		for _, e := range m.RuntimeFilterList {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	n += 1 + sovExecutor(uint64(m.MaxWaitTimeMs))
	if m.DeprecatedAnnQuery != nil {
		l = m.DeprecatedAnnQuery.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if len(m.UsedColumnarIndexes) > 0 {
		for _, e := range m.UsedColumnarIndexes {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	return n
}

func (m *PartitionTableScan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovExecutor(uint64(m.TableId))
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	n += 2
	if len(m.PrimaryColumnIds) > 0 {
		for _, e := range m.PrimaryColumnIds {
			n += 1 + sovExecutor(uint64(e))
		}
	}
	if len(m.PrimaryPrefixColumnIds) > 0 {
		for _, e := range m.PrimaryPrefixColumnIds {
			n += 1 + sovExecutor(uint64(e))
		}
	}
	if len(m.PartitionIds) > 0 {
		for _, e := range m.PartitionIds {
			n += 1 + sovExecutor(uint64(e))
		}
	}
	if m.IsFastScan != nil {
		n += 2
	}
	if len(m.PushedDownFilterConditions) > 0 {
		for _, e := range m.PushedDownFilterConditions {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.RuntimeFilterList) > 0 {
		for _, e := range m.RuntimeFilterList {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	n += 1 + sovExecutor(uint64(m.MaxWaitTimeMs))
	if m.DeprecatedAnnQuery != nil {
		l = m.DeprecatedAnnQuery.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if len(m.UsedColumnarIndexes) > 0 {
		for _, e := range m.UsedColumnarIndexes {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	return n
}

func (m *Join) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovExecutor(uint64(m.JoinType))
	n += 1 + sovExecutor(uint64(m.JoinExecType))
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	n += 1 + sovExecutor(uint64(m.InnerIdx))
	if len(m.LeftJoinKeys) > 0 {
		for _, e := range m.LeftJoinKeys {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.RightJoinKeys) > 0 {
		for _, e := range m.RightJoinKeys {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.ProbeTypes) > 0 {
		for _, e := range m.ProbeTypes {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.BuildTypes) > 0 {
		for _, e := range m.BuildTypes {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.LeftConditions) > 0 {
		for _, e := range m.LeftConditions {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.RightConditions) > 0 {
		for _, e := range m.RightConditions {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.OtherConditions) > 0 {
		for _, e := range m.OtherConditions {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.OtherEqConditionsFromIn) > 0 {
		for _, e := range m.OtherEqConditionsFromIn {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if m.IsNullAwareSemiJoin != nil {
		n += 2
	}
	if len(m.RuntimeFilterList) > 0 {
		for _, e := range m.RuntimeFilterList {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	return n
}

func (m *RuntimeFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovExecutor(uint64(m.Id))
	if len(m.SourceExprList) > 0 {
		for _, e := range m.SourceExprList {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.TargetExprList) > 0 {
		for _, e := range m.TargetExprList {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	l = len(m.SourceExecutorId)
	n += 1 + l + sovExecutor(uint64(l))
	l = len(m.TargetExecutorId)
	n += 1 + l + sovExecutor(uint64(l))
	n += 1 + sovExecutor(uint64(m.RfType))
	n += 1 + sovExecutor(uint64(m.RfMode))
	return n
}

func (m *IndexScan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovExecutor(uint64(m.TableId))
	n += 1 + sovExecutor(uint64(m.IndexId))
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	n += 2
	if m.Unique != nil {
		n += 2
	}
	if len(m.PrimaryColumnIds) > 0 {
		for _, e := range m.PrimaryColumnIds {
			n += 1 + sovExecutor(uint64(e))
		}
	}
	return n
}

func (m *Selection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.RpnConditions) > 0 {
		for _, e := range m.RpnConditions {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if m.Child != nil {
		l = m.Child.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	return n
}

func (m *Projection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Exprs) > 0 {
		for _, e := range m.Exprs {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.RpnExprs) > 0 {
		for _, e := range m.RpnExprs {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if m.Child != nil {
		l = m.Child.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	return n
}

func (m *Aggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.GroupBy) > 0 {
		for _, e := range m.GroupBy {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.AggFunc) > 0 {
		for _, e := range m.AggFunc {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	n += 2
	if len(m.RpnGroupBy) > 0 {
		for _, e := range m.RpnGroupBy {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.RpnAggFunc) > 0 {
		for _, e := range m.RpnAggFunc {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if m.Child != nil {
		l = m.Child.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.PreAggMode != nil {
		n += 1 + sovExecutor(uint64(*m.PreAggMode))
	}
	return n
}

func (m *TopN) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.OrderBy) > 0 {
		for _, e := range m.OrderBy {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	n += 1 + sovExecutor(uint64(m.Limit))
	if m.Child != nil {
		l = m.Child.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if len(m.PartitionBy) > 0 {
		for _, e := range m.PartitionBy {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	return n
}

func (m *Limit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovExecutor(uint64(m.Limit))
	if m.Child != nil {
		l = m.Child.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if len(m.PartitionBy) > 0 {
		for _, e := range m.PartitionBy {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	return n
}

func (m *Kill) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovExecutor(uint64(m.ConnID))
	n += 2
	return n
}

func (m *ExecutorExecutionSummary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TimeProcessedNs != nil {
		n += 1 + sovExecutor(uint64(*m.TimeProcessedNs))
	}
	if m.NumProducedRows != nil {
		n += 1 + sovExecutor(uint64(*m.NumProducedRows))
	}
	if m.NumIterations != nil {
		n += 1 + sovExecutor(uint64(*m.NumIterations))
	}
	if m.ExecutorId != nil {
		l = len(*m.ExecutorId)
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.Concurrency != nil {
		n += 1 + sovExecutor(uint64(*m.Concurrency))
	}
	if m.DetailInfo != nil {
		n += m.DetailInfo.Size()
	}
	if m.RuConsumption != nil {
		l = len(m.RuConsumption)
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.TiflashWaitSummary != nil {
		l = m.TiflashWaitSummary.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.TiflashNetworkSummary != nil {
		l = m.TiflashNetworkSummary.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	return n
}

func (m *ExecutorExecutionSummary_TiflashScanContext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TiflashScanContext != nil {
		l = m.TiflashScanContext.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	return n
}
func (m *TiFlashExecutionInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ExecutionSummaries) > 0 {
		for _, e := range m.ExecutionSummaries {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	return n
}

func (m *TiFlashRegionNumOfInstance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InstanceId != nil {
		l = len(*m.InstanceId)
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.RegionNum != nil {
		n += 1 + sovExecutor(uint64(*m.RegionNum))
	}
	return n
}

func (m *TiFlashScanContext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DmfileScannedPacks != nil {
		n += 1 + sovExecutor(uint64(*m.DmfileScannedPacks))
	}
	if m.DmfileSkippedPacks != nil {
		n += 1 + sovExecutor(uint64(*m.DmfileSkippedPacks))
	}
	if m.DmfileDataScannedRows != nil {
		n += 1 + sovExecutor(uint64(*m.DmfileDataScannedRows))
	}
	if m.DmfileDataSkippedRows != nil {
		n += 1 + sovExecutor(uint64(*m.DmfileDataSkippedRows))
	}
	if m.TotalDmfileRsLoadMs != nil {
		n += 1 + sovExecutor(uint64(*m.TotalDmfileRsLoadMs))
	}
	if m.TotalDmfileReadMs != nil {
		n += 1 + sovExecutor(uint64(*m.TotalDmfileReadMs))
	}
	if m.TotalBuildSnapshotMs != nil {
		n += 1 + sovExecutor(uint64(*m.TotalBuildSnapshotMs))
	}
	if m.LocalRegions != nil {
		n += 1 + sovExecutor(uint64(*m.LocalRegions))
	}
	if m.RemoteRegions != nil {
		n += 1 + sovExecutor(uint64(*m.RemoteRegions))
	}
	if m.UserReadBytes != nil {
		n += 1 + sovExecutor(uint64(*m.UserReadBytes))
	}
	if m.TotalLearnerReadMs != nil {
		n += 1 + sovExecutor(uint64(*m.TotalLearnerReadMs))
	}
	if m.DisaggReadCacheHitBytes != nil {
		n += 1 + sovExecutor(uint64(*m.DisaggReadCacheHitBytes))
	}
	if m.DisaggReadCacheMissBytes != nil {
		n += 1 + sovExecutor(uint64(*m.DisaggReadCacheMissBytes))
	}
	if m.TotalDmfileRsCheckMs != nil {
		n += 1 + sovExecutor(uint64(*m.TotalDmfileRsCheckMs))
	}
	if m.StaleReadRegions != nil {
		n += 1 + sovExecutor(uint64(*m.StaleReadRegions))
	}
	if m.Segments != nil {
		n += 2 + sovExecutor(uint64(*m.Segments))
	}
	if m.ReadTasks != nil {
		n += 2 + sovExecutor(uint64(*m.ReadTasks))
	}
	if m.DeltaRows != nil {
		n += 2 + sovExecutor(uint64(*m.DeltaRows))
	}
	if m.DeltaBytes != nil {
		n += 2 + sovExecutor(uint64(*m.DeltaBytes))
	}
	if m.MvccInputRows != nil {
		n += 2 + sovExecutor(uint64(*m.MvccInputRows))
	}
	if m.MvccInputBytes != nil {
		n += 2 + sovExecutor(uint64(*m.MvccInputBytes))
	}
	if m.MvccOutputRows != nil {
		n += 2 + sovExecutor(uint64(*m.MvccOutputRows))
	}
	if m.LmSkipRows != nil {
		n += 2 + sovExecutor(uint64(*m.LmSkipRows))
	}
	if m.TotalBuildInputstreamMs != nil {
		n += 2 + sovExecutor(uint64(*m.TotalBuildInputstreamMs))
	}
	if m.TotalBuildBitmapMs != nil {
		n += 2 + sovExecutor(uint64(*m.TotalBuildBitmapMs))
	}
	if m.MinLocalStreamMs != nil {
		n += 2 + sovExecutor(uint64(*m.MinLocalStreamMs))
	}
	if m.MaxLocalStreamMs != nil {
		n += 2 + sovExecutor(uint64(*m.MaxLocalStreamMs))
	}
	if m.MinRemoteStreamMs != nil {
		n += 2 + sovExecutor(uint64(*m.MinRemoteStreamMs))
	}
	if m.MaxRemoteStreamMs != nil {
		n += 2 + sovExecutor(uint64(*m.MaxRemoteStreamMs))
	}
	if len(m.RegionsOfInstance) > 0 {
		for _, e := range m.RegionsOfInstance {
			l = e.Size()
			n += 2 + l + sovExecutor(uint64(l))
		}
	}
	if m.DmfileMvccScannedRows != nil {
		n += 2 + sovExecutor(uint64(*m.DmfileMvccScannedRows))
	}
	if m.DmfileMvccSkippedRows != nil {
		n += 2 + sovExecutor(uint64(*m.DmfileMvccSkippedRows))
	}
	if m.DmfileLmFilterScannedRows != nil {
		n += 2 + sovExecutor(uint64(*m.DmfileLmFilterScannedRows))
	}
	if m.DmfileLmFilterSkippedRows != nil {
		n += 2 + sovExecutor(uint64(*m.DmfileLmFilterSkippedRows))
	}
	if m.TotalVectorIdxLoadFromS3 != nil {
		n += 2 + sovExecutor(uint64(*m.TotalVectorIdxLoadFromS3))
	}
	if m.TotalVectorIdxLoadFromDisk != nil {
		n += 2 + sovExecutor(uint64(*m.TotalVectorIdxLoadFromDisk))
	}
	if m.TotalVectorIdxLoadFromCache != nil {
		n += 2 + sovExecutor(uint64(*m.TotalVectorIdxLoadFromCache))
	}
	if m.TotalVectorIdxLoadTimeMs != nil {
		n += 2 + sovExecutor(uint64(*m.TotalVectorIdxLoadTimeMs))
	}
	if m.TotalVectorIdxSearchTimeMs != nil {
		n += 2 + sovExecutor(uint64(*m.TotalVectorIdxSearchTimeMs))
	}
	if m.TotalVectorIdxSearchVisitedNodes != nil {
		n += 2 + sovExecutor(uint64(*m.TotalVectorIdxSearchVisitedNodes))
	}
	if m.TotalVectorIdxSearchDiscardedNodes != nil {
		n += 2 + sovExecutor(uint64(*m.TotalVectorIdxSearchDiscardedNodes))
	}
	if m.TotalVectorIdxReadVecTimeMs != nil {
		n += 2 + sovExecutor(uint64(*m.TotalVectorIdxReadVecTimeMs))
	}
	if m.TotalVectorIdxReadOthersTimeMs != nil {
		n += 2 + sovExecutor(uint64(*m.TotalVectorIdxReadOthersTimeMs))
	}
	return n
}

func (m *TiFlashWaitSummary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MinTSOWaitNs != nil {
		n += 1 + sovExecutor(uint64(*m.MinTSOWaitNs))
	}
	if m.PipelineQueueWaitNs != nil {
		n += 1 + sovExecutor(uint64(*m.PipelineQueueWaitNs))
	}
	if m.PipelineBreakerWaitNs != nil {
		n += 1 + sovExecutor(uint64(*m.PipelineBreakerWaitNs))
	}
	return n
}

func (m *TiFlashNetWorkSummary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InnerZoneSendBytes != nil {
		n += 1 + sovExecutor(uint64(*m.InnerZoneSendBytes))
	}
	if m.InnerZoneReceiveBytes != nil {
		n += 1 + sovExecutor(uint64(*m.InnerZoneReceiveBytes))
	}
	if m.InterZoneSendBytes != nil {
		n += 1 + sovExecutor(uint64(*m.InterZoneSendBytes))
	}
	if m.InterZoneReceiveBytes != nil {
		n += 1 + sovExecutor(uint64(*m.InterZoneReceiveBytes))
	}
	return n
}

func (m *Sort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ByItems) > 0 {
		for _, e := range m.ByItems {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if m.IsPartialSort != nil {
		n += 2
	}
	if m.Child != nil {
		l = m.Child.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	return n
}

func (m *WindowFrameBound) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovExecutor(uint64(m.Type))
	n += 2
	if m.Offset != nil {
		n += 1 + sovExecutor(uint64(*m.Offset))
	}
	if len(m.CalcFuncs) > 0 {
		for _, e := range m.CalcFuncs {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if m.FrameRange != nil {
		l = m.FrameRange.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.CmpDataType != nil {
		n += 1 + sovExecutor(uint64(*m.CmpDataType))
	}
	return n
}

func (m *WindowFrame) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovExecutor(uint64(m.Type))
	if m.Start != nil {
		l = m.Start.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.End != nil {
		l = m.End.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	return n
}

func (m *Window) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.FuncDesc) > 0 {
		for _, e := range m.FuncDesc {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.PartitionBy) > 0 {
		for _, e := range m.PartitionBy {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.OrderBy) > 0 {
		for _, e := range m.OrderBy {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if m.Frame != nil {
		l = m.Frame.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.Child != nil {
		l = m.Child.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	return n
}

func (m *GroupingExpr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.GroupingExpr) > 0 {
		for _, e := range m.GroupingExpr {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	return n
}

func (m *GroupingSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.GroupingExprs) > 0 {
		for _, e := range m.GroupingExprs {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	return n
}

func (m *Expand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.GroupingSets) > 0 {
		for _, e := range m.GroupingSets {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if m.Child != nil {
		l = m.Child.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	if m.Version != nil {
		n += 1 + sovExecutor(uint64(*m.Version))
	}
	return n
}

func (m *ExprSlice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Exprs) > 0 {
		for _, e := range m.Exprs {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	return n
}

func (m *Expand2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ProjExprs) > 0 {
		for _, e := range m.ProjExprs {
			l = e.Size()
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if len(m.GeneratedOutputNames) > 0 {
		for _, s := range m.GeneratedOutputNames {
			l = len(s)
			n += 1 + l + sovExecutor(uint64(l))
		}
	}
	if m.Child != nil {
		l = m.Child.Size()
		n += 1 + l + sovExecutor(uint64(l))
	}
	return n
}

func sovExecutor(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozExecutor(x uint64) (n int) {
	return sovExecutor(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Executor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Executor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Executor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tp", wireType)
			}
			m.Tp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tp |= ExecType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TblScan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TblScan == nil {
				m.TblScan = &TableScan{}
			}
			if err := m.TblScan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdxScan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdxScan == nil {
				m.IdxScan = &IndexScan{}
			}
			if err := m.IdxScan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Selection == nil {
				m.Selection = &Selection{}
			}
			if err := m.Selection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggregation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aggregation == nil {
				m.Aggregation = &Aggregation{}
			}
			if err := m.Aggregation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopN", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TopN == nil {
				m.TopN = &TopN{}
			}
			if err := m.TopN.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Limit == nil {
				m.Limit = &Limit{}
			}
			if err := m.Limit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeReceiver", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExchangeReceiver == nil {
				m.ExchangeReceiver = &ExchangeReceiver{}
			}
			if err := m.ExchangeReceiver.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Join", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Join == nil {
				m.Join = &Join{}
			}
			if err := m.Join.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ExecutorId = &s
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kill", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Kill == nil {
				m.Kill = &Kill{}
			}
			if err := m.Kill.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeSender", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExchangeSender == nil {
				m.ExchangeSender = &ExchangeSender{}
			}
			if err := m.ExchangeSender.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Projection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Projection == nil {
				m.Projection = &Projection{}
			}
			if err := m.Projection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionTableScan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PartitionTableScan == nil {
				m.PartitionTableScan = &PartitionTableScan{}
			}
			if err := m.PartitionTableScan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sort == nil {
				m.Sort = &Sort{}
			}
			if err := m.Sort.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Window", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Window == nil {
				m.Window = &Window{}
			}
			if err := m.Window.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FineGrainedShuffleStreamCount", wireType)
			}
			m.FineGrainedShuffleStreamCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FineGrainedShuffleStreamCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FineGrainedShuffleBatchSize", wireType)
			}
			m.FineGrainedShuffleBatchSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FineGrainedShuffleBatchSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expand", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expand == nil {
				m.Expand = &Expand{}
			}
			if err := m.Expand.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expand2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expand2 == nil {
				m.Expand2 = &Expand2{}
			}
			if err := m.Expand2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExchangeSender) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExchangeSender: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExchangeSender: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tp", wireType)
			}
			m.Tp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tp |= ExchangeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncodedTaskMeta", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncodedTaskMeta = append(m.EncodedTaskMeta, make([]byte, postIndex-iNdEx))
			copy(m.EncodedTaskMeta[len(m.EncodedTaskMeta)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionKeys = append(m.PartitionKeys, &Expr{})
			if err := m.PartitionKeys[len(m.PartitionKeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Child", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Child == nil {
				m.Child = &Executor{}
			}
			if err := m.Child.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, &FieldType{})
			if err := m.Types[len(m.Types)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllFieldTypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllFieldTypes = append(m.AllFieldTypes, &FieldType{})
			if err := m.AllFieldTypes[len(m.AllFieldTypes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compression", wireType)
			}
			m.Compression = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Compression |= CompressionMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpstreamCteTaskMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpstreamCteTaskMeta = append(m.UpstreamCteTaskMeta, &EncodedBytesSlice{})
			if err := m.UpstreamCteTaskMeta[len(m.UpstreamCteTaskMeta)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SameZoneFlag = append(m.SameZoneFlag, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExecutor
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExecutor
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.SameZoneFlag) == 0 {
					m.SameZoneFlag = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExecutor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SameZoneFlag = append(m.SameZoneFlag, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SameZoneFlag", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncodedBytesSlice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncodedBytesSlice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncodedBytesSlice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncodedTasks", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncodedTasks = append(m.EncodedTasks, make([]byte, postIndex-iNdEx))
			copy(m.EncodedTasks[len(m.EncodedTasks)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExchangeReceiver) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExchangeReceiver: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExchangeReceiver: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncodedTaskMeta", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncodedTaskMeta = append(m.EncodedTaskMeta, make([]byte, postIndex-iNdEx))
			copy(m.EncodedTaskMeta[len(m.EncodedTaskMeta)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldTypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FieldTypes = append(m.FieldTypes, &FieldType{})
			if err := m.FieldTypes[len(m.FieldTypes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tp", wireType)
			}
			var v ExchangeType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= ExchangeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Tp = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalCtePrdocuerTaskMeta", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginalCtePrdocuerTaskMeta = append(m.OriginalCtePrdocuerTaskMeta, make([]byte, postIndex-iNdEx))
			copy(m.OriginalCtePrdocuerTaskMeta[len(m.OriginalCtePrdocuerTaskMeta)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SameZoneFlag = append(m.SameZoneFlag, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExecutor
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExecutor
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.SameZoneFlag) == 0 {
					m.SameZoneFlag = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExecutor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SameZoneFlag = append(m.SameZoneFlag, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SameZoneFlag", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ANNQueryInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ANNQueryInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ANNQueryInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryType", wireType)
			}
			m.QueryType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueryType |= ANNQueryType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistanceMetric", wireType)
			}
			m.DistanceMetric = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DistanceMetric |= VectorDistanceMetric(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopK", wireType)
			}
			m.TopK = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopK |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColumnName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedColumnId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeprecatedColumnId = &v
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefVecF32", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefVecF32 = append(m.RefVecF32[:0], dAtA[iNdEx:postIndex]...)
			if m.RefVecF32 == nil {
				m.RefVecF32 = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			m.IndexId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDistance", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MaxDistance = float64(math.Float64frombits(v))
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HnswEfSearch", wireType)
			}
			m.HnswEfSearch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HnswEfSearch |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Column.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableDistanceProj", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableDistanceProj = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InvertedQueryInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InvertedQueryInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InvertedQueryInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			m.IndexId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnId", wireType)
			}
			m.ColumnId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnarIndexInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnarIndexInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnarIndexInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexType", wireType)
			}
			m.IndexType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexType |= ColumnarIndexType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnnQueryInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ANNQueryInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Index = &ColumnarIndexInfo_AnnQueryInfo{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertQueryInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &InvertedQueryInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Index = &ColumnarIndexInfo_InvertQueryInfo{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableScan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableScan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableScan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &ColumnInfo{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Desc = bool(v != 0)
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PrimaryColumnIds = append(m.PrimaryColumnIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExecutor
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExecutor
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PrimaryColumnIds) == 0 {
					m.PrimaryColumnIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExecutor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PrimaryColumnIds = append(m.PrimaryColumnIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryColumnIds", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextReadEngine", wireType)
			}
			m.NextReadEngine = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextReadEngine |= EngineType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ranges = append(m.Ranges, KeyRange{})
			if err := m.Ranges[len(m.Ranges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PrimaryPrefixColumnIds = append(m.PrimaryPrefixColumnIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExecutor
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExecutor
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PrimaryPrefixColumnIds) == 0 {
					m.PrimaryPrefixColumnIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExecutor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PrimaryPrefixColumnIds = append(m.PrimaryPrefixColumnIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryPrefixColumnIds", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeepOrder", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.KeepOrder = &b
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFastScan", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsFastScan = &b
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushedDownFilterConditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PushedDownFilterConditions = append(m.PushedDownFilterConditions, &Expr{})
			if err := m.PushedDownFilterConditions[len(m.PushedDownFilterConditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeFilterList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuntimeFilterList = append(m.RuntimeFilterList, &RuntimeFilter{})
			if err := m.RuntimeFilterList[len(m.RuntimeFilterList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxWaitTimeMs", wireType)
			}
			m.MaxWaitTimeMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxWaitTimeMs |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedAnnQuery", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeprecatedAnnQuery == nil {
				m.DeprecatedAnnQuery = &ANNQueryInfo{}
			}
			if err := m.DeprecatedAnnQuery.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedColumnarIndexes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsedColumnarIndexes = append(m.UsedColumnarIndexes, &ColumnarIndexInfo{})
			if err := m.UsedColumnarIndexes[len(m.UsedColumnarIndexes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionTableScan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionTableScan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionTableScan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &ColumnInfo{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Desc = bool(v != 0)
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PrimaryColumnIds = append(m.PrimaryColumnIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExecutor
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExecutor
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PrimaryColumnIds) == 0 {
					m.PrimaryColumnIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExecutor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PrimaryColumnIds = append(m.PrimaryColumnIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryColumnIds", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PrimaryPrefixColumnIds = append(m.PrimaryPrefixColumnIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExecutor
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExecutor
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PrimaryPrefixColumnIds) == 0 {
					m.PrimaryPrefixColumnIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExecutor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PrimaryPrefixColumnIds = append(m.PrimaryPrefixColumnIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryPrefixColumnIds", wireType)
			}
		case 6:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PartitionIds = append(m.PartitionIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExecutor
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExecutor
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PartitionIds) == 0 {
					m.PartitionIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExecutor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PartitionIds = append(m.PartitionIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionIds", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFastScan", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsFastScan = &b
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushedDownFilterConditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PushedDownFilterConditions = append(m.PushedDownFilterConditions, &Expr{})
			if err := m.PushedDownFilterConditions[len(m.PushedDownFilterConditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeFilterList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuntimeFilterList = append(m.RuntimeFilterList, &RuntimeFilter{})
			if err := m.RuntimeFilterList[len(m.RuntimeFilterList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxWaitTimeMs", wireType)
			}
			m.MaxWaitTimeMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxWaitTimeMs |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedAnnQuery", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeprecatedAnnQuery == nil {
				m.DeprecatedAnnQuery = &ANNQueryInfo{}
			}
			if err := m.DeprecatedAnnQuery.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedColumnarIndexes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsedColumnarIndexes = append(m.UsedColumnarIndexes, &ColumnarIndexInfo{})
			if err := m.UsedColumnarIndexes[len(m.UsedColumnarIndexes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Join) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Join: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Join: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinType", wireType)
			}
			m.JoinType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinType |= JoinType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinExecType", wireType)
			}
			m.JoinExecType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinExecType |= JoinExecType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &Executor{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InnerIdx", wireType)
			}
			m.InnerIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InnerIdx |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftJoinKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeftJoinKeys = append(m.LeftJoinKeys, &Expr{})
			if err := m.LeftJoinKeys[len(m.LeftJoinKeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightJoinKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RightJoinKeys = append(m.RightJoinKeys, &Expr{})
			if err := m.RightJoinKeys[len(m.RightJoinKeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProbeTypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProbeTypes = append(m.ProbeTypes, &FieldType{})
			if err := m.ProbeTypes[len(m.ProbeTypes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildTypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildTypes = append(m.BuildTypes, &FieldType{})
			if err := m.BuildTypes[len(m.BuildTypes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftConditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeftConditions = append(m.LeftConditions, &Expr{})
			if err := m.LeftConditions[len(m.LeftConditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightConditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RightConditions = append(m.RightConditions, &Expr{})
			if err := m.RightConditions[len(m.RightConditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherConditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OtherConditions = append(m.OtherConditions, &Expr{})
			if err := m.OtherConditions[len(m.OtherConditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherEqConditionsFromIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OtherEqConditionsFromIn = append(m.OtherEqConditionsFromIn, &Expr{})
			if err := m.OtherEqConditionsFromIn[len(m.OtherEqConditionsFromIn)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNullAwareSemiJoin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsNullAwareSemiJoin = &b
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeFilterList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuntimeFilterList = append(m.RuntimeFilterList, &RuntimeFilter{})
			if err := m.RuntimeFilterList[len(m.RuntimeFilterList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RuntimeFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RuntimeFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RuntimeFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceExprList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceExprList = append(m.SourceExprList, &Expr{})
			if err := m.SourceExprList[len(m.SourceExprList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetExprList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetExprList = append(m.TargetExprList, &Expr{})
			if err := m.TargetExprList[len(m.TargetExprList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceExecutorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceExecutorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetExecutorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetExecutorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RfType", wireType)
			}
			m.RfType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RfType |= RuntimeFilterType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RfMode", wireType)
			}
			m.RfMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RfMode |= RuntimeFilterMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexScan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexScan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexScan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			m.IndexId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &ColumnInfo{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Desc = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unique", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Unique = &b
		case 6:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PrimaryColumnIds = append(m.PrimaryColumnIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExecutor
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthExecutor
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PrimaryColumnIds) == 0 {
					m.PrimaryColumnIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExecutor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PrimaryColumnIds = append(m.PrimaryColumnIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryColumnIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Selection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Selection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Selection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &Expr{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpnConditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RpnConditions = append(m.RpnConditions, &RpnExpr{})
			if err := m.RpnConditions[len(m.RpnConditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Child", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Child == nil {
				m.Child = &Executor{}
			}
			if err := m.Child.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Projection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Projection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Projection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exprs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exprs = append(m.Exprs, &Expr{})
			if err := m.Exprs[len(m.Exprs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpnExprs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RpnExprs = append(m.RpnExprs, &RpnExpr{})
			if err := m.RpnExprs[len(m.RpnExprs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Child", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Child == nil {
				m.Child = &Executor{}
			}
			if err := m.Child.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Aggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Aggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Aggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupBy = append(m.GroupBy, &Expr{})
			if err := m.GroupBy[len(m.GroupBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggFunc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AggFunc = append(m.AggFunc, &Expr{})
			if err := m.AggFunc[len(m.AggFunc)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Streamed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Streamed = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpnGroupBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RpnGroupBy = append(m.RpnGroupBy, &RpnExpr{})
			if err := m.RpnGroupBy[len(m.RpnGroupBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpnAggFunc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RpnAggFunc = append(m.RpnAggFunc, &RpnExpr{})
			if err := m.RpnAggFunc[len(m.RpnAggFunc)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Child", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Child == nil {
				m.Child = &Executor{}
			}
			if err := m.Child.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreAggMode", wireType)
			}
			var v TiFlashPreAggMode
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= TiFlashPreAggMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PreAggMode = &v
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopN) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopN: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopN: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderBy = append(m.OrderBy, &ByItem{})
			if err := m.OrderBy[len(m.OrderBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Child", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Child == nil {
				m.Child = &Executor{}
			}
			if err := m.Child.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionBy = append(m.PartitionBy, &ByItem{})
			if err := m.PartitionBy[len(m.PartitionBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Limit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Limit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Limit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Child", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Child == nil {
				m.Child = &Executor{}
			}
			if err := m.Child.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionBy = append(m.PartitionBy, &ByItem{})
			if err := m.PartitionBy[len(m.PartitionBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Kill) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Kill: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Kill: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnID", wireType)
			}
			m.ConnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Query = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecutorExecutionSummary) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecutorExecutionSummary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecutorExecutionSummary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeProcessedNs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimeProcessedNs = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumProducedRows", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NumProducedRows = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumIterations", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NumIterations = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ExecutorId = &s
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Concurrency", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Concurrency = &v
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TiflashScanContext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TiFlashScanContext{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DetailInfo = &ExecutorExecutionSummary_TiflashScanContext{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuConsumption", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuConsumption = append(m.RuConsumption[:0], dAtA[iNdEx:postIndex]...)
			if m.RuConsumption == nil {
				m.RuConsumption = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TiflashWaitSummary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TiflashWaitSummary == nil {
				m.TiflashWaitSummary = &TiFlashWaitSummary{}
			}
			if err := m.TiflashWaitSummary.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TiflashNetworkSummary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TiflashNetworkSummary == nil {
				m.TiflashNetworkSummary = &TiFlashNetWorkSummary{}
			}
			if err := m.TiflashNetworkSummary.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TiFlashExecutionInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TiFlashExecutionInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TiFlashExecutionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutionSummaries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExecutionSummaries = append(m.ExecutionSummaries, &ExecutorExecutionSummary{})
			if err := m.ExecutionSummaries[len(m.ExecutionSummaries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TiFlashRegionNumOfInstance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TiFlashRegionNumOfInstance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TiFlashRegionNumOfInstance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.InstanceId = &s
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionNum", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RegionNum = &v
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TiFlashScanContext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TiFlashScanContext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TiFlashScanContext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DmfileScannedPacks", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DmfileScannedPacks = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DmfileSkippedPacks", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DmfileSkippedPacks = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DmfileDataScannedRows", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DmfileDataScannedRows = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DmfileDataSkippedRows", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DmfileDataSkippedRows = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDmfileRsLoadMs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalDmfileRsLoadMs = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDmfileReadMs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalDmfileReadMs = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBuildSnapshotMs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalBuildSnapshotMs = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalRegions", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LocalRegions = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteRegions", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RemoteRegions = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserReadBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UserReadBytes = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalLearnerReadMs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalLearnerReadMs = &v
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisaggReadCacheHitBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisaggReadCacheHitBytes = &v
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisaggReadCacheMissBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisaggReadCacheMissBytes = &v
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDmfileRsCheckMs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalDmfileRsCheckMs = &v
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaleReadRegions", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StaleReadRegions = &v
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Segments", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Segments = &v
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadTasks", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadTasks = &v
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeltaRows", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeltaRows = &v
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeltaBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeltaBytes = &v
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MvccInputRows", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MvccInputRows = &v
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MvccInputBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MvccInputBytes = &v
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MvccOutputRows", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MvccOutputRows = &v
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LmSkipRows", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LmSkipRows = &v
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBuildInputstreamMs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalBuildInputstreamMs = &v
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBuildBitmapMs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalBuildBitmapMs = &v
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinLocalStreamMs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MinLocalStreamMs = &v
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLocalStreamMs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxLocalStreamMs = &v
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinRemoteStreamMs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MinRemoteStreamMs = &v
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRemoteStreamMs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxRemoteStreamMs = &v
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionsOfInstance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegionsOfInstance = append(m.RegionsOfInstance, &TiFlashRegionNumOfInstance{})
			if err := m.RegionsOfInstance[len(m.RegionsOfInstance)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DmfileMvccScannedRows", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DmfileMvccScannedRows = &v
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DmfileMvccSkippedRows", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DmfileMvccSkippedRows = &v
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DmfileLmFilterScannedRows", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DmfileLmFilterScannedRows = &v
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DmfileLmFilterSkippedRows", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DmfileLmFilterSkippedRows = &v
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalVectorIdxLoadFromS3", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalVectorIdxLoadFromS3 = &v
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalVectorIdxLoadFromDisk", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalVectorIdxLoadFromDisk = &v
		case 102:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalVectorIdxLoadFromCache", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalVectorIdxLoadFromCache = &v
		case 103:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalVectorIdxLoadTimeMs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalVectorIdxLoadTimeMs = &v
		case 104:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalVectorIdxSearchTimeMs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalVectorIdxSearchTimeMs = &v
		case 105:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalVectorIdxSearchVisitedNodes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalVectorIdxSearchVisitedNodes = &v
		case 106:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalVectorIdxSearchDiscardedNodes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalVectorIdxSearchDiscardedNodes = &v
		case 107:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalVectorIdxReadVecTimeMs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalVectorIdxReadVecTimeMs = &v
		case 108:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalVectorIdxReadOthersTimeMs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalVectorIdxReadOthersTimeMs = &v
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TiFlashWaitSummary) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TiFlashWaitSummary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TiFlashWaitSummary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinTSOWaitNs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MinTSOWaitNs = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PipelineQueueWaitNs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PipelineQueueWaitNs = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PipelineBreakerWaitNs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PipelineBreakerWaitNs = &v
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TiFlashNetWorkSummary) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TiFlashNetWorkSummary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TiFlashNetWorkSummary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InnerZoneSendBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InnerZoneSendBytes = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InnerZoneReceiveBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InnerZoneReceiveBytes = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterZoneSendBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InterZoneSendBytes = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterZoneReceiveBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InterZoneReceiveBytes = &v
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sort) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sort: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sort: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ByItems = append(m.ByItems, &ByItem{})
			if err := m.ByItems[len(m.ByItems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPartialSort", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsPartialSort = &b
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Child", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Child == nil {
				m.Child = &Executor{}
			}
			if err := m.Child.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WindowFrameBound) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WindowFrameBound: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WindowFrameBound: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= WindowBoundType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unbounded", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Unbounded = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Offset = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CalcFuncs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CalcFuncs = append(m.CalcFuncs, &Expr{})
			if err := m.CalcFuncs[len(m.CalcFuncs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrameRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FrameRange == nil {
				m.FrameRange = &Expr{}
			}
			if err := m.FrameRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmpDataType", wireType)
			}
			var v RangeCmpDataType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= RangeCmpDataType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CmpDataType = &v
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WindowFrame) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WindowFrame: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WindowFrame: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= WindowFrameType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Start == nil {
				m.Start = &WindowFrameBound{}
			}
			if err := m.Start.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.End == nil {
				m.End = &WindowFrameBound{}
			}
			if err := m.End.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Window) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Window: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Window: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FuncDesc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FuncDesc = append(m.FuncDesc, &Expr{})
			if err := m.FuncDesc[len(m.FuncDesc)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionBy = append(m.PartitionBy, &ByItem{})
			if err := m.PartitionBy[len(m.PartitionBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderBy = append(m.OrderBy, &ByItem{})
			if err := m.OrderBy[len(m.OrderBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frame", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Frame == nil {
				m.Frame = &WindowFrame{}
			}
			if err := m.Frame.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Child", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Child == nil {
				m.Child = &Executor{}
			}
			if err := m.Child.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupingExpr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupingExpr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupingExpr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupingExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupingExpr = append(m.GroupingExpr, &Expr{})
			if err := m.GroupingExpr[len(m.GroupingExpr)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupingSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupingSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupingSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupingExprs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupingExprs = append(m.GroupingExprs, &GroupingExpr{})
			if err := m.GroupingExprs[len(m.GroupingExprs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Expand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Expand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Expand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupingSets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupingSets = append(m.GroupingSets, &GroupingSet{})
			if err := m.GroupingSets[len(m.GroupingSets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Child", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Child == nil {
				m.Child = &Executor{}
			}
			if err := m.Child.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Version = &v
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExprSlice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExprSlice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExprSlice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exprs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exprs = append(m.Exprs, &Expr{})
			if err := m.Exprs[len(m.Exprs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Expand2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Expand2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Expand2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjExprs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjExprs = append(m.ProjExprs, &ExprSlice{})
			if err := m.ProjExprs[len(m.ProjExprs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeneratedOutputNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GeneratedOutputNames = append(m.GeneratedOutputNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Child", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Child == nil {
				m.Child = &Executor{}
			}
			if err := m.Child.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipExecutor(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowExecutor
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowExecutor
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthExecutor
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupExecutor
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthExecutor
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthExecutor        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowExecutor          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupExecutor = fmt.Errorf("proto: unexpected end of group")
)
